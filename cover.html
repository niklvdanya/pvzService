
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>gateway: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">gitlab.ozon.dev/safariproxd/homework/cmd/gateway/main.go (0.0%)</option>
				
				<option value="file1">gitlab.ozon.dev/safariproxd/homework/cmd/pvz/main.go (0.0%)</option>
				
				<option value="file2">gitlab.ozon.dev/safariproxd/homework/cmd/swagger/main.go (0.0%)</option>
				
				<option value="file3">gitlab.ozon.dev/safariproxd/homework/internal/adapter/cli/add_com.go (0.0%)</option>
				
				<option value="file4">gitlab.ozon.dev/safariproxd/homework/internal/adapter/cli/cli.go (0.0%)</option>
				
				<option value="file5">gitlab.ozon.dev/safariproxd/homework/internal/adapter/cli/errors.go (0.0%)</option>
				
				<option value="file6">gitlab.ozon.dev/safariproxd/homework/internal/adapter/cli/get_orders.go (0.0%)</option>
				
				<option value="file7">gitlab.ozon.dev/safariproxd/homework/internal/adapter/cli/import_orders.go (0.0%)</option>
				
				<option value="file8">gitlab.ozon.dev/safariproxd/homework/internal/adapter/cli/list_orders.go (0.0%)</option>
				
				<option value="file9">gitlab.ozon.dev/safariproxd/homework/internal/adapter/cli/mapping.go (20.0%)</option>
				
				<option value="file10">gitlab.ozon.dev/safariproxd/homework/internal/adapter/cli/process_orders.go (0.0%)</option>
				
				<option value="file11">gitlab.ozon.dev/safariproxd/homework/internal/adapter/cli/register.go (0.0%)</option>
				
				<option value="file12">gitlab.ozon.dev/safariproxd/homework/internal/adapter/cli/return_order_courier.go (0.0%)</option>
				
				<option value="file13">gitlab.ozon.dev/safariproxd/homework/internal/adapter/cli/scroll_orders.go (0.0%)</option>
				
				<option value="file14">gitlab.ozon.dev/safariproxd/homework/internal/adapter/grpc/errors.go (0.0%)</option>
				
				<option value="file15">gitlab.ozon.dev/safariproxd/homework/internal/adapter/grpc/handler.go (0.0%)</option>
				
				<option value="file16">gitlab.ozon.dev/safariproxd/homework/internal/adapter/grpc/mw/middleware.go (0.0%)</option>
				
				<option value="file17">gitlab.ozon.dev/safariproxd/homework/internal/adapter/grpc/server.go (0.0%)</option>
				
				<option value="file18">gitlab.ozon.dev/safariproxd/homework/internal/adapter/grpc/util.go (0.0%)</option>
				
				<option value="file19">gitlab.ozon.dev/safariproxd/homework/internal/app/accept_order.go (100.0%)</option>
				
				<option value="file20">gitlab.ozon.dev/safariproxd/homework/internal/app/get_orders.go (88.5%)</option>
				
				<option value="file21">gitlab.ozon.dev/safariproxd/homework/internal/app/import_orders.go (0.0%)</option>
				
				<option value="file22">gitlab.ozon.dev/safariproxd/homework/internal/app/issue_orders.go (100.0%)</option>
				
				<option value="file23">gitlab.ozon.dev/safariproxd/homework/internal/app/mock/order_repository_mock.go (34.0%)</option>
				
				<option value="file24">gitlab.ozon.dev/safariproxd/homework/internal/app/return_order_client.go (0.0%)</option>
				
				<option value="file25">gitlab.ozon.dev/safariproxd/homework/internal/app/return_order_courier.go (100.0%)</option>
				
				<option value="file26">gitlab.ozon.dev/safariproxd/homework/internal/app/service.go (80.0%)</option>
				
				<option value="file27">gitlab.ozon.dev/safariproxd/homework/internal/app/tests_utils.go (100.0%)</option>
				
				<option value="file28">gitlab.ozon.dev/safariproxd/homework/internal/config/config.go (0.0%)</option>
				
				<option value="file29">gitlab.ozon.dev/safariproxd/homework/internal/domain/errors.go (28.6%)</option>
				
				<option value="file30">gitlab.ozon.dev/safariproxd/homework/internal/domain/order.go (100.0%)</option>
				
				<option value="file31">gitlab.ozon.dev/safariproxd/homework/internal/repository/postgres/crud.go (0.0%)</option>
				
				<option value="file32">gitlab.ozon.dev/safariproxd/homework/internal/repository/postgres/getters.go (0.0%)</option>
				
				<option value="file33">gitlab.ozon.dev/safariproxd/homework/internal/repository/postgres/order_pg_repo.go (0.0%)</option>
				
				<option value="file34">gitlab.ozon.dev/safariproxd/homework/pkg/api/contract.pb.go (0.0%)</option>
				
				<option value="file35">gitlab.ozon.dev/safariproxd/homework/pkg/api/contract.pb.gw.go (0.0%)</option>
				
				<option value="file36">gitlab.ozon.dev/safariproxd/homework/pkg/api/contract.pb.validate.go (0.0%)</option>
				
				<option value="file37">gitlab.ozon.dev/safariproxd/homework/pkg/api/contract_grpc.pb.go (0.0%)</option>
				
				<option value="file38">gitlab.ozon.dev/safariproxd/homework/pkg/db/client.go (0.0%)</option>
				
				<option value="file39">gitlab.ozon.dev/safariproxd/homework/pkg/db/transaction.go (0.0%)</option>
				
				<option value="file40">gitlab.ozon.dev/safariproxd/homework/vendor.protogen/protoc-gen-openapiv2/options/annotations.pb.go (0.0%)</option>
				
				<option value="file41">gitlab.ozon.dev/safariproxd/homework/vendor.protogen/protoc-gen-openapiv2/options/openapiv2.pb.go (0.0%)</option>
				
				<option value="file42">gitlab.ozon.dev/safariproxd/homework/vendor.protogen/validate/validate.pb.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "log"
        "net/http"

        "github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
        "gitlab.ozon.dev/safariproxd/homework/internal/config"
        "gitlab.ozon.dev/safariproxd/homework/pkg/api"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
)

func main() <span class="cov0" title="0">{
        cfg, err := config.Load("config/config.yaml")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("config: %v", err)
        }</span>
        <span class="cov0" title="0">ctx := context.Background()
        mux := runtime.NewServeMux()
        err = api.RegisterOrdersServiceHandlerFromEndpoint(ctx, mux, cfg.Service.GRPCAddress, []grpc.DialOption{
                grpc.WithTransportCredentials(insecure.NewCredentials()),
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("RegisterOrdersServiceHandlerFromEndpoint err: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf("http server running on %v", cfg.Service.HTTPAddress)
        if err := http.ListenAndServe(cfg.Service.HTTPAddress, mux); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("http server running err: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "log/slog"
        "net"
        "os"
        "time"

        "github.com/ulule/limiter/v3"
        "github.com/ulule/limiter/v3/drivers/store/memory"
        server "gitlab.ozon.dev/safariproxd/homework/internal/adapter/grpc"
        "gitlab.ozon.dev/safariproxd/homework/internal/adapter/grpc/mw"
        "gitlab.ozon.dev/safariproxd/homework/internal/app"
        "gitlab.ozon.dev/safariproxd/homework/internal/config"
        "gitlab.ozon.dev/safariproxd/homework/internal/repository/postgres"
        "gitlab.ozon.dev/safariproxd/homework/pkg/db"
        "google.golang.org/grpc"
        "google.golang.org/grpc/reflection"
)

func main() <span class="cov0" title="0">{
        cfg, err := config.Load("config/config.yaml")
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Config load failed", "error", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">dbCfg := db.Config{
                ReadDSN:  cfg.ReadDSN(),
                WriteDSN: cfg.WriteDSN(),
                MaxOpen:  cfg.DB.Pool.MaxOpen,
                MaxIdle:  cfg.DB.Pool.MaxIdle,
        }
        client, err := db.NewClient(dbCfg)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("DB client creation failed", "error", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer client.Close()
        orderRepo := postgres.NewOrderRepository(client)
        pvzService := app.NewPVZService(orderRepo, time.Now) // Передаем time.Now как nowFn
        lis, err := net.Listen("tcp", cfg.Service.GRPCAddress)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to listen", "error", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">limiterInstance := limiter.New(memory.NewStore(), limiter.Rate{
                Period: time.Second,
                Limit:  5,
        })
        ordersServer := server.NewOrdersServer(pvzService)

        grpcServer := grpc.NewServer(
                grpc.ChainUnaryInterceptor(
                        mw.TimeoutInterceptor(cfg.Service.Timeout),
                        mw.LoggingInterceptor(),
                        mw.ValidationInterceptor(),
                        mw.ErrorMappingInterceptor(),
                        mw.RateLimiterInterceptor(limiterInstance),
                ),
        )

        reflection.Register(grpcServer)
        ordersServer.Register(grpcServer)

        slog.Info("gRPC server listening on", "address", cfg.Service.GRPCAddress)
        if err := grpcServer.Serve(lis); err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to serve", "error", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "log"
        "net/http"
        "os"

        "github.com/go-chi/chi/v5"
        httpSwagger "github.com/swaggo/http-swagger"
        "gitlab.ozon.dev/safariproxd/homework/internal/config"
)

func main() <span class="cov0" title="0">{
        cfg, err := config.Load("config/config.yaml")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("config: %v", err)
        }</span>
        <span class="cov0" title="0">mux := chi.NewMux()
        mux.HandleFunc("/swagger.json", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                b, err := os.ReadFile("./pkg/api/contract.swagger.json")
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                        log.Printf("failed to read swagger.json: %v", err)
                        return
                }</span>
                <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
                if _, err := w.Write(b); err != nil </span><span class="cov0" title="0">{
                        log.Printf("failed to write swagger.json response: %v", err)
                }</span>
        })

        <span class="cov0" title="0">mux.HandleFunc("/swagger/*", httpSwagger.Handler(
                httpSwagger.URL("/swagger.json"),
        ))

        log.Printf("Listening on %s", cfg.Service.SwaggerAddress)
        if err := http.ListenAndServe(cfg.Service.SwaggerAddress, mux); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to listen and serve: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package cli

import (
        "fmt"

        "github.com/spf13/cobra"
        "gitlab.ozon.dev/safariproxd/homework/internal/domain"
)

func (a *CLIAdapter) AddComm(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        receiverID, err := cmd.Flags().GetUint64("user-id")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("flag.GetUint64: %w", err)
        }</span>
        <span class="cov0" title="0">orderID, err := cmd.Flags().GetUint64("order-id")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("flag.GetUint64: %w", err)
        }</span>
        <span class="cov0" title="0">storageUntilStr, err := cmd.Flags().GetString("expires")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("flag.GetString: %w", err)
        }</span>
        <span class="cov0" title="0">weight, err := cmd.Flags().GetFloat64("weight")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("flag.GetFloat64: %w", err)
        }</span>
        <span class="cov0" title="0">price, err := cmd.Flags().GetFloat64("price")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("flag.GetFloat64: %w", err)
        }</span>
        <span class="cov0" title="0">packageType, err := cmd.Flags().GetString("package")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("flag.GetString: %w", err)
        }</span>

        <span class="cov0" title="0">storageUntil, err := MapStringToTime(storageUntilStr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("time.Parse: %w", err)
        }</span>
        <span class="cov0" title="0">req := domain.AcceptOrderRequest{
                ReceiverID:   receiverID,
                OrderID:      orderID,
                StorageUntil: storageUntil,
                Weight:       weight,
                Price:        price,
                PackageType:  packageType,
        }
        totalPrice, err := a.appService.AcceptOrder(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fmt.Printf("ORDER_ACCEPTED: %d\n", orderID)
        fmt.Printf("PACKAGE: %s\n", packageType)
        fmt.Printf("TOTAL_PRICE: %.2f\n", totalPrice)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package cli

import (
        "bufio"
        "fmt"
        "log"
        "os"
        "strings"

        "github.com/spf13/cobra"
        "gitlab.ozon.dev/safariproxd/homework/internal/domain"
)

type OrderService interface {
        AcceptOrder(req domain.AcceptOrderRequest) (float64, error)
        ReturnOrderToDelivery(orderID uint64) error
        IssueOrdersToClient(receiverID uint64, orderIDs []uint64) error
        ReturnOrdersFromClient(receiverID uint64, orderIDs []uint64) error
        GetReceiverOrders(receiverID uint64, inPVZ bool, lastN, page, limit uint64) ([]*domain.Order, uint64, error)
        GetReceiverOrdersScroll(receiverID uint64, lastID, limit uint64) ([]*domain.Order, uint64, error)
        GetReturnedOrders(page, limit uint64) ([]*domain.Order, uint64, error)
        GetOrderHistory() ([]*domain.Order, error)
        ImportOrders(orders []domain.OrderToImport) (uint64, error)
}

type CLIAdapter struct {
        appService OrderService
        debug      bool
}

func NewCLIAdapter(appService OrderService, rootCmd *cobra.Command, debugMode bool) *CLIAdapter <span class="cov0" title="0">{
        a := &amp;CLIAdapter{
                appService: appService,
                debug:      debugMode,
        }
        a.registerCommands(rootCmd)
        return a
}</span>

func (a *CLIAdapter) Run(rootCmd *cobra.Command) error <span class="cov0" title="0">{
        fmt.Println("Welcome to PVZ system.")
        scanner := bufio.NewScanner(os.Stdin)
        for </span><span class="cov0" title="0">{
                fmt.Print("pvz&gt; ")

                if !scanner.Scan() </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">line := strings.TrimSpace(scanner.Text())
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if line == "exit" </span><span class="cov0" title="0">{
                        fmt.Println("Exiting PVZ system.")
                        os.Exit(0)
                }</span>

                <span class="cov0" title="0">rootCmd.SetArgs(strings.Fields(line))
                if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Command execution error: %v", err)
                        fmt.Fprintf(os.Stderr, "%s\n", mapError(err))
                        if a.debug </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "DEBUG: %v\n", err)
                        }</span>
                }
        }
        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error reading from stdin: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package cli

import (
        "errors"
        "fmt"
        "strings"

        "gitlab.ozon.dev/safariproxd/homework/internal/domain"
        "go.uber.org/multierr"
)

func NotFoundErrorError(message string) error <span class="cov0" title="0">{
        return fmt.Errorf("ERROR: ORDER_NOT_FOUND: %s", message)
}</span>

func AlreadyExistsError(message string) error <span class="cov0" title="0">{
        return fmt.Errorf("ERROR: ORDER_ALREADY_EXISTS: %s", message)
}</span>

func StorageExpiredError(message string) error <span class="cov0" title="0">{
        return fmt.Errorf("ERROR: STORAGE_EXPIRED: %s", message)
}</span>

func ValidationFailedError(message string) error <span class="cov0" title="0">{
        return fmt.Errorf("ERROR: VALIDATION_FAILED: %s", message)
}</span>

func StorageNotExpiredError(message string) error <span class="cov0" title="0">{
        return fmt.Errorf("ERROR: STORAGE_NOT_EXPIRED: %s", message)
}</span>

func WeightTooHeavyError(message string) error <span class="cov0" title="0">{
        return fmt.Errorf("ERROR: WEIGHT_TOO_HEAVY: %s", message)
}</span>

func InternalError(err error) error <span class="cov0" title="0">{
        return fmt.Errorf("INTERNAL ERROR: %w", err)
}</span>

func mapError(err error) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // для вложенных ошибок multierr
        <span class="cov0" title="0">if errs := multierr.Errors(err); len(errs) &gt; 1 </span><span class="cov0" title="0">{
                var userMsgs []string
                for _, e := range errs </span><span class="cov0" title="0">{
                        userMsgs = append(userMsgs, processSingleError(e).Error())
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("%s", strings.Join(userMsgs, "\n"))</span>
        }

        <span class="cov0" title="0">return processSingleError(err)</span>
}

func processSingleError(err error) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var domainErr domain.Error
        if errors.As(err, &amp;domainErr) </span><span class="cov0" title="0">{
                switch domainErr.Code </span>{
                case domain.ErrorCodeNotFound:<span class="cov0" title="0">
                        return NotFoundErrorError(domainErr.Message)</span>
                case domain.ErrorCodeAlreadyExists:<span class="cov0" title="0">
                        return AlreadyExistsError(domainErr.Message)</span>
                case domain.ErrorCodeStorageExpired:<span class="cov0" title="0">
                        return StorageExpiredError(domainErr.Message)</span>
                case domain.ErrorCodeValidationFailed:<span class="cov0" title="0">
                        return ValidationFailedError(domainErr.Message)</span>
                case domain.ErrorCodeAlreadyGiven:<span class="cov0" title="0">
                        return ValidationFailedError(domainErr.Message)</span>
                case domain.ErrorCodeBelongsToOtherReceiver:<span class="cov0" title="0">
                        return ValidationFailedError(domainErr.Message)</span>
                case domain.ErrorCodeAlreadyInStorage:<span class="cov0" title="0">
                        return ValidationFailedError(domainErr.Message)</span>
                case domain.ErrorCodeReturnPeriodExpired:<span class="cov0" title="0">
                        return ValidationFailedError(domainErr.Message)</span>
                case domain.ErrorCodeStorageNotExpired:<span class="cov0" title="0">
                        return StorageNotExpiredError(domainErr.Message)</span>
                case domain.ErrorCodeUnavaliableReturned:<span class="cov0" title="0">
                        return ValidationFailedError(domainErr.Message)</span>
                case domain.ErrorCodeNilOrder:<span class="cov0" title="0">
                        return ValidationFailedError(domainErr.Message)</span>
                case domain.ErrorCodeInvalidPackage:<span class="cov0" title="0">
                        return ValidationFailedError(domainErr.Message)</span>
                case domain.ErrorCodeWeightTooHeavy:<span class="cov0" title="0">
                        return WeightTooHeavyError(domainErr.Message)</span>
                default:<span class="cov0" title="0">
                        return InternalError(err)</span>
                }
        }

        // для "сломанных" запросов по типу
        // accept-order --user-id --order-id=123 --expires 2025-05-31 --weight=10kg --price=1000
        <span class="cov0" title="0">msg := err.Error()
        switch </span>{
        case strings.Contains(msg, "invalid argument") &amp;&amp; strings.Contains(msg, "--user-id"):<span class="cov0" title="0">
                return ValidationFailedError("Invalid value for flag --user-id")</span>
        case strings.Contains(msg, "invalid argument") &amp;&amp; strings.Contains(msg, "--order-id"):<span class="cov0" title="0">
                return ValidationFailedError("Invalid value for flag --order-id")</span>
        case strings.Contains(msg, "invalid argument") &amp;&amp; strings.Contains(msg, "--weight"):<span class="cov0" title="0">
                return ValidationFailedError("Invalid value for flag --weight")</span>
        case strings.Contains(msg, "invalid argument") &amp;&amp; strings.Contains(msg, "--price"):<span class="cov0" title="0">
                return ValidationFailedError("Invalid value for flag --price")</span>
        case strings.Contains(msg, "invalid argument"):<span class="cov0" title="0">
                return ValidationFailedError("Invalid value for one of the flags")</span>
        case strings.Contains(msg, "flag needs an argument"):<span class="cov0" title="0">
                return ValidationFailedError("Missing value for a required flag")</span>
        case strings.Contains(msg, "unknown flag"):<span class="cov0" title="0">
                return ValidationFailedError("Unknown flag")</span>
        case strings.Contains(msg, "parsing"):<span class="cov0" title="0">
                return ValidationFailedError("Failed to parse flag value")</span>
        }

        <span class="cov0" title="0">return InternalError(err)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package cli

import (
        "fmt"

        "github.com/spf13/cobra"
)

func (a *CLIAdapter) GetReturnedOrders(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        page, err := cmd.Flags().GetUint64("page")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("flag.GetUint64: %w", err)
        }</span>
        <span class="cov0" title="0">limit, err := cmd.Flags().GetUint64("limit")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("flag.GetUint64: %w", err)
        }</span>

        <span class="cov0" title="0">if page == 0 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">if limit == 0 </span><span class="cov0" title="0">{
                limit = 10
        }</span>

        <span class="cov0" title="0">returnedOrderList, totalItems, err := a.appService.GetReturnedOrders(page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(returnedOrderList) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No returns found on this page or no returns in total.")
        }</span> else<span class="cov0" title="0"> {
                for _, order := range returnedOrderList </span><span class="cov0" title="0">{
                        fmt.Printf("RETURN: %d %d %s\n", order.OrderID, order.ReceiverID, order.LastUpdateTime.Format("2006-01-02"))
                }</span>
        }
        <span class="cov0" title="0">fmt.Printf("PAGE: %d LIMIT: %d\n", page, limit)
        fmt.Printf("TOTAL: %d\n", totalItems)
        return nil</span>
}

func (a *CLIAdapter) GetOrdersSortedByTime(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        allOrders, err := a.appService.GetOrderHistory()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(allOrders) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No orders in the system.")
                return nil
        }</span>

        <span class="cov0" title="0">for _, order := range allOrders </span><span class="cov0" title="0">{
                fmt.Printf("HISTORY: %d %s %s\n",
                        order.OrderID,
                        order.GetStatusString(),
                        MapTimeToString(order.LastUpdateTime),
                )
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package cli

import (
        "encoding/json"
        "fmt"
        "os"

        "github.com/spf13/cobra"
        "gitlab.ozon.dev/safariproxd/homework/internal/domain"
)

func (a *CLIAdapter) ImportOrdersComm(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        filePath, err := cmd.Flags().GetString("file")
        if err != nil || filePath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("flag.GetString: %w", err)
        }</span>

        <span class="cov0" title="0">data, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("os.ReadFile: %w", err)
        }</span>

        <span class="cov0" title="0">var ordersToImport []domain.OrderToImport
        if err := json.Unmarshal(data, &amp;ordersToImport); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("json.Unmarshal: %w", err)
        }</span>

        <span class="cov0" title="0">importedCount, err := a.appService.ImportOrders(ordersToImport)
        if err != nil </span><span class="cov0" title="0">{
                if importedCount &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("IMPORTED: %d orders successfully.\n", importedCount)
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">fmt.Printf("IMPORTED: %d\n", importedCount)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package cli

import (
        "fmt"

        "github.com/spf13/cobra"
)

func (a *CLIAdapter) ListOrdersComm(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        receiverID, err := cmd.Flags().GetUint64("user-id")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("flag.GetUint64: %w", err)
        }</span>
        <span class="cov0" title="0">inPvz, err := cmd.Flags().GetBool("in-pvz")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("flag.GetBool: %w", err)
        }</span>
        <span class="cov0" title="0">lastN, err := cmd.Flags().GetUint64("last")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("flag.GetUint64: %w", err)
        }</span>
        <span class="cov0" title="0">page, err := cmd.Flags().GetUint64("page")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("flag.GetUint64: %w", err)
        }</span>
        <span class="cov0" title="0">limit, err := cmd.Flags().GetUint64("limit")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("flag.GetUint64: %w", err)
        }</span>

        <span class="cov0" title="0">if lastN &gt; 0 &amp;&amp; (page &gt; 0 || limit &gt; 0) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid flags combination")
        }</span>

        <span class="cov0" title="0">if page == 0 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">if limit == 0 </span><span class="cov0" title="0">{
                limit = 10
        }</span>

        <span class="cov0" title="0">orders, totalItems, err := a.appService.GetReceiverOrders(receiverID, inPvz, lastN, page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(orders) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No orders found for this receiver with the given criteria.")
        }</span> else<span class="cov0" title="0"> {
                for _, order := range orders </span><span class="cov0" title="0">{
                        fmt.Printf("Order: %d Receiver: %d Status: %s Storage Limit: %s Package: %s Weight: %.2f Price: %.2f\n",
                                order.OrderID,
                                order.ReceiverID,
                                order.GetStatusString(),
                                MapTimeToString(order.StorageUntil),
                                MapPackageType(order.PackageType),
                                order.Weight,
                                order.Price,
                        )
                }</span>
        }
        <span class="cov0" title="0">fmt.Printf("TOTAL: %d\n", totalItems)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package cli

import (
        "time"
)

const TimeFormat = "2006-01-02"

func MapStringToTime(dateStr string) (time.Time, error) <span class="cov0" title="0">{
        return time.Parse(TimeFormat, dateStr)
}</span>

func MapTimeToString(t time.Time) string <span class="cov10" title="2">{
        return t.Format(TimeFormat)
}</span>

func MapPackageType(packageType string) string <span class="cov0" title="0">{
        if packageType == "" </span><span class="cov0" title="0">{
                return "none"
        }</span>
        <span class="cov0" title="0">return packageType</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package cli

import (
        "fmt"
        "strconv"
        "strings"

        "github.com/spf13/cobra"
)

func (a *CLIAdapter) ProcessOrders(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        receiverID, err := cmd.Flags().GetUint64("user-id")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("flag.GetUint64: %w", err)
        }</span>
        <span class="cov0" title="0">action, err := cmd.Flags().GetString("action")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("flag.GetString: %w", err)
        }</span>
        <span class="cov0" title="0">orderIDsStr, err := cmd.Flags().GetString("order-ids")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("flag.GetString: %w", err)
        }</span>

        <span class="cov0" title="0">if action != "issue" &amp;&amp; action != "return" </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid action '%s'", action)
        }</span>

        <span class="cov0" title="0">orderIDStrings := strings.Split(orderIDsStr, ",")
        orderIDs := make([]uint64, 0, len(orderIDStrings))
        for _, s := range orderIDStrings </span><span class="cov0" title="0">{
                orderID, err := strconv.ParseUint(s, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("strconv.ParseUint: %w", err)
                }</span>
                <span class="cov0" title="0">orderIDs = append(orderIDs, orderID)</span>
        }
        <span class="cov0" title="0">if action == "issue" </span><span class="cov0" title="0">{
                err = a.appService.IssueOrdersToClient(receiverID, orderIDs)
        }</span> else<span class="cov0" title="0"> {
                err = a.appService.ReturnOrdersFromClient(receiverID, orderIDs)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, orderID := range orderIDs </span><span class="cov0" title="0">{
                fmt.Printf("PROCESSED: %d\n", orderID)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package cli

import "github.com/spf13/cobra"

func (a *CLIAdapter) registerCommands(rootCmd *cobra.Command) <span class="cov0" title="0">{
        acceptOrderCmd := &amp;cobra.Command{
                Use:   "accept-order",
                Short: "Accepts an order from a courier.",
                RunE:  a.AddComm,
        }
        acceptOrderCmd.Flags().Uint64P("order-id", "", 0, "ID of the order")
        acceptOrderCmd.Flags().Uint64P("user-id", "", 0, "ID of the receiver")
        acceptOrderCmd.Flags().StringP("expires", "", "", "Storage expiration date (YYYY-MM-DD)")
        acceptOrderCmd.Flags().Float64P("weight", "", 0, "Weight of the order in kg")
        acceptOrderCmd.Flags().Float64P("price", "", 0, "Price of the order in RUB")
        acceptOrderCmd.Flags().StringP("package", "", "", "Package type: bag, box, film, bag+film, box+film")
        _ = acceptOrderCmd.MarkFlagRequired("order-id")
        _ = acceptOrderCmd.MarkFlagRequired("user-id")
        _ = acceptOrderCmd.MarkFlagRequired("expires")
        _ = acceptOrderCmd.MarkFlagRequired("weight")
        _ = acceptOrderCmd.MarkFlagRequired("price")
        rootCmd.AddCommand(acceptOrderCmd)

        returnOrderCmd := &amp;cobra.Command{
                Use:   "return-order",
                Short: "Returns an order to the courier.",
                RunE:  a.BackOrder,
        }
        returnOrderCmd.Flags().Uint64P("order-id", "", 0, "ID of the order to return")
        _ = returnOrderCmd.MarkFlagRequired("order-id")
        rootCmd.AddCommand(returnOrderCmd)

        processOrdersCmd := &amp;cobra.Command{
                Use:   "process-orders",
                Short: "Issues orders to a client or accepts returns from a client.",
                RunE:  a.ProcessOrders,
        }
        processOrdersCmd.Flags().Uint64P("user-id", "", 0, "ID of the receiver")
        processOrdersCmd.Flags().StringP("action", "", "", "Action to perform: 'issue' or 'return'")
        processOrdersCmd.Flags().StringP("order-ids", "", "", "Comma-separated list of order IDs")
        _ = processOrdersCmd.MarkFlagRequired("user-id")
        _ = processOrdersCmd.MarkFlagRequired("action")
        _ = processOrdersCmd.MarkFlagRequired("order-ids")
        rootCmd.AddCommand(processOrdersCmd)

        listOrdersCmd := &amp;cobra.Command{
                Use:   "list-orders",
                Short: "Lists orders for a specific receiver.",
                RunE:  a.ListOrdersComm,
        }
        listOrdersCmd.Flags().Uint64P("user-id", "", 0, "ID of the receiver")
        listOrdersCmd.Flags().BoolP("in-pvz", "", false, "Filter for orders currently in PVZ storage")
        listOrdersCmd.Flags().Uint64P("last", "", 0, "Show last N orders")
        listOrdersCmd.Flags().Uint64P("page", "", 0, "Page number for pagination")
        listOrdersCmd.Flags().Uint64P("limit", "", 0, "Items per page for pagination")
        _ = listOrdersCmd.MarkFlagRequired("user-id")
        rootCmd.AddCommand(listOrdersCmd)

        listReturnsCmd := &amp;cobra.Command{
                Use:   "list-returns",
                Short: "Lists all returned orders.",
                RunE:  a.GetReturnedOrders,
        }
        listReturnsCmd.Flags().Uint64P("page", "", 0, "Page number for pagination")
        listReturnsCmd.Flags().Uint64P("limit", "", 0, "Items per page for pagination")
        rootCmd.AddCommand(listReturnsCmd)

        orderHistoryCmd := &amp;cobra.Command{
                Use:   "order-history",
                Short: "Shows the history of all order status changes (sorted by last update time).",
                RunE:  a.GetOrdersSortedByTime,
        }
        rootCmd.AddCommand(orderHistoryCmd)

        importOrdersCmd := &amp;cobra.Command{
                Use:   "import-orders",
                Short: "Imports orders from a JSON file.",
                RunE:  a.ImportOrdersComm,
        }
        importOrdersCmd.Flags().StringP("file", "", "", "Path to the JSON file with orders")
        _ = importOrdersCmd.MarkFlagRequired("file")
        rootCmd.AddCommand(importOrdersCmd)

        scrollOrdersCmd := &amp;cobra.Command{
                Use:   "scroll-orders",
                Short: "Infinite orders scroll.",
                RunE:  a.ScrollOrdersComm,
        }
        scrollOrdersCmd.Flags().Uint64P("user-id", "", 0, "ID of the receiver")
        scrollOrdersCmd.Flags().Uint64P("limit", "", 20, "Number of orders to fetch at once")
        _ = scrollOrdersCmd.MarkFlagRequired("user-id")
        rootCmd.AddCommand(scrollOrdersCmd)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package cli

import (
        "fmt"

        "github.com/spf13/cobra"
)

func (a *CLIAdapter) BackOrder(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        orderID, err := cmd.Flags().GetUint64("order-id")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("flag.GetUint64: %w", err)
        }</span>

        <span class="cov0" title="0">err = a.appService.ReturnOrderToDelivery(orderID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">fmt.Printf("ORDER_RETURNED: %d\n", orderID)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package cli

import (
        "bufio"
        "fmt"
        "os"
        "strings"

        "github.com/spf13/cobra"
        "gitlab.ozon.dev/safariproxd/homework/internal/domain"
)

func (a *CLIAdapter) ScrollOrdersComm(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        receiverID, err := cmd.Flags().GetUint64("user-id")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("flag.GetUint64: %w", err)
        }</span>
        <span class="cov0" title="0">limit, err := cmd.Flags().GetUint64("limit")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("flag.GetUint64: %w", err)
        }</span>

        <span class="cov0" title="0">if limit == 0 </span><span class="cov0" title="0">{
                limit = 20
        }</span>

        <span class="cov0" title="0">var currentLastID uint64
        scanner := bufio.NewScanner(os.Stdin)
        orders, nextLastID, err := a.appService.GetReceiverOrdersScroll(receiverID, currentLastID, limit)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">a.printScrollOrders(orders, nextLastID)
        currentLastID = nextLastID

        for </span><span class="cov0" title="0">{
                if currentLastID == 0 &amp;&amp; len(orders) == 0 </span><span class="cov0" title="0">{
                        fmt.Println("No more orders to display.")
                        break</span>
                }

                <span class="cov0" title="0">fmt.Print("&gt; ")

                if !scanner.Scan() </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">input := strings.TrimSpace(scanner.Text())
                if input == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">switch strings.ToLower(input) </span>{
                case "next":<span class="cov0" title="0">
                        if currentLastID == 0 </span><span class="cov0" title="0">{
                                fmt.Println("No more orders to display.")
                                continue</span>
                        }
                        <span class="cov0" title="0">orders, nextLastID, err = a.appService.GetReceiverOrdersScroll(receiverID, currentLastID, limit)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">a.printScrollOrders(orders, nextLastID)
                        currentLastID = nextLastID</span>
                case "exit":<span class="cov0" title="0">
                        fmt.Println("Exiting scroll-orders.")
                        return nil</span>
                default:<span class="cov0" title="0">
                        fmt.Println("Unknown command. Type 'next' to get more orders or 'exit' to quit.")</span>
                }
        }

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("scanner.Scan: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (a *CLIAdapter) printScrollOrders(orders []*domain.Order, nextLastID uint64) <span class="cov0" title="0">{
        if len(orders) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No orders found in this batch.")
        }</span> else<span class="cov0" title="0"> {
                for _, order := range orders </span><span class="cov0" title="0">{
                        packageType := order.PackageType
                        if packageType == "" </span><span class="cov0" title="0">{
                                packageType = "none"
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("ORDER: %d Receiver: %d Status: %s Storage Limit: %s Package: %s Weight: %.2f Price: %.2f\n",
                                order.OrderID,
                                order.ReceiverID,
                                order.GetStatusString(),
                                MapTimeToString(order.StorageUntil),
                                packageType,
                                order.Weight,
                                order.Price,
                        )</span>
                }
        }
        <span class="cov0" title="0">if nextLastID &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("NEXT: %d\n", nextLastID)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("NEXT: 0 (End of orders)")
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package server

import (
        "errors"
        "fmt"
        "strings"

        "gitlab.ozon.dev/safariproxd/homework/internal/domain"
        "gitlab.ozon.dev/safariproxd/homework/pkg/api"
        "go.uber.org/multierr"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func MapErrorToGRPCStatus(err error) error <span class="cov0" title="0">{
        var domainErr domain.Error
        if errors.As(err, &amp;domainErr) </span><span class="cov0" title="0">{
                switch domainErr.Code </span>{
                case domain.ErrorCodeNotFound:<span class="cov0" title="0">
                        return status.Error(codes.NotFound, domainErr.Message)</span>
                case domain.ErrorCodeAlreadyExists:<span class="cov0" title="0">
                        return status.Error(codes.AlreadyExists, domainErr.Message)</span>
                case domain.ErrorCodeStorageExpired, domain.ErrorCodeStorageNotExpired:<span class="cov0" title="0">
                        return status.Error(codes.FailedPrecondition, domainErr.Message)</span>
                case domain.ErrorCodeValidationFailed, domain.ErrorCodeInvalidPackage, domain.ErrorCodeWeightTooHeavy:<span class="cov0" title="0">
                        return status.Error(codes.InvalidArgument, domainErr.Message)</span>
                default:<span class="cov0" title="0">
                        return status.Error(codes.Internal, domainErr.Message)</span>
                }
        }
        <span class="cov0" title="0">if multierr.Errors(err) != nil </span><span class="cov0" title="0">{
                return status.Error(codes.InvalidArgument, err.Error())
        }</span>
        <span class="cov0" title="0">return status.Error(codes.Internal, err.Error())</span>
}

func processErrors(err error, orderIDs []uint64) (*api.ProcessResult, error) <span class="cov0" title="0">{
        var processed, errors []uint64
        multiErrs := multierr.Errors(err)
        if len(multiErrs) == 0 </span><span class="cov0" title="0">{
                return &amp;api.ProcessResult{Processed: orderIDs}, nil
        }</span>
        <span class="cov0" title="0">for _, orderID := range orderIDs </span><span class="cov0" title="0">{
                found := false
                for _, e := range multiErrs </span><span class="cov0" title="0">{
                        if strings.Contains(e.Error(), fmt.Sprintf("Order %d", orderID)) </span><span class="cov0" title="0">{
                                errors = append(errors, orderID)
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        processed = append(processed, orderID)
                }</span>
        }
        <span class="cov0" title="0">return &amp;api.ProcessResult{Processed: processed, Errors: errors}, status.Error(codes.InvalidArgument, err.Error())</span>
}

func processImportErrors(err error, orders []domain.OrderToImport) *api.ImportResult <span class="cov0" title="0">{
        var errors []uint64
        multiErrs := multierr.Errors(err)
        for _, order := range orders </span><span class="cov0" title="0">{
                for _, e := range multiErrs </span><span class="cov0" title="0">{
                        if strings.Contains(e.Error(), fmt.Sprintf("Order %d", order.OrderID)) </span><span class="cov0" title="0">{
                                errors = append(errors, order.OrderID)
                                break</span>
                        }
                }
        }
        <span class="cov0" title="0">return &amp;api.ImportResult{Imported: int32(len(orders) - len(errors)), Errors: errors}</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package server

import (
        "context"

        "gitlab.ozon.dev/safariproxd/homework/internal/adapter/cli"
        "gitlab.ozon.dev/safariproxd/homework/internal/app"
        "gitlab.ozon.dev/safariproxd/homework/internal/domain"
        "gitlab.ozon.dev/safariproxd/homework/pkg/api"
        "google.golang.org/protobuf/types/known/timestamppb"
)

func (s *OrdersServer) AcceptOrder(ctx context.Context, req *api.AcceptOrderRequest) (*api.OrderResponse, error) <span class="cov0" title="0">{
        var packageType string
        if req.Package != nil </span><span class="cov0" title="0">{
                packageType = mapPackageTypeToString(*req.Package)
        }</span>
        <span class="cov0" title="0">acceptReq := domain.AcceptOrderRequest{
                OrderID:      req.OrderId,
                ReceiverID:   req.UserId,
                StorageUntil: req.ExpiresAt.AsTime(),
                Weight:       float64(req.Weight),
                Price:        float64(req.Price),
                PackageType:  packageType,
        }
        _, err := s.service.AcceptOrder(ctx, acceptReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;api.OrderResponse{
                Status:  api.OrderStatus_ORDER_STATUS_EXPECTS,
                OrderId: req.OrderId,
        }, nil</span>
}

func (s *OrdersServer) ReturnOrder(ctx context.Context, req *api.OrderIdRequest) (*api.OrderResponse, error) <span class="cov0" title="0">{
        err := s.service.ReturnOrderToDelivery(ctx, req.OrderId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;api.OrderResponse{
                Status:  api.OrderStatus_ORDER_STATUS_DELETED,
                OrderId: req.OrderId,
        }, nil</span>
}

func (s *OrdersServer) ProcessOrders(ctx context.Context, req *api.ProcessOrdersRequest) (*api.ProcessResult, error) <span class="cov0" title="0">{
        var err error
        if req.Action == api.ActionType_ACTION_TYPE_ISSUE </span><span class="cov0" title="0">{
                err = s.service.IssueOrdersToClient(ctx, req.UserId, req.OrderIds)
        }</span> else<span class="cov0" title="0"> {
                err = s.service.ReturnOrdersFromClient(ctx, req.UserId, req.OrderIds)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return processErrors(err, req.OrderIds)
        }</span>
        <span class="cov0" title="0">return &amp;api.ProcessResult{Processed: req.OrderIds}, nil</span>
}

func (s *OrdersServer) ListOrders(ctx context.Context, req *api.ListOrdersRequest) (*api.OrdersList, error) <span class="cov0" title="0">{
        var page, limit, lastN uint64
        if req.Pagination != nil </span><span class="cov0" title="0">{
                page = uint64(req.Pagination.Page)
                limit = uint64(req.Pagination.CountOnPage)
        }</span>
        <span class="cov0" title="0">if req.LastN != nil </span><span class="cov0" title="0">{
                lastN = uint64(*req.LastN)
        }</span>
        <span class="cov0" title="0">ordersReq := domain.ReceiverOrdersRequest{
                ReceiverID: req.UserId,
                InPVZ:      req.InPvz,
                LastN:      lastN,
                Page:       page,
                Limit:      limit,
        }
        orders, total, err := s.service.GetReceiverOrders(ctx, ordersReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">protoOrders := make([]*api.Order, len(orders))
        for i, order := range orders </span><span class="cov0" title="0">{
                protoOrders[i] = mapDomainOrderToProto(order)
        }</span>
        <span class="cov0" title="0">return &amp;api.OrdersList{
                Orders: protoOrders,
                Total:  int32(total),
        }, nil</span>
}

func (s *OrdersServer) ListReturns(ctx context.Context, req *api.ListReturnsRequest) (*api.ReturnsList, error) <span class="cov0" title="0">{
        var page, limit uint64
        if req.Pagination != nil </span><span class="cov0" title="0">{
                page = uint64(req.Pagination.Page)
                limit = uint64(req.Pagination.CountOnPage)
        }</span>
        <span class="cov0" title="0">orders, _, err := s.service.GetReturnedOrders(ctx, page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">protoOrders := make([]*api.Order, len(orders))
        for i, order := range orders </span><span class="cov0" title="0">{
                protoOrders[i] = mapDomainOrderToProto(order)
        }</span>
        <span class="cov0" title="0">return &amp;api.ReturnsList{Returns: protoOrders}, nil</span>
}

func (s *OrdersServer) GetHistory(ctx context.Context, req *api.GetHistoryRequest) (*api.OrderHistoryList, error) <span class="cov0" title="0">{
        var page, limit uint64
        if req.Pagination != nil </span><span class="cov0" title="0">{
                page = uint64(req.Pagination.Page)
                limit = uint64(req.Pagination.CountOnPage)
        }</span>
        <span class="cov0" title="0">orders, err := s.service.GetOrderHistory(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">paginated := app.Paginate(orders, page, limit)
        history := make([]*api.OrderHistory, len(paginated))
        for i, order := range paginated </span><span class="cov0" title="0">{
                history[i] = &amp;api.OrderHistory{
                        OrderId:   order.OrderID,
                        Status:    mapDomainStatusToProto(order.Status),
                        CreatedAt: timestamppb.New(order.LastUpdateTime),
                }
        }</span>
        <span class="cov0" title="0">return &amp;api.OrderHistoryList{History: history}, nil</span>
}

func (s *OrdersServer) GetOrderHistory(ctx context.Context, req *api.OrderHistoryRequest) (*api.OrderHistoryResponse, error) <span class="cov0" title="0">{
        history, err := s.service.GetOrderHistoryByID(ctx, req.OrderId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">protoHistory := make([]*api.OrderHistory, len(history))
        for i, record := range history </span><span class="cov0" title="0">{
                protoHistory[i] = &amp;api.OrderHistory{
                        OrderId:   record.OrderID,
                        Status:    mapDomainStatusToProto(record.Status),
                        CreatedAt: timestamppb.New(record.ChangedAt),
                }
        }</span>
        <span class="cov0" title="0">return &amp;api.OrderHistoryResponse{History: protoHistory}, nil</span>
}

func (s *OrdersServer) ImportOrders(ctx context.Context, req *api.ImportOrdersRequest) (*api.ImportResult, error) <span class="cov0" title="0">{
        orders := make([]domain.OrderToImport, len(req.Orders))
        for i, order := range req.Orders </span><span class="cov0" title="0">{
                var packageType string
                if order.Package != nil </span><span class="cov0" title="0">{
                        packageType = mapPackageTypeToString(*order.Package)
                }</span>
                <span class="cov0" title="0">orders[i] = domain.OrderToImport{
                        OrderID:      order.OrderId,
                        ReceiverID:   order.UserId,
                        StorageUntil: order.ExpiresAt.AsTime().Format(cli.TimeFormat),
                        PackageType:  packageType,
                        Weight:       float64(order.Weight),
                        Price:        float64(order.Price),
                }</span>
        }
        <span class="cov0" title="0">imported, err := s.service.ImportOrders(ctx, orders)
        if err != nil </span><span class="cov0" title="0">{
                return processImportErrors(err, orders), nil
        }</span>
        <span class="cov0" title="0">return &amp;api.ImportResult{Imported: int32(imported)}, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package mw

import (
        "context"
        "log/slog"
        "time"

        "github.com/ulule/limiter/v3"
        server "gitlab.ozon.dev/safariproxd/homework/internal/adapter/grpc"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/proto"
)

func LoggingInterceptor() grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, req any, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (any, error) </span><span class="cov0" title="0">{
                md, _ := metadata.FromIncomingContext(ctx)
                slog.Info("Request", "method", info.FullMethod, "metadata", md)
                resp, err := handler(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Response", "method", info.FullMethod, "error", err)
                }</span> else<span class="cov0" title="0"> {
                        slog.Info("Response", "method", info.FullMethod)
                }</span>
                <span class="cov0" title="0">return resp, err</span>
        }
}

func ErrorMappingInterceptor() grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, req any, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (any, error) </span><span class="cov0" title="0">{
                resp, err := handler(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        return resp, server.MapErrorToGRPCStatus(err)
                }</span>
                <span class="cov0" title="0">return resp, nil</span>
        }
}

func RateLimiterInterceptor(limiter *limiter.Limiter) grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, req any, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (any, error) </span><span class="cov0" title="0">{
                sender := "unknown"
                if md, ok := metadata.FromIncomingContext(ctx); ok </span><span class="cov0" title="0">{
                        if s, ok := md["sender"]; ok </span><span class="cov0" title="0">{
                                sender = s[0]
                        }</span>
                }

                <span class="cov0" title="0">limiterCtx, err := limiter.Get(ctx, sender)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.Internal, err.Error())
                }</span>
                <span class="cov0" title="0">if limiterCtx.Reached </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.ResourceExhausted, "rate limited")
                }</span>

                <span class="cov0" title="0">return handler(ctx, req)</span>
        }
}

func ValidationInterceptor() grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, req any, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (any, error) </span><span class="cov0" title="0">{
                if v, ok := req.(proto.Message); ok </span><span class="cov0" title="0">{
                        if validator, ok := v.(interface{ ValidateAll() error }); ok </span><span class="cov0" title="0">{
                                if err := validator.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                        return nil, status.Errorf(codes.InvalidArgument, "validation failed: %v", err)
                                }</span>
                        }
                }
                <span class="cov0" title="0">return handler(ctx, req)</span>
        }
}

func TimeoutInterceptor(timeout time.Duration) grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(parent context.Context, req any,
                info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (any, error) </span><span class="cov0" title="0">{

                ctx, cancel := context.WithTimeout(parent, timeout)
                defer cancel()

                resp, err := handler(ctx, req)

                if ctx.Err() == context.DeadlineExceeded &amp;&amp; err == nil </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.DeadlineExceeded, "service timeout")
                }</span>
                <span class="cov0" title="0">return resp, err</span>
        }
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package server

import (
        "context"

        "gitlab.ozon.dev/safariproxd/homework/internal/domain"
        "gitlab.ozon.dev/safariproxd/homework/pkg/api"
        "google.golang.org/grpc"
)

type IOrderService interface {
        AcceptOrder(ctx context.Context, req domain.AcceptOrderRequest) (float64, error)
        ReturnOrderToDelivery(ctx context.Context, orderID uint64) error
        IssueOrdersToClient(ctx context.Context, receiverID uint64, orderIDs []uint64) error
        ReturnOrdersFromClient(ctx context.Context, receiverID uint64, orderIDs []uint64) error
        GetReceiverOrders(ctx context.Context, req domain.ReceiverOrdersRequest) ([]domain.Order, uint64, error)
        GetReceiverOrdersScroll(ctx context.Context, receiverID uint64, lastID, limit uint64) ([]domain.Order, uint64, error)
        GetReturnedOrders(ctx context.Context, page, limit uint64) ([]domain.Order, uint64, error)
        GetOrderHistory(ctx context.Context) ([]domain.Order, error)
        GetOrderHistoryByID(ctx context.Context, orderID uint64) ([]domain.OrderHistory, error)
        ImportOrders(ctx context.Context, orders []domain.OrderToImport) (uint64, error)
}

type OrdersServer struct {
        api.UnimplementedOrdersServiceServer
        service IOrderService
}

func NewOrdersServer(service IOrderService) *OrdersServer <span class="cov0" title="0">{
        return &amp;OrdersServer{
                service: service,
        }
}</span>

func (s *OrdersServer) Register(grpcServer *grpc.Server) <span class="cov0" title="0">{
        api.RegisterOrdersServiceServer(grpcServer, s)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package server

import (
        "gitlab.ozon.dev/safariproxd/homework/internal/domain"
        "gitlab.ozon.dev/safariproxd/homework/pkg/api"
        "google.golang.org/protobuf/types/known/timestamppb"
)

func mapPackageTypeToString(pt api.PackageType) string <span class="cov0" title="0">{
        switch pt </span>{
        case api.PackageType_PACKAGE_TYPE_BAG:<span class="cov0" title="0">
                return "bag"</span>
        case api.PackageType_PACKAGE_TYPE_BOX:<span class="cov0" title="0">
                return "box"</span>
        case api.PackageType_PACKAGE_TYPE_TAPE:<span class="cov0" title="0">
                return "film"</span>
        case api.PackageType_PACKAGE_TYPE_BAG_TAPE:<span class="cov0" title="0">
                return "bag+film"</span>
        case api.PackageType_PACKAGE_TYPE_BOX_TAPE:<span class="cov0" title="0">
                return "box+film"</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

func mapDomainStatusToProto(status domain.OrderStatus) api.OrderStatus <span class="cov0" title="0">{
        switch status </span>{
        case domain.StatusInStorage:<span class="cov0" title="0">
                return api.OrderStatus_ORDER_STATUS_EXPECTS</span>
        case domain.StatusGivenToClient:<span class="cov0" title="0">
                return api.OrderStatus_ORDER_STATUS_ACCEPTED</span>
        case domain.StatusReturnedFromClient:<span class="cov0" title="0">
                return api.OrderStatus_ORDER_STATUS_RETURNED</span>
        case domain.StatusReturnedWithoutClient, domain.StatusGivenToCourier:<span class="cov0" title="0">
                return api.OrderStatus_ORDER_STATUS_DELETED</span>
        default:<span class="cov0" title="0">
                return api.OrderStatus_ORDER_STATUS_UNSPECIFIED</span>
        }
}

func mapDomainOrderToProto(order domain.Order) *api.Order <span class="cov0" title="0">{
        pkgType := mapStringToPackageType(order.PackageType)
        return &amp;api.Order{
                OrderId:    order.OrderID,
                UserId:     order.ReceiverID,
                Status:     mapDomainStatusToProto(order.Status),
                ExpiresAt:  timestamppb.New(order.StorageUntil),
                Weight:     float32(order.Weight),
                TotalPrice: float32(order.Price),
                Package:    &amp;pkgType,
        }
}</span>

func mapStringToPackageType(pt string) api.PackageType <span class="cov0" title="0">{
        switch pt </span>{
        case "bag":<span class="cov0" title="0">
                return api.PackageType_PACKAGE_TYPE_BAG</span>
        case "box":<span class="cov0" title="0">
                return api.PackageType_PACKAGE_TYPE_BOX</span>
        case "film":<span class="cov0" title="0">
                return api.PackageType_PACKAGE_TYPE_TAPE</span>
        case "bag+film":<span class="cov0" title="0">
                return api.PackageType_PACKAGE_TYPE_BAG_TAPE</span>
        case "box+film":<span class="cov0" title="0">
                return api.PackageType_PACKAGE_TYPE_BOX_TAPE</span>
        default:<span class="cov0" title="0">
                return api.PackageType_PACKAGE_TYPE_UNSPECIFIED</span>
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package app

import (
        "context"
        "fmt"

        "gitlab.ozon.dev/safariproxd/homework/internal/domain"
)

func (s *PVZService) AcceptOrder(ctx context.Context, req domain.AcceptOrderRequest) (float64, error) <span class="cov10" title="7">{
        currentTime := s.nowFn()

        if _, err := s.orderRepo.GetByID(ctx, req.OrderID); err == nil </span><span class="cov1" title="1">{
                return 0, fmt.Errorf("repo.GetByID: %w",
                        domain.OrderAlreadyExistsError(req.OrderID))
        }</span>

        <span class="cov9" title="6">var rules []domain.PackageRules
        if req.PackageType != "" </span><span class="cov8" title="5">{
                var err error
                rules, err = s.orderRepo.GetPackageRules(ctx, req.PackageType)
                if err != nil </span><span class="cov1" title="1">{
                        return 0, fmt.Errorf("validation: %w", err)
                }</span>
        }

        <span class="cov8" title="5">totalPrice := req.Price
        for _, r := range rules </span><span class="cov7" title="4">{
                if r.MaxWeight &gt; 0 &amp;&amp; req.Weight &gt; r.MaxWeight </span><span class="cov1" title="1">{
                        return 0, fmt.Errorf("validation: %w",
                                domain.WeightTooHeavyError(req.PackageType, req.Weight, r.MaxWeight))
                }</span>
                <span class="cov6" title="3">totalPrice += r.Price</span>
        }

        <span class="cov7" title="4">order := domain.Order{
                OrderID:        req.OrderID,
                ReceiverID:     req.ReceiverID,
                StorageUntil:   req.StorageUntil,
                Status:         domain.StatusInStorage,
                AcceptTime:     currentTime,
                LastUpdateTime: currentTime,
                PackageType:    req.PackageType,
                Weight:         req.Weight,
                Price:          totalPrice,
        }
        if err := s.orderRepo.Save(ctx, order); err != nil </span><span class="cov1" title="1">{
                return 0, fmt.Errorf("repo.Save: %w", err)
        }</span>

        <span class="cov6" title="3">history := domain.OrderHistory{
                OrderID:   req.OrderID,
                Status:    domain.StatusInStorage,
                ChangedAt: currentTime,
        }
        if err := s.orderRepo.SaveHistory(ctx, history); err != nil </span><span class="cov1" title="1">{
                return 0, fmt.Errorf("repo.SaveHistory: %w", err)
        }</span>

        <span class="cov4" title="2">return totalPrice, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package app

import (
        "context"
        "fmt"
        "sort"

        "gitlab.ozon.dev/safariproxd/homework/internal/domain"
)

func (s *PVZService) GetReceiverOrders(ctx context.Context, req domain.ReceiverOrdersRequest) ([]domain.Order, uint64, error) <span class="cov6" title="3">{
        receiverOrders, err := s.orderRepo.GetByReceiverID(ctx, req.ReceiverID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, 0, fmt.Errorf("repo.GetByReceiverID: %w", err)
        }</span>

        <span class="cov4" title="2">var filteredOrders []domain.Order
        for _, order := range receiverOrders </span><span class="cov10" title="6">{
                if req.InPVZ &amp;&amp; order.Status != domain.StatusInStorage </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov9" title="5">filteredOrders = append(filteredOrders, order)</span>
        }

        <span class="cov4" title="2">var paginatedOrders []domain.Order
        totalItems := uint64(len(filteredOrders))

        if req.LastN &gt; 0 </span><span class="cov1" title="1">{
                if totalItems &gt; req.LastN </span><span class="cov1" title="1">{
                        paginatedOrders = filteredOrders[totalItems-req.LastN:]
                }</span> else<span class="cov0" title="0"> {
                        paginatedOrders = filteredOrders
                }</span>
        } else<span class="cov1" title="1"> {
                paginatedOrders = Paginate(filteredOrders, req.Page, req.Limit)
        }</span>

        <span class="cov4" title="2">return paginatedOrders, totalItems, nil</span>
}

func (s *PVZService) GetReturnedOrders(ctx context.Context, page, limit uint64) ([]domain.Order, uint64, error) <span class="cov1" title="1">{
        returnOrders, err := s.orderRepo.GetReturnedOrders(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("repo.GetReturnedOrders: %w", err)
        }</span>

        <span class="cov1" title="1">paginated := Paginate(returnOrders, page, limit)
        return paginated, uint64(len(returnOrders)), nil</span>
}

func (s *PVZService) GetOrderHistory(ctx context.Context) ([]domain.Order, error) <span class="cov1" title="1">{
        orders, err := s.orderRepo.GetAllOrders(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("repo.GetAllOrders: %w", err)
        }</span>

        <span class="cov1" title="1">sort.Slice(orders, func(i, j int) bool </span><span class="cov6" title="3">{
                return orders[i].LastUpdateTime.After(orders[j].LastUpdateTime)
        }</span>)
        <span class="cov1" title="1">return orders, nil</span>
}

func (s *PVZService) GetOrderHistoryByID(ctx context.Context, orderID uint64) ([]domain.OrderHistory, error) <span class="cov4" title="2">{
        history, err := s.orderRepo.GetHistoryByOrderID(ctx, orderID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("repo.GetHistoryByOrderID: %w", err)
        }</span>

        <span class="cov4" title="2">if len(history) == 0 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("history: %w", domain.EntityNotFoundError("Order", fmt.Sprintf("%d", orderID)))
        }</span>
        <span class="cov1" title="1">sort.Slice(history, func(i, j int) bool </span><span class="cov1" title="1">{
                return history[i].ChangedAt.After(history[j].ChangedAt)
        }</span>)

        <span class="cov1" title="1">return history, nil</span>
}

func (s *PVZService) GetReceiverOrdersScroll(ctx context.Context, receiverID uint64, lastID, limit uint64) ([]domain.Order, uint64, error) <span class="cov4" title="2">{
        receiverOrders, err := s.orderRepo.GetByReceiverID(ctx, receiverID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("repo.GetByReceiverID: %w", err)
        }</span>

        <span class="cov4" title="2">sort.Slice(receiverOrders, func(i, j int) bool </span><span class="cov7" title="4">{
                return receiverOrders[i].OrderID &lt; receiverOrders[j].OrderID
        }</span>)

        <span class="cov4" title="2">totalItems := uint64(len(receiverOrders))
        var resultOrders []domain.Order
        var nextLastID uint64

        startIndex := -1
        if lastID &gt; 0 </span><span class="cov1" title="1">{
                for i, order := range receiverOrders </span><span class="cov4" title="2">{
                        if order.OrderID == lastID </span><span class="cov1" title="1">{
                                startIndex = i
                                break</span>
                        }
                }
                <span class="cov1" title="1">if startIndex == -1 </span><span class="cov0" title="0">{
                        return []domain.Order{}, totalItems, nil
                }</span>
        }

        <span class="cov4" title="2">startOffset := startIndex + 1
        if startOffset &gt;= len(receiverOrders) </span><span class="cov0" title="0">{
                return []domain.Order{}, totalItems, nil
        }</span>

        <span class="cov4" title="2">endOffset := startOffset + int(limit)
        if endOffset &gt; len(receiverOrders) </span><span class="cov1" title="1">{
                endOffset = len(receiverOrders)
        }</span>
        <span class="cov4" title="2">resultOrders = receiverOrders[startOffset:endOffset]

        if len(resultOrders) &gt; 0 &amp;&amp; endOffset &lt; len(receiverOrders) </span><span class="cov1" title="1">{
                nextLastID = resultOrders[len(resultOrders)-1].OrderID
        }</span>

        <span class="cov4" title="2">return resultOrders, nextLastID, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package app

import (
        "context"
        "fmt"

        "gitlab.ozon.dev/safariproxd/homework/internal/adapter/cli"
        "gitlab.ozon.dev/safariproxd/homework/internal/domain"
        "go.uber.org/multierr"
)

func (s *PVZService) ImportOrders(ctx context.Context, orders []domain.OrderToImport) (uint64, error) <span class="cov0" title="0">{
        var combinedErr error
        importedCount := uint64(0)
        for _, rawOrder := range orders </span><span class="cov0" title="0">{
                storageUntil, err := cli.MapStringToTime(rawOrder.StorageUntil)
                if err != nil </span><span class="cov0" title="0">{
                        combinedErr = multierr.Append(combinedErr, fmt.Errorf("time.Parse: %w", err))
                        continue</span>
                }

                <span class="cov0" title="0">req := domain.AcceptOrderRequest{
                        ReceiverID:   rawOrder.ReceiverID,
                        OrderID:      rawOrder.OrderID,
                        StorageUntil: storageUntil,
                        Weight:       rawOrder.Weight,
                        Price:        rawOrder.Price,
                        PackageType:  rawOrder.PackageType,
                }
                _, err = s.AcceptOrder(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        combinedErr = multierr.Append(combinedErr, fmt.Errorf("AcceptOrder: %w", err))
                        continue</span>
                }
                <span class="cov0" title="0">importedCount++</span>
        }
        <span class="cov0" title="0">return importedCount, combinedErr</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package app

import (
        "context"
        "fmt"

        "gitlab.ozon.dev/safariproxd/homework/internal/adapter/cli"
        "gitlab.ozon.dev/safariproxd/homework/internal/domain"
        "go.uber.org/multierr"
)

func (s *PVZService) IssueOrdersToClient(ctx context.Context, receiverID uint64, orderIDs []uint64) error <span class="cov9" title="9">{
        var combinedErr error
        currentTime := s.nowFn()

        for _, orderID := range orderIDs </span><span class="cov10" title="11">{
                order, err := s.orderRepo.GetByID(ctx, orderID)
                if err != nil </span><span class="cov1" title="1">{
                        combinedErr = multierr.Append(combinedErr, fmt.Errorf("repo.GetByID: %w", err))
                        continue</span>
                }

                <span class="cov9" title="10">if order.ReceiverID != receiverID </span><span class="cov1" title="1">{
                        combinedErr = multierr.Append(combinedErr, fmt.Errorf("validation: %w",
                                domain.BelongsToDifferentReceiverError(orderID, receiverID, order.ReceiverID)))
                        continue</span>
                }

                <span class="cov9" title="9">if order.Status == domain.StatusGivenToClient </span><span class="cov3" title="2">{
                        combinedErr = multierr.Append(combinedErr, fmt.Errorf("validation: %w",
                                domain.OrderAlreadyGivenError(orderID)))
                        continue</span>
                }

                <span class="cov8" title="7">if order.Status == domain.StatusReturnedFromClient </span><span class="cov1" title="1">{
                        combinedErr = multierr.Append(combinedErr, fmt.Errorf("validation: %w",
                                domain.UnavaliableReturnedOrderError(orderID)))
                        continue</span>
                }

                <span class="cov7" title="6">if currentTime.After(order.StorageUntil) </span><span class="cov1" title="1">{
                        combinedErr = multierr.Append(combinedErr, fmt.Errorf("validation: %w",
                                domain.StorageExpiredError(orderID, cli.MapTimeToString(order.StorageUntil))))
                        continue</span>
                }

                <span class="cov7" title="5">order.Status = domain.StatusGivenToClient
                order.LastUpdateTime = currentTime
                if err := s.orderRepo.Update(ctx, order); err != nil </span><span class="cov1" title="1">{
                        combinedErr = multierr.Append(combinedErr, fmt.Errorf("repo.Update: %w", err))
                        continue</span>
                }

                <span class="cov6" title="4">history := domain.OrderHistory{
                        OrderID:   orderID,
                        Status:    domain.StatusGivenToClient,
                        ChangedAt: currentTime,
                }
                if err := s.orderRepo.SaveHistory(ctx, history); err != nil </span><span class="cov1" title="1">{
                        combinedErr = multierr.Append(combinedErr, fmt.Errorf("repo.SaveHistory: %w", err))
                        continue</span>
                }
        }
        <span class="cov9" title="9">return combinedErr</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

//go:generate minimock -i gitlab.ozon.dev/safariproxd/homework/internal/app.OrderRepository -o order_repository_mock.go -n OrderRepositoryMock -p mock

import (
        "context"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/gojuno/minimock/v3"
        "gitlab.ozon.dev/safariproxd/homework/internal/domain"
)

// OrderRepositoryMock implements mm_app.OrderRepository
type OrderRepositoryMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcGetAllOrders          func(ctx context.Context) (oa1 []domain.Order, err error)
        funcGetAllOrdersOrigin    string
        inspectFuncGetAllOrders   func(ctx context.Context)
        afterGetAllOrdersCounter  uint64
        beforeGetAllOrdersCounter uint64
        GetAllOrdersMock          mOrderRepositoryMockGetAllOrders

        funcGetByID          func(ctx context.Context, orderID uint64) (o1 domain.Order, err error)
        funcGetByIDOrigin    string
        inspectFuncGetByID   func(ctx context.Context, orderID uint64)
        afterGetByIDCounter  uint64
        beforeGetByIDCounter uint64
        GetByIDMock          mOrderRepositoryMockGetByID

        funcGetByReceiverID          func(ctx context.Context, receiverID uint64) (oa1 []domain.Order, err error)
        funcGetByReceiverIDOrigin    string
        inspectFuncGetByReceiverID   func(ctx context.Context, receiverID uint64)
        afterGetByReceiverIDCounter  uint64
        beforeGetByReceiverIDCounter uint64
        GetByReceiverIDMock          mOrderRepositoryMockGetByReceiverID

        funcGetHistoryByOrderID          func(ctx context.Context, orderID uint64) (oa1 []domain.OrderHistory, err error)
        funcGetHistoryByOrderIDOrigin    string
        inspectFuncGetHistoryByOrderID   func(ctx context.Context, orderID uint64)
        afterGetHistoryByOrderIDCounter  uint64
        beforeGetHistoryByOrderIDCounter uint64
        GetHistoryByOrderIDMock          mOrderRepositoryMockGetHistoryByOrderID

        funcGetPackageRules          func(ctx context.Context, code string) (pa1 []domain.PackageRules, err error)
        funcGetPackageRulesOrigin    string
        inspectFuncGetPackageRules   func(ctx context.Context, code string)
        afterGetPackageRulesCounter  uint64
        beforeGetPackageRulesCounter uint64
        GetPackageRulesMock          mOrderRepositoryMockGetPackageRules

        funcGetReturnedOrders          func(ctx context.Context) (oa1 []domain.Order, err error)
        funcGetReturnedOrdersOrigin    string
        inspectFuncGetReturnedOrders   func(ctx context.Context)
        afterGetReturnedOrdersCounter  uint64
        beforeGetReturnedOrdersCounter uint64
        GetReturnedOrdersMock          mOrderRepositoryMockGetReturnedOrders

        funcSave          func(ctx context.Context, order domain.Order) (err error)
        funcSaveOrigin    string
        inspectFuncSave   func(ctx context.Context, order domain.Order)
        afterSaveCounter  uint64
        beforeSaveCounter uint64
        SaveMock          mOrderRepositoryMockSave

        funcSaveHistory          func(ctx context.Context, history domain.OrderHistory) (err error)
        funcSaveHistoryOrigin    string
        inspectFuncSaveHistory   func(ctx context.Context, history domain.OrderHistory)
        afterSaveHistoryCounter  uint64
        beforeSaveHistoryCounter uint64
        SaveHistoryMock          mOrderRepositoryMockSaveHistory

        funcUpdate          func(ctx context.Context, order domain.Order) (err error)
        funcUpdateOrigin    string
        inspectFuncUpdate   func(ctx context.Context, order domain.Order)
        afterUpdateCounter  uint64
        beforeUpdateCounter uint64
        UpdateMock          mOrderRepositoryMockUpdate
}

// NewOrderRepositoryMock returns a mock for mm_app.OrderRepository
func NewOrderRepositoryMock(t minimock.Tester) *OrderRepositoryMock <span class="cov8" title="33">{
        m := &amp;OrderRepositoryMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov8" title="33">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov8" title="33">m.GetAllOrdersMock = mOrderRepositoryMockGetAllOrders{mock: m}
        m.GetAllOrdersMock.callArgs = []*OrderRepositoryMockGetAllOrdersParams{}

        m.GetByIDMock = mOrderRepositoryMockGetByID{mock: m}
        m.GetByIDMock.callArgs = []*OrderRepositoryMockGetByIDParams{}

        m.GetByReceiverIDMock = mOrderRepositoryMockGetByReceiverID{mock: m}
        m.GetByReceiverIDMock.callArgs = []*OrderRepositoryMockGetByReceiverIDParams{}

        m.GetHistoryByOrderIDMock = mOrderRepositoryMockGetHistoryByOrderID{mock: m}
        m.GetHistoryByOrderIDMock.callArgs = []*OrderRepositoryMockGetHistoryByOrderIDParams{}

        m.GetPackageRulesMock = mOrderRepositoryMockGetPackageRules{mock: m}
        m.GetPackageRulesMock.callArgs = []*OrderRepositoryMockGetPackageRulesParams{}

        m.GetReturnedOrdersMock = mOrderRepositoryMockGetReturnedOrders{mock: m}
        m.GetReturnedOrdersMock.callArgs = []*OrderRepositoryMockGetReturnedOrdersParams{}

        m.SaveMock = mOrderRepositoryMockSave{mock: m}
        m.SaveMock.callArgs = []*OrderRepositoryMockSaveParams{}

        m.SaveHistoryMock = mOrderRepositoryMockSaveHistory{mock: m}
        m.SaveHistoryMock.callArgs = []*OrderRepositoryMockSaveHistoryParams{}

        m.UpdateMock = mOrderRepositoryMockUpdate{mock: m}
        m.UpdateMock.callArgs = []*OrderRepositoryMockUpdateParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mOrderRepositoryMockGetAllOrders struct {
        optional           bool
        mock               *OrderRepositoryMock
        defaultExpectation *OrderRepositoryMockGetAllOrdersExpectation
        expectations       []*OrderRepositoryMockGetAllOrdersExpectation

        callArgs []*OrderRepositoryMockGetAllOrdersParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// OrderRepositoryMockGetAllOrdersExpectation specifies expectation struct of the OrderRepository.GetAllOrders
type OrderRepositoryMockGetAllOrdersExpectation struct {
        mock               *OrderRepositoryMock
        params             *OrderRepositoryMockGetAllOrdersParams
        paramPtrs          *OrderRepositoryMockGetAllOrdersParamPtrs
        expectationOrigins OrderRepositoryMockGetAllOrdersExpectationOrigins
        results            *OrderRepositoryMockGetAllOrdersResults
        returnOrigin       string
        Counter            uint64
}

// OrderRepositoryMockGetAllOrdersParams contains parameters of the OrderRepository.GetAllOrders
type OrderRepositoryMockGetAllOrdersParams struct {
        ctx context.Context
}

// OrderRepositoryMockGetAllOrdersParamPtrs contains pointers to parameters of the OrderRepository.GetAllOrders
type OrderRepositoryMockGetAllOrdersParamPtrs struct {
        ctx *context.Context
}

// OrderRepositoryMockGetAllOrdersResults contains results of the OrderRepository.GetAllOrders
type OrderRepositoryMockGetAllOrdersResults struct {
        oa1 []domain.Order
        err error
}

// OrderRepositoryMockGetAllOrdersOrigins contains origins of expectations of the OrderRepository.GetAllOrders
type OrderRepositoryMockGetAllOrdersExpectationOrigins struct {
        origin    string
        originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAllOrders *mOrderRepositoryMockGetAllOrders) Optional() *mOrderRepositoryMockGetAllOrders <span class="cov0" title="0">{
        mmGetAllOrders.optional = true
        return mmGetAllOrders
}</span>

// Expect sets up expected params for OrderRepository.GetAllOrders
func (mmGetAllOrders *mOrderRepositoryMockGetAllOrders) Expect(ctx context.Context) *mOrderRepositoryMockGetAllOrders <span class="cov1" title="1">{
        if mmGetAllOrders.mock.funcGetAllOrders != nil </span><span class="cov0" title="0">{
                mmGetAllOrders.mock.t.Fatalf("OrderRepositoryMock.GetAllOrders mock is already set by Set")
        }</span>

        <span class="cov1" title="1">if mmGetAllOrders.defaultExpectation == nil </span><span class="cov1" title="1">{
                mmGetAllOrders.defaultExpectation = &amp;OrderRepositoryMockGetAllOrdersExpectation{}
        }</span>

        <span class="cov1" title="1">if mmGetAllOrders.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmGetAllOrders.mock.t.Fatalf("OrderRepositoryMock.GetAllOrders mock is already set by ExpectParams functions")
        }</span>

        <span class="cov1" title="1">mmGetAllOrders.defaultExpectation.params = &amp;OrderRepositoryMockGetAllOrdersParams{ctx}
        mmGetAllOrders.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmGetAllOrders.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmGetAllOrders.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmGetAllOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAllOrders.defaultExpectation.params)
                }</span>
        }

        <span class="cov1" title="1">return mmGetAllOrders</span>
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepository.GetAllOrders
func (mmGetAllOrders *mOrderRepositoryMockGetAllOrders) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockGetAllOrders <span class="cov0" title="0">{
        if mmGetAllOrders.mock.funcGetAllOrders != nil </span><span class="cov0" title="0">{
                mmGetAllOrders.mock.t.Fatalf("OrderRepositoryMock.GetAllOrders mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetAllOrders.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetAllOrders.defaultExpectation = &amp;OrderRepositoryMockGetAllOrdersExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetAllOrders.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGetAllOrders.mock.t.Fatalf("OrderRepositoryMock.GetAllOrders mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGetAllOrders.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGetAllOrders.defaultExpectation.paramPtrs = &amp;OrderRepositoryMockGetAllOrdersParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGetAllOrders.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmGetAllOrders.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmGetAllOrders</span>
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.GetAllOrders
func (mmGetAllOrders *mOrderRepositoryMockGetAllOrders) Inspect(f func(ctx context.Context)) *mOrderRepositoryMockGetAllOrders <span class="cov0" title="0">{
        if mmGetAllOrders.mock.inspectFuncGetAllOrders != nil </span><span class="cov0" title="0">{
                mmGetAllOrders.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.GetAllOrders")
        }</span>

        <span class="cov0" title="0">mmGetAllOrders.mock.inspectFuncGetAllOrders = f

        return mmGetAllOrders</span>
}

// Return sets up results that will be returned by OrderRepository.GetAllOrders
func (mmGetAllOrders *mOrderRepositoryMockGetAllOrders) Return(oa1 []domain.Order, err error) *OrderRepositoryMock <span class="cov1" title="1">{
        if mmGetAllOrders.mock.funcGetAllOrders != nil </span><span class="cov0" title="0">{
                mmGetAllOrders.mock.t.Fatalf("OrderRepositoryMock.GetAllOrders mock is already set by Set")
        }</span>

        <span class="cov1" title="1">if mmGetAllOrders.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetAllOrders.defaultExpectation = &amp;OrderRepositoryMockGetAllOrdersExpectation{mock: mmGetAllOrders.mock}
        }</span>
        <span class="cov1" title="1">mmGetAllOrders.defaultExpectation.results = &amp;OrderRepositoryMockGetAllOrdersResults{oa1, err}
        mmGetAllOrders.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmGetAllOrders.mock</span>
}

// Set uses given function f to mock the OrderRepository.GetAllOrders method
func (mmGetAllOrders *mOrderRepositoryMockGetAllOrders) Set(f func(ctx context.Context) (oa1 []domain.Order, err error)) *OrderRepositoryMock <span class="cov0" title="0">{
        if mmGetAllOrders.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmGetAllOrders.mock.t.Fatalf("Default expectation is already set for the OrderRepository.GetAllOrders method")
        }</span>

        <span class="cov0" title="0">if len(mmGetAllOrders.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmGetAllOrders.mock.t.Fatalf("Some expectations are already set for the OrderRepository.GetAllOrders method")
        }</span>

        <span class="cov0" title="0">mmGetAllOrders.mock.funcGetAllOrders = f
        mmGetAllOrders.mock.funcGetAllOrdersOrigin = minimock.CallerInfo(1)
        return mmGetAllOrders.mock</span>
}

// When sets expectation for the OrderRepository.GetAllOrders which will trigger the result defined by the following
// Then helper
func (mmGetAllOrders *mOrderRepositoryMockGetAllOrders) When(ctx context.Context) *OrderRepositoryMockGetAllOrdersExpectation <span class="cov0" title="0">{
        if mmGetAllOrders.mock.funcGetAllOrders != nil </span><span class="cov0" title="0">{
                mmGetAllOrders.mock.t.Fatalf("OrderRepositoryMock.GetAllOrders mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;OrderRepositoryMockGetAllOrdersExpectation{
                mock:               mmGetAllOrders.mock,
                params:             &amp;OrderRepositoryMockGetAllOrdersParams{ctx},
                expectationOrigins: OrderRepositoryMockGetAllOrdersExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmGetAllOrders.expectations = append(mmGetAllOrders.expectations, expectation)
        return expectation</span>
}

// Then sets up OrderRepository.GetAllOrders return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockGetAllOrdersExpectation) Then(oa1 []domain.Order, err error) *OrderRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;OrderRepositoryMockGetAllOrdersResults{oa1, err}
        return e.mock
}</span>

// Times sets number of times OrderRepository.GetAllOrders should be invoked
func (mmGetAllOrders *mOrderRepositoryMockGetAllOrders) Times(n uint64) *mOrderRepositoryMockGetAllOrders <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmGetAllOrders.mock.t.Fatalf("Times of OrderRepositoryMock.GetAllOrders mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmGetAllOrders.expectedInvocations, n)
        mmGetAllOrders.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmGetAllOrders</span>
}

func (mmGetAllOrders *mOrderRepositoryMockGetAllOrders) invocationsDone() bool <span class="cov8" title="33">{
        if len(mmGetAllOrders.expectations) == 0 &amp;&amp; mmGetAllOrders.defaultExpectation == nil &amp;&amp; mmGetAllOrders.mock.funcGetAllOrders == nil </span><span class="cov8" title="32">{
                return true
        }</span>

        <span class="cov1" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmGetAllOrders.mock.afterGetAllOrdersCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmGetAllOrders.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// GetAllOrders implements mm_app.OrderRepository
func (mmGetAllOrders *OrderRepositoryMock) GetAllOrders(ctx context.Context) (oa1 []domain.Order, err error) <span class="cov1" title="1">{
        mm_atomic.AddUint64(&amp;mmGetAllOrders.beforeGetAllOrdersCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmGetAllOrders.afterGetAllOrdersCounter, 1)

        mmGetAllOrders.t.Helper()

        if mmGetAllOrders.inspectFuncGetAllOrders != nil </span><span class="cov0" title="0">{
                mmGetAllOrders.inspectFuncGetAllOrders(ctx)
        }</span>

        <span class="cov1" title="1">mm_params := OrderRepositoryMockGetAllOrdersParams{ctx}

        // Record call args
        mmGetAllOrders.GetAllOrdersMock.mutex.Lock()
        mmGetAllOrders.GetAllOrdersMock.callArgs = append(mmGetAllOrders.GetAllOrdersMock.callArgs, &amp;mm_params)
        mmGetAllOrders.GetAllOrdersMock.mutex.Unlock()

        for _, e := range mmGetAllOrders.GetAllOrdersMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.oa1, e.results.err
                }</span>
        }

        <span class="cov1" title="1">if mmGetAllOrders.GetAllOrdersMock.defaultExpectation != nil </span><span class="cov1" title="1">{
                mm_atomic.AddUint64(&amp;mmGetAllOrders.GetAllOrdersMock.defaultExpectation.Counter, 1)
                mm_want := mmGetAllOrders.GetAllOrdersMock.defaultExpectation.params
                mm_want_ptrs := mmGetAllOrders.GetAllOrdersMock.defaultExpectation.paramPtrs

                mm_got := OrderRepositoryMockGetAllOrdersParams{ctx}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmGetAllOrders.t.Errorf("OrderRepositoryMock.GetAllOrders got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmGetAllOrders.GetAllOrdersMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                } else<span class="cov1" title="1"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmGetAllOrders.t.Errorf("OrderRepositoryMock.GetAllOrders got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmGetAllOrders.GetAllOrdersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov1" title="1">mm_results := mmGetAllOrders.GetAllOrdersMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmGetAllOrders.t.Fatal("No results are set for the OrderRepositoryMock.GetAllOrders")
                }</span>
                <span class="cov1" title="1">return (*mm_results).oa1, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmGetAllOrders.funcGetAllOrders != nil </span><span class="cov0" title="0">{
                return mmGetAllOrders.funcGetAllOrders(ctx)
        }</span>
        <span class="cov0" title="0">mmGetAllOrders.t.Fatalf("Unexpected call to OrderRepositoryMock.GetAllOrders. %v", ctx)
        return</span>
}

// GetAllOrdersAfterCounter returns a count of finished OrderRepositoryMock.GetAllOrders invocations
func (mmGetAllOrders *OrderRepositoryMock) GetAllOrdersAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetAllOrders.afterGetAllOrdersCounter)
}</span>

// GetAllOrdersBeforeCounter returns a count of OrderRepositoryMock.GetAllOrders invocations
func (mmGetAllOrders *OrderRepositoryMock) GetAllOrdersBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetAllOrders.beforeGetAllOrdersCounter)
}</span>

// Calls returns a list of arguments used in each call to OrderRepositoryMock.GetAllOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAllOrders *mOrderRepositoryMockGetAllOrders) Calls() []*OrderRepositoryMockGetAllOrdersParams <span class="cov0" title="0">{
        mmGetAllOrders.mutex.RLock()

        argCopy := make([]*OrderRepositoryMockGetAllOrdersParams, len(mmGetAllOrders.callArgs))
        copy(argCopy, mmGetAllOrders.callArgs)

        mmGetAllOrders.mutex.RUnlock()

        return argCopy
}</span>

// MinimockGetAllOrdersDone returns true if the count of the GetAllOrders invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockGetAllOrdersDone() bool <span class="cov8" title="33">{
        if m.GetAllOrdersMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="33">for _, e := range m.GetAllOrdersMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="33">return m.GetAllOrdersMock.invocationsDone()</span>
}

// MinimockGetAllOrdersInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockGetAllOrdersInspect() <span class="cov0" title="0">{
        for _, e := range m.GetAllOrdersMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrderRepositoryMock.GetAllOrders at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterGetAllOrdersCounter := mm_atomic.LoadUint64(&amp;m.afterGetAllOrdersCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.GetAllOrdersMock.defaultExpectation != nil &amp;&amp; afterGetAllOrdersCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.GetAllOrdersMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrderRepositoryMock.GetAllOrders at\n%s", m.GetAllOrdersMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to OrderRepositoryMock.GetAllOrders at\n%s with params: %#v", m.GetAllOrdersMock.defaultExpectation.expectationOrigins.origin, *m.GetAllOrdersMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcGetAllOrders != nil &amp;&amp; afterGetAllOrdersCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to OrderRepositoryMock.GetAllOrders at\n%s", m.funcGetAllOrdersOrigin)
        }</span>

        <span class="cov0" title="0">if !m.GetAllOrdersMock.invocationsDone() &amp;&amp; afterGetAllOrdersCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to OrderRepositoryMock.GetAllOrders at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.GetAllOrdersMock.expectedInvocations), m.GetAllOrdersMock.expectedInvocationsOrigin, afterGetAllOrdersCounter)
        }</span>
}

type mOrderRepositoryMockGetByID struct {
        optional           bool
        mock               *OrderRepositoryMock
        defaultExpectation *OrderRepositoryMockGetByIDExpectation
        expectations       []*OrderRepositoryMockGetByIDExpectation

        callArgs []*OrderRepositoryMockGetByIDParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// OrderRepositoryMockGetByIDExpectation specifies expectation struct of the OrderRepository.GetByID
type OrderRepositoryMockGetByIDExpectation struct {
        mock               *OrderRepositoryMock
        params             *OrderRepositoryMockGetByIDParams
        paramPtrs          *OrderRepositoryMockGetByIDParamPtrs
        expectationOrigins OrderRepositoryMockGetByIDExpectationOrigins
        results            *OrderRepositoryMockGetByIDResults
        returnOrigin       string
        Counter            uint64
}

// OrderRepositoryMockGetByIDParams contains parameters of the OrderRepository.GetByID
type OrderRepositoryMockGetByIDParams struct {
        ctx     context.Context
        orderID uint64
}

// OrderRepositoryMockGetByIDParamPtrs contains pointers to parameters of the OrderRepository.GetByID
type OrderRepositoryMockGetByIDParamPtrs struct {
        ctx     *context.Context
        orderID *uint64
}

// OrderRepositoryMockGetByIDResults contains results of the OrderRepository.GetByID
type OrderRepositoryMockGetByIDResults struct {
        o1  domain.Order
        err error
}

// OrderRepositoryMockGetByIDOrigins contains origins of expectations of the OrderRepository.GetByID
type OrderRepositoryMockGetByIDExpectationOrigins struct {
        origin        string
        originCtx     string
        originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetByID *mOrderRepositoryMockGetByID) Optional() *mOrderRepositoryMockGetByID <span class="cov0" title="0">{
        mmGetByID.optional = true
        return mmGetByID
}</span>

// Expect sets up expected params for OrderRepository.GetByID
func (mmGetByID *mOrderRepositoryMockGetByID) Expect(ctx context.Context, orderID uint64) *mOrderRepositoryMockGetByID <span class="cov7" title="24">{
        if mmGetByID.mock.funcGetByID != nil </span><span class="cov0" title="0">{
                mmGetByID.mock.t.Fatalf("OrderRepositoryMock.GetByID mock is already set by Set")
        }</span>

        <span class="cov7" title="24">if mmGetByID.defaultExpectation == nil </span><span class="cov7" title="24">{
                mmGetByID.defaultExpectation = &amp;OrderRepositoryMockGetByIDExpectation{}
        }</span>

        <span class="cov7" title="24">if mmGetByID.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmGetByID.mock.t.Fatalf("OrderRepositoryMock.GetByID mock is already set by ExpectParams functions")
        }</span>

        <span class="cov7" title="24">mmGetByID.defaultExpectation.params = &amp;OrderRepositoryMockGetByIDParams{ctx, orderID}
        mmGetByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmGetByID.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmGetByID.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmGetByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByID.defaultExpectation.params)
                }</span>
        }

        <span class="cov7" title="24">return mmGetByID</span>
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepository.GetByID
func (mmGetByID *mOrderRepositoryMockGetByID) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockGetByID <span class="cov0" title="0">{
        if mmGetByID.mock.funcGetByID != nil </span><span class="cov0" title="0">{
                mmGetByID.mock.t.Fatalf("OrderRepositoryMock.GetByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetByID.defaultExpectation = &amp;OrderRepositoryMockGetByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGetByID.mock.t.Fatalf("OrderRepositoryMock.GetByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGetByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGetByID.defaultExpectation.paramPtrs = &amp;OrderRepositoryMockGetByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGetByID.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmGetByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmGetByID</span>
}

// ExpectOrderIDParam2 sets up expected param orderID for OrderRepository.GetByID
func (mmGetByID *mOrderRepositoryMockGetByID) ExpectOrderIDParam2(orderID uint64) *mOrderRepositoryMockGetByID <span class="cov0" title="0">{
        if mmGetByID.mock.funcGetByID != nil </span><span class="cov0" title="0">{
                mmGetByID.mock.t.Fatalf("OrderRepositoryMock.GetByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetByID.defaultExpectation = &amp;OrderRepositoryMockGetByIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetByID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGetByID.mock.t.Fatalf("OrderRepositoryMock.GetByID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGetByID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGetByID.defaultExpectation.paramPtrs = &amp;OrderRepositoryMockGetByIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGetByID.defaultExpectation.paramPtrs.orderID = &amp;orderID
        mmGetByID.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

        return mmGetByID</span>
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.GetByID
func (mmGetByID *mOrderRepositoryMockGetByID) Inspect(f func(ctx context.Context, orderID uint64)) *mOrderRepositoryMockGetByID <span class="cov0" title="0">{
        if mmGetByID.mock.inspectFuncGetByID != nil </span><span class="cov0" title="0">{
                mmGetByID.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.GetByID")
        }</span>

        <span class="cov0" title="0">mmGetByID.mock.inspectFuncGetByID = f

        return mmGetByID</span>
}

// Return sets up results that will be returned by OrderRepository.GetByID
func (mmGetByID *mOrderRepositoryMockGetByID) Return(o1 domain.Order, err error) *OrderRepositoryMock <span class="cov7" title="24">{
        if mmGetByID.mock.funcGetByID != nil </span><span class="cov0" title="0">{
                mmGetByID.mock.t.Fatalf("OrderRepositoryMock.GetByID mock is already set by Set")
        }</span>

        <span class="cov7" title="24">if mmGetByID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetByID.defaultExpectation = &amp;OrderRepositoryMockGetByIDExpectation{mock: mmGetByID.mock}
        }</span>
        <span class="cov7" title="24">mmGetByID.defaultExpectation.results = &amp;OrderRepositoryMockGetByIDResults{o1, err}
        mmGetByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmGetByID.mock</span>
}

// Set uses given function f to mock the OrderRepository.GetByID method
func (mmGetByID *mOrderRepositoryMockGetByID) Set(f func(ctx context.Context, orderID uint64) (o1 domain.Order, err error)) *OrderRepositoryMock <span class="cov2" title="2">{
        if mmGetByID.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmGetByID.mock.t.Fatalf("Default expectation is already set for the OrderRepository.GetByID method")
        }</span>

        <span class="cov2" title="2">if len(mmGetByID.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmGetByID.mock.t.Fatalf("Some expectations are already set for the OrderRepository.GetByID method")
        }</span>

        <span class="cov2" title="2">mmGetByID.mock.funcGetByID = f
        mmGetByID.mock.funcGetByIDOrigin = minimock.CallerInfo(1)
        return mmGetByID.mock</span>
}

// When sets expectation for the OrderRepository.GetByID which will trigger the result defined by the following
// Then helper
func (mmGetByID *mOrderRepositoryMockGetByID) When(ctx context.Context, orderID uint64) *OrderRepositoryMockGetByIDExpectation <span class="cov0" title="0">{
        if mmGetByID.mock.funcGetByID != nil </span><span class="cov0" title="0">{
                mmGetByID.mock.t.Fatalf("OrderRepositoryMock.GetByID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;OrderRepositoryMockGetByIDExpectation{
                mock:               mmGetByID.mock,
                params:             &amp;OrderRepositoryMockGetByIDParams{ctx, orderID},
                expectationOrigins: OrderRepositoryMockGetByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmGetByID.expectations = append(mmGetByID.expectations, expectation)
        return expectation</span>
}

// Then sets up OrderRepository.GetByID return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockGetByIDExpectation) Then(o1 domain.Order, err error) *OrderRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;OrderRepositoryMockGetByIDResults{o1, err}
        return e.mock
}</span>

// Times sets number of times OrderRepository.GetByID should be invoked
func (mmGetByID *mOrderRepositoryMockGetByID) Times(n uint64) *mOrderRepositoryMockGetByID <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmGetByID.mock.t.Fatalf("Times of OrderRepositoryMock.GetByID mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmGetByID.expectedInvocations, n)
        mmGetByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmGetByID</span>
}

func (mmGetByID *mOrderRepositoryMockGetByID) invocationsDone() bool <span class="cov8" title="33">{
        if len(mmGetByID.expectations) == 0 &amp;&amp; mmGetByID.defaultExpectation == nil &amp;&amp; mmGetByID.mock.funcGetByID == nil </span><span class="cov5" title="7">{
                return true
        }</span>

        <span class="cov7" title="26">totalInvocations := mm_atomic.LoadUint64(&amp;mmGetByID.mock.afterGetByIDCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmGetByID.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// GetByID implements mm_app.OrderRepository
func (mmGetByID *OrderRepositoryMock) GetByID(ctx context.Context, orderID uint64) (o1 domain.Order, err error) <span class="cov8" title="28">{
        mm_atomic.AddUint64(&amp;mmGetByID.beforeGetByIDCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmGetByID.afterGetByIDCounter, 1)

        mmGetByID.t.Helper()

        if mmGetByID.inspectFuncGetByID != nil </span><span class="cov0" title="0">{
                mmGetByID.inspectFuncGetByID(ctx, orderID)
        }</span>

        <span class="cov8" title="28">mm_params := OrderRepositoryMockGetByIDParams{ctx, orderID}

        // Record call args
        mmGetByID.GetByIDMock.mutex.Lock()
        mmGetByID.GetByIDMock.callArgs = append(mmGetByID.GetByIDMock.callArgs, &amp;mm_params)
        mmGetByID.GetByIDMock.mutex.Unlock()

        for _, e := range mmGetByID.GetByIDMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.o1, e.results.err
                }</span>
        }

        <span class="cov8" title="28">if mmGetByID.GetByIDMock.defaultExpectation != nil </span><span class="cov7" title="24">{
                mm_atomic.AddUint64(&amp;mmGetByID.GetByIDMock.defaultExpectation.Counter, 1)
                mm_want := mmGetByID.GetByIDMock.defaultExpectation.params
                mm_want_ptrs := mmGetByID.GetByIDMock.defaultExpectation.paramPtrs

                mm_got := OrderRepositoryMockGetByIDParams{ctx, orderID}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmGetByID.t.Errorf("OrderRepositoryMock.GetByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmGetByID.GetByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.orderID != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) </span><span class="cov0" title="0">{
                                mmGetByID.t.Errorf("OrderRepositoryMock.GetByID got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmGetByID.GetByIDMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
                        }</span>

                } else<span class="cov7" title="24"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmGetByID.t.Errorf("OrderRepositoryMock.GetByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmGetByID.GetByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov7" title="24">mm_results := mmGetByID.GetByIDMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmGetByID.t.Fatal("No results are set for the OrderRepositoryMock.GetByID")
                }</span>
                <span class="cov7" title="24">return (*mm_results).o1, (*mm_results).err</span>
        }
        <span class="cov3" title="4">if mmGetByID.funcGetByID != nil </span><span class="cov3" title="4">{
                return mmGetByID.funcGetByID(ctx, orderID)
        }</span>
        <span class="cov0" title="0">mmGetByID.t.Fatalf("Unexpected call to OrderRepositoryMock.GetByID. %v %v", ctx, orderID)
        return</span>
}

// GetByIDAfterCounter returns a count of finished OrderRepositoryMock.GetByID invocations
func (mmGetByID *OrderRepositoryMock) GetByIDAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetByID.afterGetByIDCounter)
}</span>

// GetByIDBeforeCounter returns a count of OrderRepositoryMock.GetByID invocations
func (mmGetByID *OrderRepositoryMock) GetByIDBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetByID.beforeGetByIDCounter)
}</span>

// Calls returns a list of arguments used in each call to OrderRepositoryMock.GetByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByID *mOrderRepositoryMockGetByID) Calls() []*OrderRepositoryMockGetByIDParams <span class="cov0" title="0">{
        mmGetByID.mutex.RLock()

        argCopy := make([]*OrderRepositoryMockGetByIDParams, len(mmGetByID.callArgs))
        copy(argCopy, mmGetByID.callArgs)

        mmGetByID.mutex.RUnlock()

        return argCopy
}</span>

// MinimockGetByIDDone returns true if the count of the GetByID invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockGetByIDDone() bool <span class="cov8" title="33">{
        if m.GetByIDMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="33">for _, e := range m.GetByIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="33">return m.GetByIDMock.invocationsDone()</span>
}

// MinimockGetByIDInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockGetByIDInspect() <span class="cov0" title="0">{
        for _, e := range m.GetByIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrderRepositoryMock.GetByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterGetByIDCounter := mm_atomic.LoadUint64(&amp;m.afterGetByIDCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.GetByIDMock.defaultExpectation != nil &amp;&amp; afterGetByIDCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.GetByIDMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrderRepositoryMock.GetByID at\n%s", m.GetByIDMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to OrderRepositoryMock.GetByID at\n%s with params: %#v", m.GetByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetByIDMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcGetByID != nil &amp;&amp; afterGetByIDCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to OrderRepositoryMock.GetByID at\n%s", m.funcGetByIDOrigin)
        }</span>

        <span class="cov0" title="0">if !m.GetByIDMock.invocationsDone() &amp;&amp; afterGetByIDCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to OrderRepositoryMock.GetByID at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.GetByIDMock.expectedInvocations), m.GetByIDMock.expectedInvocationsOrigin, afterGetByIDCounter)
        }</span>
}

type mOrderRepositoryMockGetByReceiverID struct {
        optional           bool
        mock               *OrderRepositoryMock
        defaultExpectation *OrderRepositoryMockGetByReceiverIDExpectation
        expectations       []*OrderRepositoryMockGetByReceiverIDExpectation

        callArgs []*OrderRepositoryMockGetByReceiverIDParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// OrderRepositoryMockGetByReceiverIDExpectation specifies expectation struct of the OrderRepository.GetByReceiverID
type OrderRepositoryMockGetByReceiverIDExpectation struct {
        mock               *OrderRepositoryMock
        params             *OrderRepositoryMockGetByReceiverIDParams
        paramPtrs          *OrderRepositoryMockGetByReceiverIDParamPtrs
        expectationOrigins OrderRepositoryMockGetByReceiverIDExpectationOrigins
        results            *OrderRepositoryMockGetByReceiverIDResults
        returnOrigin       string
        Counter            uint64
}

// OrderRepositoryMockGetByReceiverIDParams contains parameters of the OrderRepository.GetByReceiverID
type OrderRepositoryMockGetByReceiverIDParams struct {
        ctx        context.Context
        receiverID uint64
}

// OrderRepositoryMockGetByReceiverIDParamPtrs contains pointers to parameters of the OrderRepository.GetByReceiverID
type OrderRepositoryMockGetByReceiverIDParamPtrs struct {
        ctx        *context.Context
        receiverID *uint64
}

// OrderRepositoryMockGetByReceiverIDResults contains results of the OrderRepository.GetByReceiverID
type OrderRepositoryMockGetByReceiverIDResults struct {
        oa1 []domain.Order
        err error
}

// OrderRepositoryMockGetByReceiverIDOrigins contains origins of expectations of the OrderRepository.GetByReceiverID
type OrderRepositoryMockGetByReceiverIDExpectationOrigins struct {
        origin           string
        originCtx        string
        originReceiverID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetByReceiverID *mOrderRepositoryMockGetByReceiverID) Optional() *mOrderRepositoryMockGetByReceiverID <span class="cov0" title="0">{
        mmGetByReceiverID.optional = true
        return mmGetByReceiverID
}</span>

// Expect sets up expected params for OrderRepository.GetByReceiverID
func (mmGetByReceiverID *mOrderRepositoryMockGetByReceiverID) Expect(ctx context.Context, receiverID uint64) *mOrderRepositoryMockGetByReceiverID <span class="cov3" title="3">{
        if mmGetByReceiverID.mock.funcGetByReceiverID != nil </span><span class="cov0" title="0">{
                mmGetByReceiverID.mock.t.Fatalf("OrderRepositoryMock.GetByReceiverID mock is already set by Set")
        }</span>

        <span class="cov3" title="3">if mmGetByReceiverID.defaultExpectation == nil </span><span class="cov3" title="3">{
                mmGetByReceiverID.defaultExpectation = &amp;OrderRepositoryMockGetByReceiverIDExpectation{}
        }</span>

        <span class="cov3" title="3">if mmGetByReceiverID.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmGetByReceiverID.mock.t.Fatalf("OrderRepositoryMock.GetByReceiverID mock is already set by ExpectParams functions")
        }</span>

        <span class="cov3" title="3">mmGetByReceiverID.defaultExpectation.params = &amp;OrderRepositoryMockGetByReceiverIDParams{ctx, receiverID}
        mmGetByReceiverID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmGetByReceiverID.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmGetByReceiverID.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmGetByReceiverID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByReceiverID.defaultExpectation.params)
                }</span>
        }

        <span class="cov3" title="3">return mmGetByReceiverID</span>
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepository.GetByReceiverID
func (mmGetByReceiverID *mOrderRepositoryMockGetByReceiverID) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockGetByReceiverID <span class="cov0" title="0">{
        if mmGetByReceiverID.mock.funcGetByReceiverID != nil </span><span class="cov0" title="0">{
                mmGetByReceiverID.mock.t.Fatalf("OrderRepositoryMock.GetByReceiverID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetByReceiverID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetByReceiverID.defaultExpectation = &amp;OrderRepositoryMockGetByReceiverIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetByReceiverID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGetByReceiverID.mock.t.Fatalf("OrderRepositoryMock.GetByReceiverID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGetByReceiverID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGetByReceiverID.defaultExpectation.paramPtrs = &amp;OrderRepositoryMockGetByReceiverIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGetByReceiverID.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmGetByReceiverID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmGetByReceiverID</span>
}

// ExpectReceiverIDParam2 sets up expected param receiverID for OrderRepository.GetByReceiverID
func (mmGetByReceiverID *mOrderRepositoryMockGetByReceiverID) ExpectReceiverIDParam2(receiverID uint64) *mOrderRepositoryMockGetByReceiverID <span class="cov0" title="0">{
        if mmGetByReceiverID.mock.funcGetByReceiverID != nil </span><span class="cov0" title="0">{
                mmGetByReceiverID.mock.t.Fatalf("OrderRepositoryMock.GetByReceiverID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetByReceiverID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetByReceiverID.defaultExpectation = &amp;OrderRepositoryMockGetByReceiverIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetByReceiverID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGetByReceiverID.mock.t.Fatalf("OrderRepositoryMock.GetByReceiverID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGetByReceiverID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGetByReceiverID.defaultExpectation.paramPtrs = &amp;OrderRepositoryMockGetByReceiverIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGetByReceiverID.defaultExpectation.paramPtrs.receiverID = &amp;receiverID
        mmGetByReceiverID.defaultExpectation.expectationOrigins.originReceiverID = minimock.CallerInfo(1)

        return mmGetByReceiverID</span>
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.GetByReceiverID
func (mmGetByReceiverID *mOrderRepositoryMockGetByReceiverID) Inspect(f func(ctx context.Context, receiverID uint64)) *mOrderRepositoryMockGetByReceiverID <span class="cov0" title="0">{
        if mmGetByReceiverID.mock.inspectFuncGetByReceiverID != nil </span><span class="cov0" title="0">{
                mmGetByReceiverID.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.GetByReceiverID")
        }</span>

        <span class="cov0" title="0">mmGetByReceiverID.mock.inspectFuncGetByReceiverID = f

        return mmGetByReceiverID</span>
}

// Return sets up results that will be returned by OrderRepository.GetByReceiverID
func (mmGetByReceiverID *mOrderRepositoryMockGetByReceiverID) Return(oa1 []domain.Order, err error) *OrderRepositoryMock <span class="cov3" title="3">{
        if mmGetByReceiverID.mock.funcGetByReceiverID != nil </span><span class="cov0" title="0">{
                mmGetByReceiverID.mock.t.Fatalf("OrderRepositoryMock.GetByReceiverID mock is already set by Set")
        }</span>

        <span class="cov3" title="3">if mmGetByReceiverID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetByReceiverID.defaultExpectation = &amp;OrderRepositoryMockGetByReceiverIDExpectation{mock: mmGetByReceiverID.mock}
        }</span>
        <span class="cov3" title="3">mmGetByReceiverID.defaultExpectation.results = &amp;OrderRepositoryMockGetByReceiverIDResults{oa1, err}
        mmGetByReceiverID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmGetByReceiverID.mock</span>
}

// Set uses given function f to mock the OrderRepository.GetByReceiverID method
func (mmGetByReceiverID *mOrderRepositoryMockGetByReceiverID) Set(f func(ctx context.Context, receiverID uint64) (oa1 []domain.Order, err error)) *OrderRepositoryMock <span class="cov1" title="1">{
        if mmGetByReceiverID.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmGetByReceiverID.mock.t.Fatalf("Default expectation is already set for the OrderRepository.GetByReceiverID method")
        }</span>

        <span class="cov1" title="1">if len(mmGetByReceiverID.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmGetByReceiverID.mock.t.Fatalf("Some expectations are already set for the OrderRepository.GetByReceiverID method")
        }</span>

        <span class="cov1" title="1">mmGetByReceiverID.mock.funcGetByReceiverID = f
        mmGetByReceiverID.mock.funcGetByReceiverIDOrigin = minimock.CallerInfo(1)
        return mmGetByReceiverID.mock</span>
}

// When sets expectation for the OrderRepository.GetByReceiverID which will trigger the result defined by the following
// Then helper
func (mmGetByReceiverID *mOrderRepositoryMockGetByReceiverID) When(ctx context.Context, receiverID uint64) *OrderRepositoryMockGetByReceiverIDExpectation <span class="cov0" title="0">{
        if mmGetByReceiverID.mock.funcGetByReceiverID != nil </span><span class="cov0" title="0">{
                mmGetByReceiverID.mock.t.Fatalf("OrderRepositoryMock.GetByReceiverID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;OrderRepositoryMockGetByReceiverIDExpectation{
                mock:               mmGetByReceiverID.mock,
                params:             &amp;OrderRepositoryMockGetByReceiverIDParams{ctx, receiverID},
                expectationOrigins: OrderRepositoryMockGetByReceiverIDExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmGetByReceiverID.expectations = append(mmGetByReceiverID.expectations, expectation)
        return expectation</span>
}

// Then sets up OrderRepository.GetByReceiverID return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockGetByReceiverIDExpectation) Then(oa1 []domain.Order, err error) *OrderRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;OrderRepositoryMockGetByReceiverIDResults{oa1, err}
        return e.mock
}</span>

// Times sets number of times OrderRepository.GetByReceiverID should be invoked
func (mmGetByReceiverID *mOrderRepositoryMockGetByReceiverID) Times(n uint64) *mOrderRepositoryMockGetByReceiverID <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmGetByReceiverID.mock.t.Fatalf("Times of OrderRepositoryMock.GetByReceiverID mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmGetByReceiverID.expectedInvocations, n)
        mmGetByReceiverID.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmGetByReceiverID</span>
}

func (mmGetByReceiverID *mOrderRepositoryMockGetByReceiverID) invocationsDone() bool <span class="cov8" title="33">{
        if len(mmGetByReceiverID.expectations) == 0 &amp;&amp; mmGetByReceiverID.defaultExpectation == nil &amp;&amp; mmGetByReceiverID.mock.funcGetByReceiverID == nil </span><span class="cov8" title="29">{
                return true
        }</span>

        <span class="cov3" title="4">totalInvocations := mm_atomic.LoadUint64(&amp;mmGetByReceiverID.mock.afterGetByReceiverIDCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmGetByReceiverID.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// GetByReceiverID implements mm_app.OrderRepository
func (mmGetByReceiverID *OrderRepositoryMock) GetByReceiverID(ctx context.Context, receiverID uint64) (oa1 []domain.Order, err error) <span class="cov4" title="5">{
        mm_atomic.AddUint64(&amp;mmGetByReceiverID.beforeGetByReceiverIDCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmGetByReceiverID.afterGetByReceiverIDCounter, 1)

        mmGetByReceiverID.t.Helper()

        if mmGetByReceiverID.inspectFuncGetByReceiverID != nil </span><span class="cov0" title="0">{
                mmGetByReceiverID.inspectFuncGetByReceiverID(ctx, receiverID)
        }</span>

        <span class="cov4" title="5">mm_params := OrderRepositoryMockGetByReceiverIDParams{ctx, receiverID}

        // Record call args
        mmGetByReceiverID.GetByReceiverIDMock.mutex.Lock()
        mmGetByReceiverID.GetByReceiverIDMock.callArgs = append(mmGetByReceiverID.GetByReceiverIDMock.callArgs, &amp;mm_params)
        mmGetByReceiverID.GetByReceiverIDMock.mutex.Unlock()

        for _, e := range mmGetByReceiverID.GetByReceiverIDMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.oa1, e.results.err
                }</span>
        }

        <span class="cov4" title="5">if mmGetByReceiverID.GetByReceiverIDMock.defaultExpectation != nil </span><span class="cov3" title="3">{
                mm_atomic.AddUint64(&amp;mmGetByReceiverID.GetByReceiverIDMock.defaultExpectation.Counter, 1)
                mm_want := mmGetByReceiverID.GetByReceiverIDMock.defaultExpectation.params
                mm_want_ptrs := mmGetByReceiverID.GetByReceiverIDMock.defaultExpectation.paramPtrs

                mm_got := OrderRepositoryMockGetByReceiverIDParams{ctx, receiverID}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmGetByReceiverID.t.Errorf("OrderRepositoryMock.GetByReceiverID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmGetByReceiverID.GetByReceiverIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.receiverID != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.receiverID, mm_got.receiverID) </span><span class="cov0" title="0">{
                                mmGetByReceiverID.t.Errorf("OrderRepositoryMock.GetByReceiverID got unexpected parameter receiverID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmGetByReceiverID.GetByReceiverIDMock.defaultExpectation.expectationOrigins.originReceiverID, *mm_want_ptrs.receiverID, mm_got.receiverID, minimock.Diff(*mm_want_ptrs.receiverID, mm_got.receiverID))
                        }</span>

                } else<span class="cov3" title="3"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmGetByReceiverID.t.Errorf("OrderRepositoryMock.GetByReceiverID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmGetByReceiverID.GetByReceiverIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov3" title="3">mm_results := mmGetByReceiverID.GetByReceiverIDMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmGetByReceiverID.t.Fatal("No results are set for the OrderRepositoryMock.GetByReceiverID")
                }</span>
                <span class="cov3" title="3">return (*mm_results).oa1, (*mm_results).err</span>
        }
        <span class="cov2" title="2">if mmGetByReceiverID.funcGetByReceiverID != nil </span><span class="cov2" title="2">{
                return mmGetByReceiverID.funcGetByReceiverID(ctx, receiverID)
        }</span>
        <span class="cov0" title="0">mmGetByReceiverID.t.Fatalf("Unexpected call to OrderRepositoryMock.GetByReceiverID. %v %v", ctx, receiverID)
        return</span>
}

// GetByReceiverIDAfterCounter returns a count of finished OrderRepositoryMock.GetByReceiverID invocations
func (mmGetByReceiverID *OrderRepositoryMock) GetByReceiverIDAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetByReceiverID.afterGetByReceiverIDCounter)
}</span>

// GetByReceiverIDBeforeCounter returns a count of OrderRepositoryMock.GetByReceiverID invocations
func (mmGetByReceiverID *OrderRepositoryMock) GetByReceiverIDBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetByReceiverID.beforeGetByReceiverIDCounter)
}</span>

// Calls returns a list of arguments used in each call to OrderRepositoryMock.GetByReceiverID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByReceiverID *mOrderRepositoryMockGetByReceiverID) Calls() []*OrderRepositoryMockGetByReceiverIDParams <span class="cov0" title="0">{
        mmGetByReceiverID.mutex.RLock()

        argCopy := make([]*OrderRepositoryMockGetByReceiverIDParams, len(mmGetByReceiverID.callArgs))
        copy(argCopy, mmGetByReceiverID.callArgs)

        mmGetByReceiverID.mutex.RUnlock()

        return argCopy
}</span>

// MinimockGetByReceiverIDDone returns true if the count of the GetByReceiverID invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockGetByReceiverIDDone() bool <span class="cov8" title="33">{
        if m.GetByReceiverIDMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="33">for _, e := range m.GetByReceiverIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="33">return m.GetByReceiverIDMock.invocationsDone()</span>
}

// MinimockGetByReceiverIDInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockGetByReceiverIDInspect() <span class="cov0" title="0">{
        for _, e := range m.GetByReceiverIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrderRepositoryMock.GetByReceiverID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterGetByReceiverIDCounter := mm_atomic.LoadUint64(&amp;m.afterGetByReceiverIDCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.GetByReceiverIDMock.defaultExpectation != nil &amp;&amp; afterGetByReceiverIDCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.GetByReceiverIDMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrderRepositoryMock.GetByReceiverID at\n%s", m.GetByReceiverIDMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to OrderRepositoryMock.GetByReceiverID at\n%s with params: %#v", m.GetByReceiverIDMock.defaultExpectation.expectationOrigins.origin, *m.GetByReceiverIDMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcGetByReceiverID != nil &amp;&amp; afterGetByReceiverIDCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to OrderRepositoryMock.GetByReceiverID at\n%s", m.funcGetByReceiverIDOrigin)
        }</span>

        <span class="cov0" title="0">if !m.GetByReceiverIDMock.invocationsDone() &amp;&amp; afterGetByReceiverIDCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to OrderRepositoryMock.GetByReceiverID at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.GetByReceiverIDMock.expectedInvocations), m.GetByReceiverIDMock.expectedInvocationsOrigin, afterGetByReceiverIDCounter)
        }</span>
}

type mOrderRepositoryMockGetHistoryByOrderID struct {
        optional           bool
        mock               *OrderRepositoryMock
        defaultExpectation *OrderRepositoryMockGetHistoryByOrderIDExpectation
        expectations       []*OrderRepositoryMockGetHistoryByOrderIDExpectation

        callArgs []*OrderRepositoryMockGetHistoryByOrderIDParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// OrderRepositoryMockGetHistoryByOrderIDExpectation specifies expectation struct of the OrderRepository.GetHistoryByOrderID
type OrderRepositoryMockGetHistoryByOrderIDExpectation struct {
        mock               *OrderRepositoryMock
        params             *OrderRepositoryMockGetHistoryByOrderIDParams
        paramPtrs          *OrderRepositoryMockGetHistoryByOrderIDParamPtrs
        expectationOrigins OrderRepositoryMockGetHistoryByOrderIDExpectationOrigins
        results            *OrderRepositoryMockGetHistoryByOrderIDResults
        returnOrigin       string
        Counter            uint64
}

// OrderRepositoryMockGetHistoryByOrderIDParams contains parameters of the OrderRepository.GetHistoryByOrderID
type OrderRepositoryMockGetHistoryByOrderIDParams struct {
        ctx     context.Context
        orderID uint64
}

// OrderRepositoryMockGetHistoryByOrderIDParamPtrs contains pointers to parameters of the OrderRepository.GetHistoryByOrderID
type OrderRepositoryMockGetHistoryByOrderIDParamPtrs struct {
        ctx     *context.Context
        orderID *uint64
}

// OrderRepositoryMockGetHistoryByOrderIDResults contains results of the OrderRepository.GetHistoryByOrderID
type OrderRepositoryMockGetHistoryByOrderIDResults struct {
        oa1 []domain.OrderHistory
        err error
}

// OrderRepositoryMockGetHistoryByOrderIDOrigins contains origins of expectations of the OrderRepository.GetHistoryByOrderID
type OrderRepositoryMockGetHistoryByOrderIDExpectationOrigins struct {
        origin        string
        originCtx     string
        originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetHistoryByOrderID *mOrderRepositoryMockGetHistoryByOrderID) Optional() *mOrderRepositoryMockGetHistoryByOrderID <span class="cov0" title="0">{
        mmGetHistoryByOrderID.optional = true
        return mmGetHistoryByOrderID
}</span>

// Expect sets up expected params for OrderRepository.GetHistoryByOrderID
func (mmGetHistoryByOrderID *mOrderRepositoryMockGetHistoryByOrderID) Expect(ctx context.Context, orderID uint64) *mOrderRepositoryMockGetHistoryByOrderID <span class="cov0" title="0">{
        if mmGetHistoryByOrderID.mock.funcGetHistoryByOrderID != nil </span><span class="cov0" title="0">{
                mmGetHistoryByOrderID.mock.t.Fatalf("OrderRepositoryMock.GetHistoryByOrderID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetHistoryByOrderID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetHistoryByOrderID.defaultExpectation = &amp;OrderRepositoryMockGetHistoryByOrderIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetHistoryByOrderID.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmGetHistoryByOrderID.mock.t.Fatalf("OrderRepositoryMock.GetHistoryByOrderID mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmGetHistoryByOrderID.defaultExpectation.params = &amp;OrderRepositoryMockGetHistoryByOrderIDParams{ctx, orderID}
        mmGetHistoryByOrderID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmGetHistoryByOrderID.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmGetHistoryByOrderID.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmGetHistoryByOrderID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetHistoryByOrderID.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmGetHistoryByOrderID</span>
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepository.GetHistoryByOrderID
func (mmGetHistoryByOrderID *mOrderRepositoryMockGetHistoryByOrderID) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockGetHistoryByOrderID <span class="cov0" title="0">{
        if mmGetHistoryByOrderID.mock.funcGetHistoryByOrderID != nil </span><span class="cov0" title="0">{
                mmGetHistoryByOrderID.mock.t.Fatalf("OrderRepositoryMock.GetHistoryByOrderID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetHistoryByOrderID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetHistoryByOrderID.defaultExpectation = &amp;OrderRepositoryMockGetHistoryByOrderIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetHistoryByOrderID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGetHistoryByOrderID.mock.t.Fatalf("OrderRepositoryMock.GetHistoryByOrderID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGetHistoryByOrderID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGetHistoryByOrderID.defaultExpectation.paramPtrs = &amp;OrderRepositoryMockGetHistoryByOrderIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGetHistoryByOrderID.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmGetHistoryByOrderID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmGetHistoryByOrderID</span>
}

// ExpectOrderIDParam2 sets up expected param orderID for OrderRepository.GetHistoryByOrderID
func (mmGetHistoryByOrderID *mOrderRepositoryMockGetHistoryByOrderID) ExpectOrderIDParam2(orderID uint64) *mOrderRepositoryMockGetHistoryByOrderID <span class="cov0" title="0">{
        if mmGetHistoryByOrderID.mock.funcGetHistoryByOrderID != nil </span><span class="cov0" title="0">{
                mmGetHistoryByOrderID.mock.t.Fatalf("OrderRepositoryMock.GetHistoryByOrderID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetHistoryByOrderID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetHistoryByOrderID.defaultExpectation = &amp;OrderRepositoryMockGetHistoryByOrderIDExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetHistoryByOrderID.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGetHistoryByOrderID.mock.t.Fatalf("OrderRepositoryMock.GetHistoryByOrderID mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGetHistoryByOrderID.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGetHistoryByOrderID.defaultExpectation.paramPtrs = &amp;OrderRepositoryMockGetHistoryByOrderIDParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGetHistoryByOrderID.defaultExpectation.paramPtrs.orderID = &amp;orderID
        mmGetHistoryByOrderID.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

        return mmGetHistoryByOrderID</span>
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.GetHistoryByOrderID
func (mmGetHistoryByOrderID *mOrderRepositoryMockGetHistoryByOrderID) Inspect(f func(ctx context.Context, orderID uint64)) *mOrderRepositoryMockGetHistoryByOrderID <span class="cov0" title="0">{
        if mmGetHistoryByOrderID.mock.inspectFuncGetHistoryByOrderID != nil </span><span class="cov0" title="0">{
                mmGetHistoryByOrderID.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.GetHistoryByOrderID")
        }</span>

        <span class="cov0" title="0">mmGetHistoryByOrderID.mock.inspectFuncGetHistoryByOrderID = f

        return mmGetHistoryByOrderID</span>
}

// Return sets up results that will be returned by OrderRepository.GetHistoryByOrderID
func (mmGetHistoryByOrderID *mOrderRepositoryMockGetHistoryByOrderID) Return(oa1 []domain.OrderHistory, err error) *OrderRepositoryMock <span class="cov0" title="0">{
        if mmGetHistoryByOrderID.mock.funcGetHistoryByOrderID != nil </span><span class="cov0" title="0">{
                mmGetHistoryByOrderID.mock.t.Fatalf("OrderRepositoryMock.GetHistoryByOrderID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetHistoryByOrderID.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetHistoryByOrderID.defaultExpectation = &amp;OrderRepositoryMockGetHistoryByOrderIDExpectation{mock: mmGetHistoryByOrderID.mock}
        }</span>
        <span class="cov0" title="0">mmGetHistoryByOrderID.defaultExpectation.results = &amp;OrderRepositoryMockGetHistoryByOrderIDResults{oa1, err}
        mmGetHistoryByOrderID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmGetHistoryByOrderID.mock</span>
}

// Set uses given function f to mock the OrderRepository.GetHistoryByOrderID method
func (mmGetHistoryByOrderID *mOrderRepositoryMockGetHistoryByOrderID) Set(f func(ctx context.Context, orderID uint64) (oa1 []domain.OrderHistory, err error)) *OrderRepositoryMock <span class="cov1" title="1">{
        if mmGetHistoryByOrderID.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmGetHistoryByOrderID.mock.t.Fatalf("Default expectation is already set for the OrderRepository.GetHistoryByOrderID method")
        }</span>

        <span class="cov1" title="1">if len(mmGetHistoryByOrderID.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmGetHistoryByOrderID.mock.t.Fatalf("Some expectations are already set for the OrderRepository.GetHistoryByOrderID method")
        }</span>

        <span class="cov1" title="1">mmGetHistoryByOrderID.mock.funcGetHistoryByOrderID = f
        mmGetHistoryByOrderID.mock.funcGetHistoryByOrderIDOrigin = minimock.CallerInfo(1)
        return mmGetHistoryByOrderID.mock</span>
}

// When sets expectation for the OrderRepository.GetHistoryByOrderID which will trigger the result defined by the following
// Then helper
func (mmGetHistoryByOrderID *mOrderRepositoryMockGetHistoryByOrderID) When(ctx context.Context, orderID uint64) *OrderRepositoryMockGetHistoryByOrderIDExpectation <span class="cov0" title="0">{
        if mmGetHistoryByOrderID.mock.funcGetHistoryByOrderID != nil </span><span class="cov0" title="0">{
                mmGetHistoryByOrderID.mock.t.Fatalf("OrderRepositoryMock.GetHistoryByOrderID mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;OrderRepositoryMockGetHistoryByOrderIDExpectation{
                mock:               mmGetHistoryByOrderID.mock,
                params:             &amp;OrderRepositoryMockGetHistoryByOrderIDParams{ctx, orderID},
                expectationOrigins: OrderRepositoryMockGetHistoryByOrderIDExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmGetHistoryByOrderID.expectations = append(mmGetHistoryByOrderID.expectations, expectation)
        return expectation</span>
}

// Then sets up OrderRepository.GetHistoryByOrderID return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockGetHistoryByOrderIDExpectation) Then(oa1 []domain.OrderHistory, err error) *OrderRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;OrderRepositoryMockGetHistoryByOrderIDResults{oa1, err}
        return e.mock
}</span>

// Times sets number of times OrderRepository.GetHistoryByOrderID should be invoked
func (mmGetHistoryByOrderID *mOrderRepositoryMockGetHistoryByOrderID) Times(n uint64) *mOrderRepositoryMockGetHistoryByOrderID <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmGetHistoryByOrderID.mock.t.Fatalf("Times of OrderRepositoryMock.GetHistoryByOrderID mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmGetHistoryByOrderID.expectedInvocations, n)
        mmGetHistoryByOrderID.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmGetHistoryByOrderID</span>
}

func (mmGetHistoryByOrderID *mOrderRepositoryMockGetHistoryByOrderID) invocationsDone() bool <span class="cov8" title="33">{
        if len(mmGetHistoryByOrderID.expectations) == 0 &amp;&amp; mmGetHistoryByOrderID.defaultExpectation == nil &amp;&amp; mmGetHistoryByOrderID.mock.funcGetHistoryByOrderID == nil </span><span class="cov8" title="32">{
                return true
        }</span>

        <span class="cov1" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmGetHistoryByOrderID.mock.afterGetHistoryByOrderIDCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmGetHistoryByOrderID.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// GetHistoryByOrderID implements mm_app.OrderRepository
func (mmGetHistoryByOrderID *OrderRepositoryMock) GetHistoryByOrderID(ctx context.Context, orderID uint64) (oa1 []domain.OrderHistory, err error) <span class="cov2" title="2">{
        mm_atomic.AddUint64(&amp;mmGetHistoryByOrderID.beforeGetHistoryByOrderIDCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmGetHistoryByOrderID.afterGetHistoryByOrderIDCounter, 1)

        mmGetHistoryByOrderID.t.Helper()

        if mmGetHistoryByOrderID.inspectFuncGetHistoryByOrderID != nil </span><span class="cov0" title="0">{
                mmGetHistoryByOrderID.inspectFuncGetHistoryByOrderID(ctx, orderID)
        }</span>

        <span class="cov2" title="2">mm_params := OrderRepositoryMockGetHistoryByOrderIDParams{ctx, orderID}

        // Record call args
        mmGetHistoryByOrderID.GetHistoryByOrderIDMock.mutex.Lock()
        mmGetHistoryByOrderID.GetHistoryByOrderIDMock.callArgs = append(mmGetHistoryByOrderID.GetHistoryByOrderIDMock.callArgs, &amp;mm_params)
        mmGetHistoryByOrderID.GetHistoryByOrderIDMock.mutex.Unlock()

        for _, e := range mmGetHistoryByOrderID.GetHistoryByOrderIDMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.oa1, e.results.err
                }</span>
        }

        <span class="cov2" title="2">if mmGetHistoryByOrderID.GetHistoryByOrderIDMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmGetHistoryByOrderID.GetHistoryByOrderIDMock.defaultExpectation.Counter, 1)
                mm_want := mmGetHistoryByOrderID.GetHistoryByOrderIDMock.defaultExpectation.params
                mm_want_ptrs := mmGetHistoryByOrderID.GetHistoryByOrderIDMock.defaultExpectation.paramPtrs

                mm_got := OrderRepositoryMockGetHistoryByOrderIDParams{ctx, orderID}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmGetHistoryByOrderID.t.Errorf("OrderRepositoryMock.GetHistoryByOrderID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmGetHistoryByOrderID.GetHistoryByOrderIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.orderID != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) </span><span class="cov0" title="0">{
                                mmGetHistoryByOrderID.t.Errorf("OrderRepositoryMock.GetHistoryByOrderID got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmGetHistoryByOrderID.GetHistoryByOrderIDMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmGetHistoryByOrderID.t.Errorf("OrderRepositoryMock.GetHistoryByOrderID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmGetHistoryByOrderID.GetHistoryByOrderIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmGetHistoryByOrderID.GetHistoryByOrderIDMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmGetHistoryByOrderID.t.Fatal("No results are set for the OrderRepositoryMock.GetHistoryByOrderID")
                }</span>
                <span class="cov0" title="0">return (*mm_results).oa1, (*mm_results).err</span>
        }
        <span class="cov2" title="2">if mmGetHistoryByOrderID.funcGetHistoryByOrderID != nil </span><span class="cov2" title="2">{
                return mmGetHistoryByOrderID.funcGetHistoryByOrderID(ctx, orderID)
        }</span>
        <span class="cov0" title="0">mmGetHistoryByOrderID.t.Fatalf("Unexpected call to OrderRepositoryMock.GetHistoryByOrderID. %v %v", ctx, orderID)
        return</span>
}

// GetHistoryByOrderIDAfterCounter returns a count of finished OrderRepositoryMock.GetHistoryByOrderID invocations
func (mmGetHistoryByOrderID *OrderRepositoryMock) GetHistoryByOrderIDAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetHistoryByOrderID.afterGetHistoryByOrderIDCounter)
}</span>

// GetHistoryByOrderIDBeforeCounter returns a count of OrderRepositoryMock.GetHistoryByOrderID invocations
func (mmGetHistoryByOrderID *OrderRepositoryMock) GetHistoryByOrderIDBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetHistoryByOrderID.beforeGetHistoryByOrderIDCounter)
}</span>

// Calls returns a list of arguments used in each call to OrderRepositoryMock.GetHistoryByOrderID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetHistoryByOrderID *mOrderRepositoryMockGetHistoryByOrderID) Calls() []*OrderRepositoryMockGetHistoryByOrderIDParams <span class="cov0" title="0">{
        mmGetHistoryByOrderID.mutex.RLock()

        argCopy := make([]*OrderRepositoryMockGetHistoryByOrderIDParams, len(mmGetHistoryByOrderID.callArgs))
        copy(argCopy, mmGetHistoryByOrderID.callArgs)

        mmGetHistoryByOrderID.mutex.RUnlock()

        return argCopy
}</span>

// MinimockGetHistoryByOrderIDDone returns true if the count of the GetHistoryByOrderID invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockGetHistoryByOrderIDDone() bool <span class="cov8" title="33">{
        if m.GetHistoryByOrderIDMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="33">for _, e := range m.GetHistoryByOrderIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="33">return m.GetHistoryByOrderIDMock.invocationsDone()</span>
}

// MinimockGetHistoryByOrderIDInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockGetHistoryByOrderIDInspect() <span class="cov0" title="0">{
        for _, e := range m.GetHistoryByOrderIDMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrderRepositoryMock.GetHistoryByOrderID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterGetHistoryByOrderIDCounter := mm_atomic.LoadUint64(&amp;m.afterGetHistoryByOrderIDCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.GetHistoryByOrderIDMock.defaultExpectation != nil &amp;&amp; afterGetHistoryByOrderIDCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.GetHistoryByOrderIDMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrderRepositoryMock.GetHistoryByOrderID at\n%s", m.GetHistoryByOrderIDMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to OrderRepositoryMock.GetHistoryByOrderID at\n%s with params: %#v", m.GetHistoryByOrderIDMock.defaultExpectation.expectationOrigins.origin, *m.GetHistoryByOrderIDMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcGetHistoryByOrderID != nil &amp;&amp; afterGetHistoryByOrderIDCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to OrderRepositoryMock.GetHistoryByOrderID at\n%s", m.funcGetHistoryByOrderIDOrigin)
        }</span>

        <span class="cov0" title="0">if !m.GetHistoryByOrderIDMock.invocationsDone() &amp;&amp; afterGetHistoryByOrderIDCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to OrderRepositoryMock.GetHistoryByOrderID at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.GetHistoryByOrderIDMock.expectedInvocations), m.GetHistoryByOrderIDMock.expectedInvocationsOrigin, afterGetHistoryByOrderIDCounter)
        }</span>
}

type mOrderRepositoryMockGetPackageRules struct {
        optional           bool
        mock               *OrderRepositoryMock
        defaultExpectation *OrderRepositoryMockGetPackageRulesExpectation
        expectations       []*OrderRepositoryMockGetPackageRulesExpectation

        callArgs []*OrderRepositoryMockGetPackageRulesParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// OrderRepositoryMockGetPackageRulesExpectation specifies expectation struct of the OrderRepository.GetPackageRules
type OrderRepositoryMockGetPackageRulesExpectation struct {
        mock               *OrderRepositoryMock
        params             *OrderRepositoryMockGetPackageRulesParams
        paramPtrs          *OrderRepositoryMockGetPackageRulesParamPtrs
        expectationOrigins OrderRepositoryMockGetPackageRulesExpectationOrigins
        results            *OrderRepositoryMockGetPackageRulesResults
        returnOrigin       string
        Counter            uint64
}

// OrderRepositoryMockGetPackageRulesParams contains parameters of the OrderRepository.GetPackageRules
type OrderRepositoryMockGetPackageRulesParams struct {
        ctx  context.Context
        code string
}

// OrderRepositoryMockGetPackageRulesParamPtrs contains pointers to parameters of the OrderRepository.GetPackageRules
type OrderRepositoryMockGetPackageRulesParamPtrs struct {
        ctx  *context.Context
        code *string
}

// OrderRepositoryMockGetPackageRulesResults contains results of the OrderRepository.GetPackageRules
type OrderRepositoryMockGetPackageRulesResults struct {
        pa1 []domain.PackageRules
        err error
}

// OrderRepositoryMockGetPackageRulesOrigins contains origins of expectations of the OrderRepository.GetPackageRules
type OrderRepositoryMockGetPackageRulesExpectationOrigins struct {
        origin     string
        originCtx  string
        originCode string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPackageRules *mOrderRepositoryMockGetPackageRules) Optional() *mOrderRepositoryMockGetPackageRules <span class="cov0" title="0">{
        mmGetPackageRules.optional = true
        return mmGetPackageRules
}</span>

// Expect sets up expected params for OrderRepository.GetPackageRules
func (mmGetPackageRules *mOrderRepositoryMockGetPackageRules) Expect(ctx context.Context, code string) *mOrderRepositoryMockGetPackageRules <span class="cov4" title="5">{
        if mmGetPackageRules.mock.funcGetPackageRules != nil </span><span class="cov0" title="0">{
                mmGetPackageRules.mock.t.Fatalf("OrderRepositoryMock.GetPackageRules mock is already set by Set")
        }</span>

        <span class="cov4" title="5">if mmGetPackageRules.defaultExpectation == nil </span><span class="cov4" title="5">{
                mmGetPackageRules.defaultExpectation = &amp;OrderRepositoryMockGetPackageRulesExpectation{}
        }</span>

        <span class="cov4" title="5">if mmGetPackageRules.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmGetPackageRules.mock.t.Fatalf("OrderRepositoryMock.GetPackageRules mock is already set by ExpectParams functions")
        }</span>

        <span class="cov4" title="5">mmGetPackageRules.defaultExpectation.params = &amp;OrderRepositoryMockGetPackageRulesParams{ctx, code}
        mmGetPackageRules.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmGetPackageRules.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmGetPackageRules.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmGetPackageRules.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPackageRules.defaultExpectation.params)
                }</span>
        }

        <span class="cov4" title="5">return mmGetPackageRules</span>
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepository.GetPackageRules
func (mmGetPackageRules *mOrderRepositoryMockGetPackageRules) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockGetPackageRules <span class="cov0" title="0">{
        if mmGetPackageRules.mock.funcGetPackageRules != nil </span><span class="cov0" title="0">{
                mmGetPackageRules.mock.t.Fatalf("OrderRepositoryMock.GetPackageRules mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetPackageRules.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetPackageRules.defaultExpectation = &amp;OrderRepositoryMockGetPackageRulesExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetPackageRules.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGetPackageRules.mock.t.Fatalf("OrderRepositoryMock.GetPackageRules mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGetPackageRules.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGetPackageRules.defaultExpectation.paramPtrs = &amp;OrderRepositoryMockGetPackageRulesParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGetPackageRules.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmGetPackageRules.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmGetPackageRules</span>
}

// ExpectCodeParam2 sets up expected param code for OrderRepository.GetPackageRules
func (mmGetPackageRules *mOrderRepositoryMockGetPackageRules) ExpectCodeParam2(code string) *mOrderRepositoryMockGetPackageRules <span class="cov0" title="0">{
        if mmGetPackageRules.mock.funcGetPackageRules != nil </span><span class="cov0" title="0">{
                mmGetPackageRules.mock.t.Fatalf("OrderRepositoryMock.GetPackageRules mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetPackageRules.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetPackageRules.defaultExpectation = &amp;OrderRepositoryMockGetPackageRulesExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetPackageRules.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGetPackageRules.mock.t.Fatalf("OrderRepositoryMock.GetPackageRules mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGetPackageRules.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGetPackageRules.defaultExpectation.paramPtrs = &amp;OrderRepositoryMockGetPackageRulesParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGetPackageRules.defaultExpectation.paramPtrs.code = &amp;code
        mmGetPackageRules.defaultExpectation.expectationOrigins.originCode = minimock.CallerInfo(1)

        return mmGetPackageRules</span>
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.GetPackageRules
func (mmGetPackageRules *mOrderRepositoryMockGetPackageRules) Inspect(f func(ctx context.Context, code string)) *mOrderRepositoryMockGetPackageRules <span class="cov0" title="0">{
        if mmGetPackageRules.mock.inspectFuncGetPackageRules != nil </span><span class="cov0" title="0">{
                mmGetPackageRules.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.GetPackageRules")
        }</span>

        <span class="cov0" title="0">mmGetPackageRules.mock.inspectFuncGetPackageRules = f

        return mmGetPackageRules</span>
}

// Return sets up results that will be returned by OrderRepository.GetPackageRules
func (mmGetPackageRules *mOrderRepositoryMockGetPackageRules) Return(pa1 []domain.PackageRules, err error) *OrderRepositoryMock <span class="cov4" title="5">{
        if mmGetPackageRules.mock.funcGetPackageRules != nil </span><span class="cov0" title="0">{
                mmGetPackageRules.mock.t.Fatalf("OrderRepositoryMock.GetPackageRules mock is already set by Set")
        }</span>

        <span class="cov4" title="5">if mmGetPackageRules.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetPackageRules.defaultExpectation = &amp;OrderRepositoryMockGetPackageRulesExpectation{mock: mmGetPackageRules.mock}
        }</span>
        <span class="cov4" title="5">mmGetPackageRules.defaultExpectation.results = &amp;OrderRepositoryMockGetPackageRulesResults{pa1, err}
        mmGetPackageRules.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmGetPackageRules.mock</span>
}

// Set uses given function f to mock the OrderRepository.GetPackageRules method
func (mmGetPackageRules *mOrderRepositoryMockGetPackageRules) Set(f func(ctx context.Context, code string) (pa1 []domain.PackageRules, err error)) *OrderRepositoryMock <span class="cov0" title="0">{
        if mmGetPackageRules.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmGetPackageRules.mock.t.Fatalf("Default expectation is already set for the OrderRepository.GetPackageRules method")
        }</span>

        <span class="cov0" title="0">if len(mmGetPackageRules.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmGetPackageRules.mock.t.Fatalf("Some expectations are already set for the OrderRepository.GetPackageRules method")
        }</span>

        <span class="cov0" title="0">mmGetPackageRules.mock.funcGetPackageRules = f
        mmGetPackageRules.mock.funcGetPackageRulesOrigin = minimock.CallerInfo(1)
        return mmGetPackageRules.mock</span>
}

// When sets expectation for the OrderRepository.GetPackageRules which will trigger the result defined by the following
// Then helper
func (mmGetPackageRules *mOrderRepositoryMockGetPackageRules) When(ctx context.Context, code string) *OrderRepositoryMockGetPackageRulesExpectation <span class="cov0" title="0">{
        if mmGetPackageRules.mock.funcGetPackageRules != nil </span><span class="cov0" title="0">{
                mmGetPackageRules.mock.t.Fatalf("OrderRepositoryMock.GetPackageRules mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;OrderRepositoryMockGetPackageRulesExpectation{
                mock:               mmGetPackageRules.mock,
                params:             &amp;OrderRepositoryMockGetPackageRulesParams{ctx, code},
                expectationOrigins: OrderRepositoryMockGetPackageRulesExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmGetPackageRules.expectations = append(mmGetPackageRules.expectations, expectation)
        return expectation</span>
}

// Then sets up OrderRepository.GetPackageRules return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockGetPackageRulesExpectation) Then(pa1 []domain.PackageRules, err error) *OrderRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;OrderRepositoryMockGetPackageRulesResults{pa1, err}
        return e.mock
}</span>

// Times sets number of times OrderRepository.GetPackageRules should be invoked
func (mmGetPackageRules *mOrderRepositoryMockGetPackageRules) Times(n uint64) *mOrderRepositoryMockGetPackageRules <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmGetPackageRules.mock.t.Fatalf("Times of OrderRepositoryMock.GetPackageRules mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmGetPackageRules.expectedInvocations, n)
        mmGetPackageRules.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmGetPackageRules</span>
}

func (mmGetPackageRules *mOrderRepositoryMockGetPackageRules) invocationsDone() bool <span class="cov8" title="33">{
        if len(mmGetPackageRules.expectations) == 0 &amp;&amp; mmGetPackageRules.defaultExpectation == nil &amp;&amp; mmGetPackageRules.mock.funcGetPackageRules == nil </span><span class="cov8" title="28">{
                return true
        }</span>

        <span class="cov4" title="5">totalInvocations := mm_atomic.LoadUint64(&amp;mmGetPackageRules.mock.afterGetPackageRulesCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmGetPackageRules.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// GetPackageRules implements mm_app.OrderRepository
func (mmGetPackageRules *OrderRepositoryMock) GetPackageRules(ctx context.Context, code string) (pa1 []domain.PackageRules, err error) <span class="cov4" title="5">{
        mm_atomic.AddUint64(&amp;mmGetPackageRules.beforeGetPackageRulesCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmGetPackageRules.afterGetPackageRulesCounter, 1)

        mmGetPackageRules.t.Helper()

        if mmGetPackageRules.inspectFuncGetPackageRules != nil </span><span class="cov0" title="0">{
                mmGetPackageRules.inspectFuncGetPackageRules(ctx, code)
        }</span>

        <span class="cov4" title="5">mm_params := OrderRepositoryMockGetPackageRulesParams{ctx, code}

        // Record call args
        mmGetPackageRules.GetPackageRulesMock.mutex.Lock()
        mmGetPackageRules.GetPackageRulesMock.callArgs = append(mmGetPackageRules.GetPackageRulesMock.callArgs, &amp;mm_params)
        mmGetPackageRules.GetPackageRulesMock.mutex.Unlock()

        for _, e := range mmGetPackageRules.GetPackageRulesMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.pa1, e.results.err
                }</span>
        }

        <span class="cov4" title="5">if mmGetPackageRules.GetPackageRulesMock.defaultExpectation != nil </span><span class="cov4" title="5">{
                mm_atomic.AddUint64(&amp;mmGetPackageRules.GetPackageRulesMock.defaultExpectation.Counter, 1)
                mm_want := mmGetPackageRules.GetPackageRulesMock.defaultExpectation.params
                mm_want_ptrs := mmGetPackageRules.GetPackageRulesMock.defaultExpectation.paramPtrs

                mm_got := OrderRepositoryMockGetPackageRulesParams{ctx, code}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmGetPackageRules.t.Errorf("OrderRepositoryMock.GetPackageRules got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmGetPackageRules.GetPackageRulesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.code != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.code, mm_got.code) </span><span class="cov0" title="0">{
                                mmGetPackageRules.t.Errorf("OrderRepositoryMock.GetPackageRules got unexpected parameter code, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmGetPackageRules.GetPackageRulesMock.defaultExpectation.expectationOrigins.originCode, *mm_want_ptrs.code, mm_got.code, minimock.Diff(*mm_want_ptrs.code, mm_got.code))
                        }</span>

                } else<span class="cov4" title="5"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmGetPackageRules.t.Errorf("OrderRepositoryMock.GetPackageRules got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmGetPackageRules.GetPackageRulesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov4" title="5">mm_results := mmGetPackageRules.GetPackageRulesMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmGetPackageRules.t.Fatal("No results are set for the OrderRepositoryMock.GetPackageRules")
                }</span>
                <span class="cov4" title="5">return (*mm_results).pa1, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmGetPackageRules.funcGetPackageRules != nil </span><span class="cov0" title="0">{
                return mmGetPackageRules.funcGetPackageRules(ctx, code)
        }</span>
        <span class="cov0" title="0">mmGetPackageRules.t.Fatalf("Unexpected call to OrderRepositoryMock.GetPackageRules. %v %v", ctx, code)
        return</span>
}

// GetPackageRulesAfterCounter returns a count of finished OrderRepositoryMock.GetPackageRules invocations
func (mmGetPackageRules *OrderRepositoryMock) GetPackageRulesAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetPackageRules.afterGetPackageRulesCounter)
}</span>

// GetPackageRulesBeforeCounter returns a count of OrderRepositoryMock.GetPackageRules invocations
func (mmGetPackageRules *OrderRepositoryMock) GetPackageRulesBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetPackageRules.beforeGetPackageRulesCounter)
}</span>

// Calls returns a list of arguments used in each call to OrderRepositoryMock.GetPackageRules.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPackageRules *mOrderRepositoryMockGetPackageRules) Calls() []*OrderRepositoryMockGetPackageRulesParams <span class="cov0" title="0">{
        mmGetPackageRules.mutex.RLock()

        argCopy := make([]*OrderRepositoryMockGetPackageRulesParams, len(mmGetPackageRules.callArgs))
        copy(argCopy, mmGetPackageRules.callArgs)

        mmGetPackageRules.mutex.RUnlock()

        return argCopy
}</span>

// MinimockGetPackageRulesDone returns true if the count of the GetPackageRules invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockGetPackageRulesDone() bool <span class="cov8" title="33">{
        if m.GetPackageRulesMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="33">for _, e := range m.GetPackageRulesMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="33">return m.GetPackageRulesMock.invocationsDone()</span>
}

// MinimockGetPackageRulesInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockGetPackageRulesInspect() <span class="cov0" title="0">{
        for _, e := range m.GetPackageRulesMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrderRepositoryMock.GetPackageRules at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterGetPackageRulesCounter := mm_atomic.LoadUint64(&amp;m.afterGetPackageRulesCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.GetPackageRulesMock.defaultExpectation != nil &amp;&amp; afterGetPackageRulesCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.GetPackageRulesMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrderRepositoryMock.GetPackageRules at\n%s", m.GetPackageRulesMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to OrderRepositoryMock.GetPackageRules at\n%s with params: %#v", m.GetPackageRulesMock.defaultExpectation.expectationOrigins.origin, *m.GetPackageRulesMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcGetPackageRules != nil &amp;&amp; afterGetPackageRulesCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to OrderRepositoryMock.GetPackageRules at\n%s", m.funcGetPackageRulesOrigin)
        }</span>

        <span class="cov0" title="0">if !m.GetPackageRulesMock.invocationsDone() &amp;&amp; afterGetPackageRulesCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to OrderRepositoryMock.GetPackageRules at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.GetPackageRulesMock.expectedInvocations), m.GetPackageRulesMock.expectedInvocationsOrigin, afterGetPackageRulesCounter)
        }</span>
}

type mOrderRepositoryMockGetReturnedOrders struct {
        optional           bool
        mock               *OrderRepositoryMock
        defaultExpectation *OrderRepositoryMockGetReturnedOrdersExpectation
        expectations       []*OrderRepositoryMockGetReturnedOrdersExpectation

        callArgs []*OrderRepositoryMockGetReturnedOrdersParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// OrderRepositoryMockGetReturnedOrdersExpectation specifies expectation struct of the OrderRepository.GetReturnedOrders
type OrderRepositoryMockGetReturnedOrdersExpectation struct {
        mock               *OrderRepositoryMock
        params             *OrderRepositoryMockGetReturnedOrdersParams
        paramPtrs          *OrderRepositoryMockGetReturnedOrdersParamPtrs
        expectationOrigins OrderRepositoryMockGetReturnedOrdersExpectationOrigins
        results            *OrderRepositoryMockGetReturnedOrdersResults
        returnOrigin       string
        Counter            uint64
}

// OrderRepositoryMockGetReturnedOrdersParams contains parameters of the OrderRepository.GetReturnedOrders
type OrderRepositoryMockGetReturnedOrdersParams struct {
        ctx context.Context
}

// OrderRepositoryMockGetReturnedOrdersParamPtrs contains pointers to parameters of the OrderRepository.GetReturnedOrders
type OrderRepositoryMockGetReturnedOrdersParamPtrs struct {
        ctx *context.Context
}

// OrderRepositoryMockGetReturnedOrdersResults contains results of the OrderRepository.GetReturnedOrders
type OrderRepositoryMockGetReturnedOrdersResults struct {
        oa1 []domain.Order
        err error
}

// OrderRepositoryMockGetReturnedOrdersOrigins contains origins of expectations of the OrderRepository.GetReturnedOrders
type OrderRepositoryMockGetReturnedOrdersExpectationOrigins struct {
        origin    string
        originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetReturnedOrders *mOrderRepositoryMockGetReturnedOrders) Optional() *mOrderRepositoryMockGetReturnedOrders <span class="cov0" title="0">{
        mmGetReturnedOrders.optional = true
        return mmGetReturnedOrders
}</span>

// Expect sets up expected params for OrderRepository.GetReturnedOrders
func (mmGetReturnedOrders *mOrderRepositoryMockGetReturnedOrders) Expect(ctx context.Context) *mOrderRepositoryMockGetReturnedOrders <span class="cov1" title="1">{
        if mmGetReturnedOrders.mock.funcGetReturnedOrders != nil </span><span class="cov0" title="0">{
                mmGetReturnedOrders.mock.t.Fatalf("OrderRepositoryMock.GetReturnedOrders mock is already set by Set")
        }</span>

        <span class="cov1" title="1">if mmGetReturnedOrders.defaultExpectation == nil </span><span class="cov1" title="1">{
                mmGetReturnedOrders.defaultExpectation = &amp;OrderRepositoryMockGetReturnedOrdersExpectation{}
        }</span>

        <span class="cov1" title="1">if mmGetReturnedOrders.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmGetReturnedOrders.mock.t.Fatalf("OrderRepositoryMock.GetReturnedOrders mock is already set by ExpectParams functions")
        }</span>

        <span class="cov1" title="1">mmGetReturnedOrders.defaultExpectation.params = &amp;OrderRepositoryMockGetReturnedOrdersParams{ctx}
        mmGetReturnedOrders.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmGetReturnedOrders.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmGetReturnedOrders.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmGetReturnedOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetReturnedOrders.defaultExpectation.params)
                }</span>
        }

        <span class="cov1" title="1">return mmGetReturnedOrders</span>
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepository.GetReturnedOrders
func (mmGetReturnedOrders *mOrderRepositoryMockGetReturnedOrders) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockGetReturnedOrders <span class="cov0" title="0">{
        if mmGetReturnedOrders.mock.funcGetReturnedOrders != nil </span><span class="cov0" title="0">{
                mmGetReturnedOrders.mock.t.Fatalf("OrderRepositoryMock.GetReturnedOrders mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetReturnedOrders.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetReturnedOrders.defaultExpectation = &amp;OrderRepositoryMockGetReturnedOrdersExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetReturnedOrders.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGetReturnedOrders.mock.t.Fatalf("OrderRepositoryMock.GetReturnedOrders mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGetReturnedOrders.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGetReturnedOrders.defaultExpectation.paramPtrs = &amp;OrderRepositoryMockGetReturnedOrdersParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGetReturnedOrders.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmGetReturnedOrders.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmGetReturnedOrders</span>
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.GetReturnedOrders
func (mmGetReturnedOrders *mOrderRepositoryMockGetReturnedOrders) Inspect(f func(ctx context.Context)) *mOrderRepositoryMockGetReturnedOrders <span class="cov0" title="0">{
        if mmGetReturnedOrders.mock.inspectFuncGetReturnedOrders != nil </span><span class="cov0" title="0">{
                mmGetReturnedOrders.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.GetReturnedOrders")
        }</span>

        <span class="cov0" title="0">mmGetReturnedOrders.mock.inspectFuncGetReturnedOrders = f

        return mmGetReturnedOrders</span>
}

// Return sets up results that will be returned by OrderRepository.GetReturnedOrders
func (mmGetReturnedOrders *mOrderRepositoryMockGetReturnedOrders) Return(oa1 []domain.Order, err error) *OrderRepositoryMock <span class="cov1" title="1">{
        if mmGetReturnedOrders.mock.funcGetReturnedOrders != nil </span><span class="cov0" title="0">{
                mmGetReturnedOrders.mock.t.Fatalf("OrderRepositoryMock.GetReturnedOrders mock is already set by Set")
        }</span>

        <span class="cov1" title="1">if mmGetReturnedOrders.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetReturnedOrders.defaultExpectation = &amp;OrderRepositoryMockGetReturnedOrdersExpectation{mock: mmGetReturnedOrders.mock}
        }</span>
        <span class="cov1" title="1">mmGetReturnedOrders.defaultExpectation.results = &amp;OrderRepositoryMockGetReturnedOrdersResults{oa1, err}
        mmGetReturnedOrders.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmGetReturnedOrders.mock</span>
}

// Set uses given function f to mock the OrderRepository.GetReturnedOrders method
func (mmGetReturnedOrders *mOrderRepositoryMockGetReturnedOrders) Set(f func(ctx context.Context) (oa1 []domain.Order, err error)) *OrderRepositoryMock <span class="cov0" title="0">{
        if mmGetReturnedOrders.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmGetReturnedOrders.mock.t.Fatalf("Default expectation is already set for the OrderRepository.GetReturnedOrders method")
        }</span>

        <span class="cov0" title="0">if len(mmGetReturnedOrders.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmGetReturnedOrders.mock.t.Fatalf("Some expectations are already set for the OrderRepository.GetReturnedOrders method")
        }</span>

        <span class="cov0" title="0">mmGetReturnedOrders.mock.funcGetReturnedOrders = f
        mmGetReturnedOrders.mock.funcGetReturnedOrdersOrigin = minimock.CallerInfo(1)
        return mmGetReturnedOrders.mock</span>
}

// When sets expectation for the OrderRepository.GetReturnedOrders which will trigger the result defined by the following
// Then helper
func (mmGetReturnedOrders *mOrderRepositoryMockGetReturnedOrders) When(ctx context.Context) *OrderRepositoryMockGetReturnedOrdersExpectation <span class="cov0" title="0">{
        if mmGetReturnedOrders.mock.funcGetReturnedOrders != nil </span><span class="cov0" title="0">{
                mmGetReturnedOrders.mock.t.Fatalf("OrderRepositoryMock.GetReturnedOrders mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;OrderRepositoryMockGetReturnedOrdersExpectation{
                mock:               mmGetReturnedOrders.mock,
                params:             &amp;OrderRepositoryMockGetReturnedOrdersParams{ctx},
                expectationOrigins: OrderRepositoryMockGetReturnedOrdersExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmGetReturnedOrders.expectations = append(mmGetReturnedOrders.expectations, expectation)
        return expectation</span>
}

// Then sets up OrderRepository.GetReturnedOrders return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockGetReturnedOrdersExpectation) Then(oa1 []domain.Order, err error) *OrderRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;OrderRepositoryMockGetReturnedOrdersResults{oa1, err}
        return e.mock
}</span>

// Times sets number of times OrderRepository.GetReturnedOrders should be invoked
func (mmGetReturnedOrders *mOrderRepositoryMockGetReturnedOrders) Times(n uint64) *mOrderRepositoryMockGetReturnedOrders <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmGetReturnedOrders.mock.t.Fatalf("Times of OrderRepositoryMock.GetReturnedOrders mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmGetReturnedOrders.expectedInvocations, n)
        mmGetReturnedOrders.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmGetReturnedOrders</span>
}

func (mmGetReturnedOrders *mOrderRepositoryMockGetReturnedOrders) invocationsDone() bool <span class="cov8" title="33">{
        if len(mmGetReturnedOrders.expectations) == 0 &amp;&amp; mmGetReturnedOrders.defaultExpectation == nil &amp;&amp; mmGetReturnedOrders.mock.funcGetReturnedOrders == nil </span><span class="cov8" title="32">{
                return true
        }</span>

        <span class="cov1" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmGetReturnedOrders.mock.afterGetReturnedOrdersCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmGetReturnedOrders.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// GetReturnedOrders implements mm_app.OrderRepository
func (mmGetReturnedOrders *OrderRepositoryMock) GetReturnedOrders(ctx context.Context) (oa1 []domain.Order, err error) <span class="cov1" title="1">{
        mm_atomic.AddUint64(&amp;mmGetReturnedOrders.beforeGetReturnedOrdersCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmGetReturnedOrders.afterGetReturnedOrdersCounter, 1)

        mmGetReturnedOrders.t.Helper()

        if mmGetReturnedOrders.inspectFuncGetReturnedOrders != nil </span><span class="cov0" title="0">{
                mmGetReturnedOrders.inspectFuncGetReturnedOrders(ctx)
        }</span>

        <span class="cov1" title="1">mm_params := OrderRepositoryMockGetReturnedOrdersParams{ctx}

        // Record call args
        mmGetReturnedOrders.GetReturnedOrdersMock.mutex.Lock()
        mmGetReturnedOrders.GetReturnedOrdersMock.callArgs = append(mmGetReturnedOrders.GetReturnedOrdersMock.callArgs, &amp;mm_params)
        mmGetReturnedOrders.GetReturnedOrdersMock.mutex.Unlock()

        for _, e := range mmGetReturnedOrders.GetReturnedOrdersMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.oa1, e.results.err
                }</span>
        }

        <span class="cov1" title="1">if mmGetReturnedOrders.GetReturnedOrdersMock.defaultExpectation != nil </span><span class="cov1" title="1">{
                mm_atomic.AddUint64(&amp;mmGetReturnedOrders.GetReturnedOrdersMock.defaultExpectation.Counter, 1)
                mm_want := mmGetReturnedOrders.GetReturnedOrdersMock.defaultExpectation.params
                mm_want_ptrs := mmGetReturnedOrders.GetReturnedOrdersMock.defaultExpectation.paramPtrs

                mm_got := OrderRepositoryMockGetReturnedOrdersParams{ctx}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmGetReturnedOrders.t.Errorf("OrderRepositoryMock.GetReturnedOrders got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmGetReturnedOrders.GetReturnedOrdersMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                } else<span class="cov1" title="1"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmGetReturnedOrders.t.Errorf("OrderRepositoryMock.GetReturnedOrders got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmGetReturnedOrders.GetReturnedOrdersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov1" title="1">mm_results := mmGetReturnedOrders.GetReturnedOrdersMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmGetReturnedOrders.t.Fatal("No results are set for the OrderRepositoryMock.GetReturnedOrders")
                }</span>
                <span class="cov1" title="1">return (*mm_results).oa1, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmGetReturnedOrders.funcGetReturnedOrders != nil </span><span class="cov0" title="0">{
                return mmGetReturnedOrders.funcGetReturnedOrders(ctx)
        }</span>
        <span class="cov0" title="0">mmGetReturnedOrders.t.Fatalf("Unexpected call to OrderRepositoryMock.GetReturnedOrders. %v", ctx)
        return</span>
}

// GetReturnedOrdersAfterCounter returns a count of finished OrderRepositoryMock.GetReturnedOrders invocations
func (mmGetReturnedOrders *OrderRepositoryMock) GetReturnedOrdersAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetReturnedOrders.afterGetReturnedOrdersCounter)
}</span>

// GetReturnedOrdersBeforeCounter returns a count of OrderRepositoryMock.GetReturnedOrders invocations
func (mmGetReturnedOrders *OrderRepositoryMock) GetReturnedOrdersBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetReturnedOrders.beforeGetReturnedOrdersCounter)
}</span>

// Calls returns a list of arguments used in each call to OrderRepositoryMock.GetReturnedOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetReturnedOrders *mOrderRepositoryMockGetReturnedOrders) Calls() []*OrderRepositoryMockGetReturnedOrdersParams <span class="cov0" title="0">{
        mmGetReturnedOrders.mutex.RLock()

        argCopy := make([]*OrderRepositoryMockGetReturnedOrdersParams, len(mmGetReturnedOrders.callArgs))
        copy(argCopy, mmGetReturnedOrders.callArgs)

        mmGetReturnedOrders.mutex.RUnlock()

        return argCopy
}</span>

// MinimockGetReturnedOrdersDone returns true if the count of the GetReturnedOrders invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockGetReturnedOrdersDone() bool <span class="cov8" title="33">{
        if m.GetReturnedOrdersMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="33">for _, e := range m.GetReturnedOrdersMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="33">return m.GetReturnedOrdersMock.invocationsDone()</span>
}

// MinimockGetReturnedOrdersInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockGetReturnedOrdersInspect() <span class="cov0" title="0">{
        for _, e := range m.GetReturnedOrdersMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrderRepositoryMock.GetReturnedOrders at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterGetReturnedOrdersCounter := mm_atomic.LoadUint64(&amp;m.afterGetReturnedOrdersCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.GetReturnedOrdersMock.defaultExpectation != nil &amp;&amp; afterGetReturnedOrdersCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.GetReturnedOrdersMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrderRepositoryMock.GetReturnedOrders at\n%s", m.GetReturnedOrdersMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to OrderRepositoryMock.GetReturnedOrders at\n%s with params: %#v", m.GetReturnedOrdersMock.defaultExpectation.expectationOrigins.origin, *m.GetReturnedOrdersMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcGetReturnedOrders != nil &amp;&amp; afterGetReturnedOrdersCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to OrderRepositoryMock.GetReturnedOrders at\n%s", m.funcGetReturnedOrdersOrigin)
        }</span>

        <span class="cov0" title="0">if !m.GetReturnedOrdersMock.invocationsDone() &amp;&amp; afterGetReturnedOrdersCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to OrderRepositoryMock.GetReturnedOrders at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.GetReturnedOrdersMock.expectedInvocations), m.GetReturnedOrdersMock.expectedInvocationsOrigin, afterGetReturnedOrdersCounter)
        }</span>
}

type mOrderRepositoryMockSave struct {
        optional           bool
        mock               *OrderRepositoryMock
        defaultExpectation *OrderRepositoryMockSaveExpectation
        expectations       []*OrderRepositoryMockSaveExpectation

        callArgs []*OrderRepositoryMockSaveParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// OrderRepositoryMockSaveExpectation specifies expectation struct of the OrderRepository.Save
type OrderRepositoryMockSaveExpectation struct {
        mock               *OrderRepositoryMock
        params             *OrderRepositoryMockSaveParams
        paramPtrs          *OrderRepositoryMockSaveParamPtrs
        expectationOrigins OrderRepositoryMockSaveExpectationOrigins
        results            *OrderRepositoryMockSaveResults
        returnOrigin       string
        Counter            uint64
}

// OrderRepositoryMockSaveParams contains parameters of the OrderRepository.Save
type OrderRepositoryMockSaveParams struct {
        ctx   context.Context
        order domain.Order
}

// OrderRepositoryMockSaveParamPtrs contains pointers to parameters of the OrderRepository.Save
type OrderRepositoryMockSaveParamPtrs struct {
        ctx   *context.Context
        order *domain.Order
}

// OrderRepositoryMockSaveResults contains results of the OrderRepository.Save
type OrderRepositoryMockSaveResults struct {
        err error
}

// OrderRepositoryMockSaveOrigins contains origins of expectations of the OrderRepository.Save
type OrderRepositoryMockSaveExpectationOrigins struct {
        origin      string
        originCtx   string
        originOrder string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSave *mOrderRepositoryMockSave) Optional() *mOrderRepositoryMockSave <span class="cov0" title="0">{
        mmSave.optional = true
        return mmSave
}</span>

// Expect sets up expected params for OrderRepository.Save
func (mmSave *mOrderRepositoryMockSave) Expect(ctx context.Context, order domain.Order) *mOrderRepositoryMockSave <span class="cov3" title="4">{
        if mmSave.mock.funcSave != nil </span><span class="cov0" title="0">{
                mmSave.mock.t.Fatalf("OrderRepositoryMock.Save mock is already set by Set")
        }</span>

        <span class="cov3" title="4">if mmSave.defaultExpectation == nil </span><span class="cov3" title="4">{
                mmSave.defaultExpectation = &amp;OrderRepositoryMockSaveExpectation{}
        }</span>

        <span class="cov3" title="4">if mmSave.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmSave.mock.t.Fatalf("OrderRepositoryMock.Save mock is already set by ExpectParams functions")
        }</span>

        <span class="cov3" title="4">mmSave.defaultExpectation.params = &amp;OrderRepositoryMockSaveParams{ctx, order}
        mmSave.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmSave.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmSave.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmSave.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSave.defaultExpectation.params)
                }</span>
        }

        <span class="cov3" title="4">return mmSave</span>
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepository.Save
func (mmSave *mOrderRepositoryMockSave) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockSave <span class="cov0" title="0">{
        if mmSave.mock.funcSave != nil </span><span class="cov0" title="0">{
                mmSave.mock.t.Fatalf("OrderRepositoryMock.Save mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSave.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSave.defaultExpectation = &amp;OrderRepositoryMockSaveExpectation{}
        }</span>

        <span class="cov0" title="0">if mmSave.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmSave.mock.t.Fatalf("OrderRepositoryMock.Save mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmSave.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmSave.defaultExpectation.paramPtrs = &amp;OrderRepositoryMockSaveParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmSave.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmSave.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmSave</span>
}

// ExpectOrderParam2 sets up expected param order for OrderRepository.Save
func (mmSave *mOrderRepositoryMockSave) ExpectOrderParam2(order domain.Order) *mOrderRepositoryMockSave <span class="cov0" title="0">{
        if mmSave.mock.funcSave != nil </span><span class="cov0" title="0">{
                mmSave.mock.t.Fatalf("OrderRepositoryMock.Save mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSave.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSave.defaultExpectation = &amp;OrderRepositoryMockSaveExpectation{}
        }</span>

        <span class="cov0" title="0">if mmSave.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmSave.mock.t.Fatalf("OrderRepositoryMock.Save mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmSave.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmSave.defaultExpectation.paramPtrs = &amp;OrderRepositoryMockSaveParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmSave.defaultExpectation.paramPtrs.order = &amp;order
        mmSave.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

        return mmSave</span>
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.Save
func (mmSave *mOrderRepositoryMockSave) Inspect(f func(ctx context.Context, order domain.Order)) *mOrderRepositoryMockSave <span class="cov0" title="0">{
        if mmSave.mock.inspectFuncSave != nil </span><span class="cov0" title="0">{
                mmSave.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.Save")
        }</span>

        <span class="cov0" title="0">mmSave.mock.inspectFuncSave = f

        return mmSave</span>
}

// Return sets up results that will be returned by OrderRepository.Save
func (mmSave *mOrderRepositoryMockSave) Return(err error) *OrderRepositoryMock <span class="cov3" title="4">{
        if mmSave.mock.funcSave != nil </span><span class="cov0" title="0">{
                mmSave.mock.t.Fatalf("OrderRepositoryMock.Save mock is already set by Set")
        }</span>

        <span class="cov3" title="4">if mmSave.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSave.defaultExpectation = &amp;OrderRepositoryMockSaveExpectation{mock: mmSave.mock}
        }</span>
        <span class="cov3" title="4">mmSave.defaultExpectation.results = &amp;OrderRepositoryMockSaveResults{err}
        mmSave.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmSave.mock</span>
}

// Set uses given function f to mock the OrderRepository.Save method
func (mmSave *mOrderRepositoryMockSave) Set(f func(ctx context.Context, order domain.Order) (err error)) *OrderRepositoryMock <span class="cov0" title="0">{
        if mmSave.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmSave.mock.t.Fatalf("Default expectation is already set for the OrderRepository.Save method")
        }</span>

        <span class="cov0" title="0">if len(mmSave.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmSave.mock.t.Fatalf("Some expectations are already set for the OrderRepository.Save method")
        }</span>

        <span class="cov0" title="0">mmSave.mock.funcSave = f
        mmSave.mock.funcSaveOrigin = minimock.CallerInfo(1)
        return mmSave.mock</span>
}

// When sets expectation for the OrderRepository.Save which will trigger the result defined by the following
// Then helper
func (mmSave *mOrderRepositoryMockSave) When(ctx context.Context, order domain.Order) *OrderRepositoryMockSaveExpectation <span class="cov0" title="0">{
        if mmSave.mock.funcSave != nil </span><span class="cov0" title="0">{
                mmSave.mock.t.Fatalf("OrderRepositoryMock.Save mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;OrderRepositoryMockSaveExpectation{
                mock:               mmSave.mock,
                params:             &amp;OrderRepositoryMockSaveParams{ctx, order},
                expectationOrigins: OrderRepositoryMockSaveExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmSave.expectations = append(mmSave.expectations, expectation)
        return expectation</span>
}

// Then sets up OrderRepository.Save return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockSaveExpectation) Then(err error) *OrderRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;OrderRepositoryMockSaveResults{err}
        return e.mock
}</span>

// Times sets number of times OrderRepository.Save should be invoked
func (mmSave *mOrderRepositoryMockSave) Times(n uint64) *mOrderRepositoryMockSave <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmSave.mock.t.Fatalf("Times of OrderRepositoryMock.Save mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmSave.expectedInvocations, n)
        mmSave.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmSave</span>
}

func (mmSave *mOrderRepositoryMockSave) invocationsDone() bool <span class="cov8" title="33">{
        if len(mmSave.expectations) == 0 &amp;&amp; mmSave.defaultExpectation == nil &amp;&amp; mmSave.mock.funcSave == nil </span><span class="cov8" title="29">{
                return true
        }</span>

        <span class="cov3" title="4">totalInvocations := mm_atomic.LoadUint64(&amp;mmSave.mock.afterSaveCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmSave.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Save implements mm_app.OrderRepository
func (mmSave *OrderRepositoryMock) Save(ctx context.Context, order domain.Order) (err error) <span class="cov3" title="4">{
        mm_atomic.AddUint64(&amp;mmSave.beforeSaveCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmSave.afterSaveCounter, 1)

        mmSave.t.Helper()

        if mmSave.inspectFuncSave != nil </span><span class="cov0" title="0">{
                mmSave.inspectFuncSave(ctx, order)
        }</span>

        <span class="cov3" title="4">mm_params := OrderRepositoryMockSaveParams{ctx, order}

        // Record call args
        mmSave.SaveMock.mutex.Lock()
        mmSave.SaveMock.callArgs = append(mmSave.SaveMock.callArgs, &amp;mm_params)
        mmSave.SaveMock.mutex.Unlock()

        for _, e := range mmSave.SaveMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov3" title="4">if mmSave.SaveMock.defaultExpectation != nil </span><span class="cov3" title="4">{
                mm_atomic.AddUint64(&amp;mmSave.SaveMock.defaultExpectation.Counter, 1)
                mm_want := mmSave.SaveMock.defaultExpectation.params
                mm_want_ptrs := mmSave.SaveMock.defaultExpectation.paramPtrs

                mm_got := OrderRepositoryMockSaveParams{ctx, order}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmSave.t.Errorf("OrderRepositoryMock.Save got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmSave.SaveMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.order != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.order, mm_got.order) </span><span class="cov0" title="0">{
                                mmSave.t.Errorf("OrderRepositoryMock.Save got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmSave.SaveMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
                        }</span>

                } else<span class="cov3" title="4"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmSave.t.Errorf("OrderRepositoryMock.Save got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmSave.SaveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov3" title="4">mm_results := mmSave.SaveMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmSave.t.Fatal("No results are set for the OrderRepositoryMock.Save")
                }</span>
                <span class="cov3" title="4">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmSave.funcSave != nil </span><span class="cov0" title="0">{
                return mmSave.funcSave(ctx, order)
        }</span>
        <span class="cov0" title="0">mmSave.t.Fatalf("Unexpected call to OrderRepositoryMock.Save. %v %v", ctx, order)
        return</span>
}

// SaveAfterCounter returns a count of finished OrderRepositoryMock.Save invocations
func (mmSave *OrderRepositoryMock) SaveAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmSave.afterSaveCounter)
}</span>

// SaveBeforeCounter returns a count of OrderRepositoryMock.Save invocations
func (mmSave *OrderRepositoryMock) SaveBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmSave.beforeSaveCounter)
}</span>

// Calls returns a list of arguments used in each call to OrderRepositoryMock.Save.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSave *mOrderRepositoryMockSave) Calls() []*OrderRepositoryMockSaveParams <span class="cov0" title="0">{
        mmSave.mutex.RLock()

        argCopy := make([]*OrderRepositoryMockSaveParams, len(mmSave.callArgs))
        copy(argCopy, mmSave.callArgs)

        mmSave.mutex.RUnlock()

        return argCopy
}</span>

// MinimockSaveDone returns true if the count of the Save invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockSaveDone() bool <span class="cov8" title="33">{
        if m.SaveMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="33">for _, e := range m.SaveMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="33">return m.SaveMock.invocationsDone()</span>
}

// MinimockSaveInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockSaveInspect() <span class="cov0" title="0">{
        for _, e := range m.SaveMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrderRepositoryMock.Save at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterSaveCounter := mm_atomic.LoadUint64(&amp;m.afterSaveCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.SaveMock.defaultExpectation != nil &amp;&amp; afterSaveCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.SaveMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrderRepositoryMock.Save at\n%s", m.SaveMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to OrderRepositoryMock.Save at\n%s with params: %#v", m.SaveMock.defaultExpectation.expectationOrigins.origin, *m.SaveMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcSave != nil &amp;&amp; afterSaveCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to OrderRepositoryMock.Save at\n%s", m.funcSaveOrigin)
        }</span>

        <span class="cov0" title="0">if !m.SaveMock.invocationsDone() &amp;&amp; afterSaveCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to OrderRepositoryMock.Save at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.SaveMock.expectedInvocations), m.SaveMock.expectedInvocationsOrigin, afterSaveCounter)
        }</span>
}

type mOrderRepositoryMockSaveHistory struct {
        optional           bool
        mock               *OrderRepositoryMock
        defaultExpectation *OrderRepositoryMockSaveHistoryExpectation
        expectations       []*OrderRepositoryMockSaveHistoryExpectation

        callArgs []*OrderRepositoryMockSaveHistoryParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// OrderRepositoryMockSaveHistoryExpectation specifies expectation struct of the OrderRepository.SaveHistory
type OrderRepositoryMockSaveHistoryExpectation struct {
        mock               *OrderRepositoryMock
        params             *OrderRepositoryMockSaveHistoryParams
        paramPtrs          *OrderRepositoryMockSaveHistoryParamPtrs
        expectationOrigins OrderRepositoryMockSaveHistoryExpectationOrigins
        results            *OrderRepositoryMockSaveHistoryResults
        returnOrigin       string
        Counter            uint64
}

// OrderRepositoryMockSaveHistoryParams contains parameters of the OrderRepository.SaveHistory
type OrderRepositoryMockSaveHistoryParams struct {
        ctx     context.Context
        history domain.OrderHistory
}

// OrderRepositoryMockSaveHistoryParamPtrs contains pointers to parameters of the OrderRepository.SaveHistory
type OrderRepositoryMockSaveHistoryParamPtrs struct {
        ctx     *context.Context
        history *domain.OrderHistory
}

// OrderRepositoryMockSaveHistoryResults contains results of the OrderRepository.SaveHistory
type OrderRepositoryMockSaveHistoryResults struct {
        err error
}

// OrderRepositoryMockSaveHistoryOrigins contains origins of expectations of the OrderRepository.SaveHistory
type OrderRepositoryMockSaveHistoryExpectationOrigins struct {
        origin        string
        originCtx     string
        originHistory string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSaveHistory *mOrderRepositoryMockSaveHistory) Optional() *mOrderRepositoryMockSaveHistory <span class="cov0" title="0">{
        mmSaveHistory.optional = true
        return mmSaveHistory
}</span>

// Expect sets up expected params for OrderRepository.SaveHistory
func (mmSaveHistory *mOrderRepositoryMockSaveHistory) Expect(ctx context.Context, history domain.OrderHistory) *mOrderRepositoryMockSaveHistory <span class="cov5" title="10">{
        if mmSaveHistory.mock.funcSaveHistory != nil </span><span class="cov0" title="0">{
                mmSaveHistory.mock.t.Fatalf("OrderRepositoryMock.SaveHistory mock is already set by Set")
        }</span>

        <span class="cov5" title="10">if mmSaveHistory.defaultExpectation == nil </span><span class="cov5" title="10">{
                mmSaveHistory.defaultExpectation = &amp;OrderRepositoryMockSaveHistoryExpectation{}
        }</span>

        <span class="cov5" title="10">if mmSaveHistory.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmSaveHistory.mock.t.Fatalf("OrderRepositoryMock.SaveHistory mock is already set by ExpectParams functions")
        }</span>

        <span class="cov5" title="10">mmSaveHistory.defaultExpectation.params = &amp;OrderRepositoryMockSaveHistoryParams{ctx, history}
        mmSaveHistory.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmSaveHistory.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmSaveHistory.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmSaveHistory.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveHistory.defaultExpectation.params)
                }</span>
        }

        <span class="cov5" title="10">return mmSaveHistory</span>
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepository.SaveHistory
func (mmSaveHistory *mOrderRepositoryMockSaveHistory) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockSaveHistory <span class="cov0" title="0">{
        if mmSaveHistory.mock.funcSaveHistory != nil </span><span class="cov0" title="0">{
                mmSaveHistory.mock.t.Fatalf("OrderRepositoryMock.SaveHistory mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSaveHistory.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSaveHistory.defaultExpectation = &amp;OrderRepositoryMockSaveHistoryExpectation{}
        }</span>

        <span class="cov0" title="0">if mmSaveHistory.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmSaveHistory.mock.t.Fatalf("OrderRepositoryMock.SaveHistory mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmSaveHistory.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmSaveHistory.defaultExpectation.paramPtrs = &amp;OrderRepositoryMockSaveHistoryParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmSaveHistory.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmSaveHistory.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmSaveHistory</span>
}

// ExpectHistoryParam2 sets up expected param history for OrderRepository.SaveHistory
func (mmSaveHistory *mOrderRepositoryMockSaveHistory) ExpectHistoryParam2(history domain.OrderHistory) *mOrderRepositoryMockSaveHistory <span class="cov0" title="0">{
        if mmSaveHistory.mock.funcSaveHistory != nil </span><span class="cov0" title="0">{
                mmSaveHistory.mock.t.Fatalf("OrderRepositoryMock.SaveHistory mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSaveHistory.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSaveHistory.defaultExpectation = &amp;OrderRepositoryMockSaveHistoryExpectation{}
        }</span>

        <span class="cov0" title="0">if mmSaveHistory.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmSaveHistory.mock.t.Fatalf("OrderRepositoryMock.SaveHistory mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmSaveHistory.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmSaveHistory.defaultExpectation.paramPtrs = &amp;OrderRepositoryMockSaveHistoryParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmSaveHistory.defaultExpectation.paramPtrs.history = &amp;history
        mmSaveHistory.defaultExpectation.expectationOrigins.originHistory = minimock.CallerInfo(1)

        return mmSaveHistory</span>
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.SaveHistory
func (mmSaveHistory *mOrderRepositoryMockSaveHistory) Inspect(f func(ctx context.Context, history domain.OrderHistory)) *mOrderRepositoryMockSaveHistory <span class="cov0" title="0">{
        if mmSaveHistory.mock.inspectFuncSaveHistory != nil </span><span class="cov0" title="0">{
                mmSaveHistory.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.SaveHistory")
        }</span>

        <span class="cov0" title="0">mmSaveHistory.mock.inspectFuncSaveHistory = f

        return mmSaveHistory</span>
}

// Return sets up results that will be returned by OrderRepository.SaveHistory
func (mmSaveHistory *mOrderRepositoryMockSaveHistory) Return(err error) *OrderRepositoryMock <span class="cov5" title="10">{
        if mmSaveHistory.mock.funcSaveHistory != nil </span><span class="cov0" title="0">{
                mmSaveHistory.mock.t.Fatalf("OrderRepositoryMock.SaveHistory mock is already set by Set")
        }</span>

        <span class="cov5" title="10">if mmSaveHistory.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSaveHistory.defaultExpectation = &amp;OrderRepositoryMockSaveHistoryExpectation{mock: mmSaveHistory.mock}
        }</span>
        <span class="cov5" title="10">mmSaveHistory.defaultExpectation.results = &amp;OrderRepositoryMockSaveHistoryResults{err}
        mmSaveHistory.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmSaveHistory.mock</span>
}

// Set uses given function f to mock the OrderRepository.SaveHistory method
func (mmSaveHistory *mOrderRepositoryMockSaveHistory) Set(f func(ctx context.Context, history domain.OrderHistory) (err error)) *OrderRepositoryMock <span class="cov1" title="1">{
        if mmSaveHistory.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmSaveHistory.mock.t.Fatalf("Default expectation is already set for the OrderRepository.SaveHistory method")
        }</span>

        <span class="cov1" title="1">if len(mmSaveHistory.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmSaveHistory.mock.t.Fatalf("Some expectations are already set for the OrderRepository.SaveHistory method")
        }</span>

        <span class="cov1" title="1">mmSaveHistory.mock.funcSaveHistory = f
        mmSaveHistory.mock.funcSaveHistoryOrigin = minimock.CallerInfo(1)
        return mmSaveHistory.mock</span>
}

// When sets expectation for the OrderRepository.SaveHistory which will trigger the result defined by the following
// Then helper
func (mmSaveHistory *mOrderRepositoryMockSaveHistory) When(ctx context.Context, history domain.OrderHistory) *OrderRepositoryMockSaveHistoryExpectation <span class="cov0" title="0">{
        if mmSaveHistory.mock.funcSaveHistory != nil </span><span class="cov0" title="0">{
                mmSaveHistory.mock.t.Fatalf("OrderRepositoryMock.SaveHistory mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;OrderRepositoryMockSaveHistoryExpectation{
                mock:               mmSaveHistory.mock,
                params:             &amp;OrderRepositoryMockSaveHistoryParams{ctx, history},
                expectationOrigins: OrderRepositoryMockSaveHistoryExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmSaveHistory.expectations = append(mmSaveHistory.expectations, expectation)
        return expectation</span>
}

// Then sets up OrderRepository.SaveHistory return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockSaveHistoryExpectation) Then(err error) *OrderRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;OrderRepositoryMockSaveHistoryResults{err}
        return e.mock
}</span>

// Times sets number of times OrderRepository.SaveHistory should be invoked
func (mmSaveHistory *mOrderRepositoryMockSaveHistory) Times(n uint64) *mOrderRepositoryMockSaveHistory <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmSaveHistory.mock.t.Fatalf("Times of OrderRepositoryMock.SaveHistory mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmSaveHistory.expectedInvocations, n)
        mmSaveHistory.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmSaveHistory</span>
}

func (mmSaveHistory *mOrderRepositoryMockSaveHistory) invocationsDone() bool <span class="cov8" title="33">{
        if len(mmSaveHistory.expectations) == 0 &amp;&amp; mmSaveHistory.defaultExpectation == nil &amp;&amp; mmSaveHistory.mock.funcSaveHistory == nil </span><span class="cov7" title="22">{
                return true
        }</span>

        <span class="cov6" title="11">totalInvocations := mm_atomic.LoadUint64(&amp;mmSaveHistory.mock.afterSaveHistoryCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmSaveHistory.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// SaveHistory implements mm_app.OrderRepository
func (mmSaveHistory *OrderRepositoryMock) SaveHistory(ctx context.Context, history domain.OrderHistory) (err error) <span class="cov6" title="12">{
        mm_atomic.AddUint64(&amp;mmSaveHistory.beforeSaveHistoryCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmSaveHistory.afterSaveHistoryCounter, 1)

        mmSaveHistory.t.Helper()

        if mmSaveHistory.inspectFuncSaveHistory != nil </span><span class="cov0" title="0">{
                mmSaveHistory.inspectFuncSaveHistory(ctx, history)
        }</span>

        <span class="cov6" title="12">mm_params := OrderRepositoryMockSaveHistoryParams{ctx, history}

        // Record call args
        mmSaveHistory.SaveHistoryMock.mutex.Lock()
        mmSaveHistory.SaveHistoryMock.callArgs = append(mmSaveHistory.SaveHistoryMock.callArgs, &amp;mm_params)
        mmSaveHistory.SaveHistoryMock.mutex.Unlock()

        for _, e := range mmSaveHistory.SaveHistoryMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov6" title="12">if mmSaveHistory.SaveHistoryMock.defaultExpectation != nil </span><span class="cov5" title="10">{
                mm_atomic.AddUint64(&amp;mmSaveHistory.SaveHistoryMock.defaultExpectation.Counter, 1)
                mm_want := mmSaveHistory.SaveHistoryMock.defaultExpectation.params
                mm_want_ptrs := mmSaveHistory.SaveHistoryMock.defaultExpectation.paramPtrs

                mm_got := OrderRepositoryMockSaveHistoryParams{ctx, history}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmSaveHistory.t.Errorf("OrderRepositoryMock.SaveHistory got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmSaveHistory.SaveHistoryMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.history != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.history, mm_got.history) </span><span class="cov0" title="0">{
                                mmSaveHistory.t.Errorf("OrderRepositoryMock.SaveHistory got unexpected parameter history, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmSaveHistory.SaveHistoryMock.defaultExpectation.expectationOrigins.originHistory, *mm_want_ptrs.history, mm_got.history, minimock.Diff(*mm_want_ptrs.history, mm_got.history))
                        }</span>

                } else<span class="cov5" title="10"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmSaveHistory.t.Errorf("OrderRepositoryMock.SaveHistory got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmSaveHistory.SaveHistoryMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov5" title="10">mm_results := mmSaveHistory.SaveHistoryMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmSaveHistory.t.Fatal("No results are set for the OrderRepositoryMock.SaveHistory")
                }</span>
                <span class="cov5" title="10">return (*mm_results).err</span>
        }
        <span class="cov2" title="2">if mmSaveHistory.funcSaveHistory != nil </span><span class="cov2" title="2">{
                return mmSaveHistory.funcSaveHistory(ctx, history)
        }</span>
        <span class="cov0" title="0">mmSaveHistory.t.Fatalf("Unexpected call to OrderRepositoryMock.SaveHistory. %v %v", ctx, history)
        return</span>
}

// SaveHistoryAfterCounter returns a count of finished OrderRepositoryMock.SaveHistory invocations
func (mmSaveHistory *OrderRepositoryMock) SaveHistoryAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmSaveHistory.afterSaveHistoryCounter)
}</span>

// SaveHistoryBeforeCounter returns a count of OrderRepositoryMock.SaveHistory invocations
func (mmSaveHistory *OrderRepositoryMock) SaveHistoryBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmSaveHistory.beforeSaveHistoryCounter)
}</span>

// Calls returns a list of arguments used in each call to OrderRepositoryMock.SaveHistory.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveHistory *mOrderRepositoryMockSaveHistory) Calls() []*OrderRepositoryMockSaveHistoryParams <span class="cov0" title="0">{
        mmSaveHistory.mutex.RLock()

        argCopy := make([]*OrderRepositoryMockSaveHistoryParams, len(mmSaveHistory.callArgs))
        copy(argCopy, mmSaveHistory.callArgs)

        mmSaveHistory.mutex.RUnlock()

        return argCopy
}</span>

// MinimockSaveHistoryDone returns true if the count of the SaveHistory invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockSaveHistoryDone() bool <span class="cov8" title="33">{
        if m.SaveHistoryMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="33">for _, e := range m.SaveHistoryMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="33">return m.SaveHistoryMock.invocationsDone()</span>
}

// MinimockSaveHistoryInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockSaveHistoryInspect() <span class="cov0" title="0">{
        for _, e := range m.SaveHistoryMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrderRepositoryMock.SaveHistory at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterSaveHistoryCounter := mm_atomic.LoadUint64(&amp;m.afterSaveHistoryCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.SaveHistoryMock.defaultExpectation != nil &amp;&amp; afterSaveHistoryCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.SaveHistoryMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrderRepositoryMock.SaveHistory at\n%s", m.SaveHistoryMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to OrderRepositoryMock.SaveHistory at\n%s with params: %#v", m.SaveHistoryMock.defaultExpectation.expectationOrigins.origin, *m.SaveHistoryMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcSaveHistory != nil &amp;&amp; afterSaveHistoryCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to OrderRepositoryMock.SaveHistory at\n%s", m.funcSaveHistoryOrigin)
        }</span>

        <span class="cov0" title="0">if !m.SaveHistoryMock.invocationsDone() &amp;&amp; afterSaveHistoryCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to OrderRepositoryMock.SaveHistory at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.SaveHistoryMock.expectedInvocations), m.SaveHistoryMock.expectedInvocationsOrigin, afterSaveHistoryCounter)
        }</span>
}

type mOrderRepositoryMockUpdate struct {
        optional           bool
        mock               *OrderRepositoryMock
        defaultExpectation *OrderRepositoryMockUpdateExpectation
        expectations       []*OrderRepositoryMockUpdateExpectation

        callArgs []*OrderRepositoryMockUpdateParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// OrderRepositoryMockUpdateExpectation specifies expectation struct of the OrderRepository.Update
type OrderRepositoryMockUpdateExpectation struct {
        mock               *OrderRepositoryMock
        params             *OrderRepositoryMockUpdateParams
        paramPtrs          *OrderRepositoryMockUpdateParamPtrs
        expectationOrigins OrderRepositoryMockUpdateExpectationOrigins
        results            *OrderRepositoryMockUpdateResults
        returnOrigin       string
        Counter            uint64
}

// OrderRepositoryMockUpdateParams contains parameters of the OrderRepository.Update
type OrderRepositoryMockUpdateParams struct {
        ctx   context.Context
        order domain.Order
}

// OrderRepositoryMockUpdateParamPtrs contains pointers to parameters of the OrderRepository.Update
type OrderRepositoryMockUpdateParamPtrs struct {
        ctx   *context.Context
        order *domain.Order
}

// OrderRepositoryMockUpdateResults contains results of the OrderRepository.Update
type OrderRepositoryMockUpdateResults struct {
        err error
}

// OrderRepositoryMockUpdateOrigins contains origins of expectations of the OrderRepository.Update
type OrderRepositoryMockUpdateExpectationOrigins struct {
        origin      string
        originCtx   string
        originOrder string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mOrderRepositoryMockUpdate) Optional() *mOrderRepositoryMockUpdate <span class="cov0" title="0">{
        mmUpdate.optional = true
        return mmUpdate
}</span>

// Expect sets up expected params for OrderRepository.Update
func (mmUpdate *mOrderRepositoryMockUpdate) Expect(ctx context.Context, order domain.Order) *mOrderRepositoryMockUpdate <span class="cov5" title="9">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("OrderRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov5" title="9">if mmUpdate.defaultExpectation == nil </span><span class="cov5" title="9">{
                mmUpdate.defaultExpectation = &amp;OrderRepositoryMockUpdateExpectation{}
        }</span>

        <span class="cov5" title="9">if mmUpdate.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("OrderRepositoryMock.Update mock is already set by ExpectParams functions")
        }</span>

        <span class="cov5" title="9">mmUpdate.defaultExpectation.params = &amp;OrderRepositoryMockUpdateParams{ctx, order}
        mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmUpdate.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
                }</span>
        }

        <span class="cov5" title="9">return mmUpdate</span>
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepository.Update
func (mmUpdate *mOrderRepositoryMockUpdate) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockUpdate <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("OrderRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation = &amp;OrderRepositoryMockUpdateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("OrderRepositoryMock.Update mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation.paramPtrs = &amp;OrderRepositoryMockUpdateParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmUpdate.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmUpdate</span>
}

// ExpectOrderParam2 sets up expected param order for OrderRepository.Update
func (mmUpdate *mOrderRepositoryMockUpdate) ExpectOrderParam2(order domain.Order) *mOrderRepositoryMockUpdate <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("OrderRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation = &amp;OrderRepositoryMockUpdateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("OrderRepositoryMock.Update mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation.paramPtrs = &amp;OrderRepositoryMockUpdateParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmUpdate.defaultExpectation.paramPtrs.order = &amp;order
        mmUpdate.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

        return mmUpdate</span>
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.Update
func (mmUpdate *mOrderRepositoryMockUpdate) Inspect(f func(ctx context.Context, order domain.Order)) *mOrderRepositoryMockUpdate <span class="cov0" title="0">{
        if mmUpdate.mock.inspectFuncUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.Update")
        }</span>

        <span class="cov0" title="0">mmUpdate.mock.inspectFuncUpdate = f

        return mmUpdate</span>
}

// Return sets up results that will be returned by OrderRepository.Update
func (mmUpdate *mOrderRepositoryMockUpdate) Return(err error) *OrderRepositoryMock <span class="cov5" title="9">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("OrderRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov5" title="9">if mmUpdate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation = &amp;OrderRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
        }</span>
        <span class="cov5" title="9">mmUpdate.defaultExpectation.results = &amp;OrderRepositoryMockUpdateResults{err}
        mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmUpdate.mock</span>
}

// Set uses given function f to mock the OrderRepository.Update method
func (mmUpdate *mOrderRepositoryMockUpdate) Set(f func(ctx context.Context, order domain.Order) (err error)) *OrderRepositoryMock <span class="cov1" title="1">{
        if mmUpdate.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("Default expectation is already set for the OrderRepository.Update method")
        }</span>

        <span class="cov1" title="1">if len(mmUpdate.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("Some expectations are already set for the OrderRepository.Update method")
        }</span>

        <span class="cov1" title="1">mmUpdate.mock.funcUpdate = f
        mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
        return mmUpdate.mock</span>
}

// When sets expectation for the OrderRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mOrderRepositoryMockUpdate) When(ctx context.Context, order domain.Order) *OrderRepositoryMockUpdateExpectation <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("OrderRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;OrderRepositoryMockUpdateExpectation{
                mock:               mmUpdate.mock,
                params:             &amp;OrderRepositoryMockUpdateParams{ctx, order},
                expectationOrigins: OrderRepositoryMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmUpdate.expectations = append(mmUpdate.expectations, expectation)
        return expectation</span>
}

// Then sets up OrderRepository.Update return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockUpdateExpectation) Then(err error) *OrderRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;OrderRepositoryMockUpdateResults{err}
        return e.mock
}</span>

// Times sets number of times OrderRepository.Update should be invoked
func (mmUpdate *mOrderRepositoryMockUpdate) Times(n uint64) *mOrderRepositoryMockUpdate <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("Times of OrderRepositoryMock.Update mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmUpdate.expectedInvocations, n)
        mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmUpdate</span>
}

func (mmUpdate *mOrderRepositoryMockUpdate) invocationsDone() bool <span class="cov8" title="33">{
        if len(mmUpdate.expectations) == 0 &amp;&amp; mmUpdate.defaultExpectation == nil &amp;&amp; mmUpdate.mock.funcUpdate == nil </span><span class="cov7" title="23">{
                return true
        }</span>

        <span class="cov5" title="10">totalInvocations := mm_atomic.LoadUint64(&amp;mmUpdate.mock.afterUpdateCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmUpdate.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Update implements mm_app.OrderRepository
func (mmUpdate *OrderRepositoryMock) Update(ctx context.Context, order domain.Order) (err error) <span class="cov6" title="11">{
        mm_atomic.AddUint64(&amp;mmUpdate.beforeUpdateCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmUpdate.afterUpdateCounter, 1)

        mmUpdate.t.Helper()

        if mmUpdate.inspectFuncUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.inspectFuncUpdate(ctx, order)
        }</span>

        <span class="cov6" title="11">mm_params := OrderRepositoryMockUpdateParams{ctx, order}

        // Record call args
        mmUpdate.UpdateMock.mutex.Lock()
        mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &amp;mm_params)
        mmUpdate.UpdateMock.mutex.Unlock()

        for _, e := range mmUpdate.UpdateMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov6" title="11">if mmUpdate.UpdateMock.defaultExpectation != nil </span><span class="cov5" title="9">{
                mm_atomic.AddUint64(&amp;mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
                mm_want := mmUpdate.UpdateMock.defaultExpectation.params
                mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

                mm_got := OrderRepositoryMockUpdateParams{ctx, order}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmUpdate.t.Errorf("OrderRepositoryMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.order != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.order, mm_got.order) </span><span class="cov0" title="0">{
                                mmUpdate.t.Errorf("OrderRepositoryMock.Update got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
                        }</span>

                } else<span class="cov5" title="9"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmUpdate.t.Errorf("OrderRepositoryMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov5" title="9">mm_results := mmUpdate.UpdateMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmUpdate.t.Fatal("No results are set for the OrderRepositoryMock.Update")
                }</span>
                <span class="cov5" title="9">return (*mm_results).err</span>
        }
        <span class="cov2" title="2">if mmUpdate.funcUpdate != nil </span><span class="cov2" title="2">{
                return mmUpdate.funcUpdate(ctx, order)
        }</span>
        <span class="cov0" title="0">mmUpdate.t.Fatalf("Unexpected call to OrderRepositoryMock.Update. %v %v", ctx, order)
        return</span>
}

// UpdateAfterCounter returns a count of finished OrderRepositoryMock.Update invocations
func (mmUpdate *OrderRepositoryMock) UpdateAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmUpdate.afterUpdateCounter)
}</span>

// UpdateBeforeCounter returns a count of OrderRepositoryMock.Update invocations
func (mmUpdate *OrderRepositoryMock) UpdateBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmUpdate.beforeUpdateCounter)
}</span>

// Calls returns a list of arguments used in each call to OrderRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mOrderRepositoryMockUpdate) Calls() []*OrderRepositoryMockUpdateParams <span class="cov0" title="0">{
        mmUpdate.mutex.RLock()

        argCopy := make([]*OrderRepositoryMockUpdateParams, len(mmUpdate.callArgs))
        copy(argCopy, mmUpdate.callArgs)

        mmUpdate.mutex.RUnlock()

        return argCopy
}</span>

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockUpdateDone() bool <span class="cov8" title="33">{
        if m.UpdateMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="33">for _, e := range m.UpdateMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="33">return m.UpdateMock.invocationsDone()</span>
}

// MinimockUpdateInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockUpdateInspect() <span class="cov0" title="0">{
        for _, e := range m.UpdateMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrderRepositoryMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterUpdateCounter := mm_atomic.LoadUint64(&amp;m.afterUpdateCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.UpdateMock.defaultExpectation != nil &amp;&amp; afterUpdateCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.UpdateMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to OrderRepositoryMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to OrderRepositoryMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcUpdate != nil &amp;&amp; afterUpdateCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to OrderRepositoryMock.Update at\n%s", m.funcUpdateOrigin)
        }</span>

        <span class="cov0" title="0">if !m.UpdateMock.invocationsDone() &amp;&amp; afterUpdateCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to OrderRepositoryMock.Update at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OrderRepositoryMock) MinimockFinish() <span class="cov10" title="66">{
        m.finishOnce.Do(func() </span><span class="cov8" title="33">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockGetAllOrdersInspect()

                        m.MinimockGetByIDInspect()

                        m.MinimockGetByReceiverIDInspect()

                        m.MinimockGetHistoryByOrderIDInspect()

                        m.MinimockGetPackageRulesInspect()

                        m.MinimockGetReturnedOrdersInspect()

                        m.MinimockSaveInspect()

                        m.MinimockSaveHistoryInspect()

                        m.MinimockUpdateInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OrderRepositoryMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *OrderRepositoryMock) minimockDone() bool <span class="cov8" title="33">{
        done := true
        return done &amp;&amp;
                m.MinimockGetAllOrdersDone() &amp;&amp;
                m.MinimockGetByIDDone() &amp;&amp;
                m.MinimockGetByReceiverIDDone() &amp;&amp;
                m.MinimockGetHistoryByOrderIDDone() &amp;&amp;
                m.MinimockGetPackageRulesDone() &amp;&amp;
                m.MinimockGetReturnedOrdersDone() &amp;&amp;
                m.MinimockSaveDone() &amp;&amp;
                m.MinimockSaveHistoryDone() &amp;&amp;
                m.MinimockUpdateDone()
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package app

import (
        "context"
        "fmt"
        "time"

        "gitlab.ozon.dev/safariproxd/homework/internal/domain"
        "go.uber.org/multierr"
)

func (s *PVZService) ReturnOrdersFromClient(ctx context.Context, receiverID uint64, orderIDs []uint64) error <span class="cov0" title="0">{
        var combinedErr error
        currentTime := s.nowFn()

        for _, orderID := range orderIDs </span><span class="cov0" title="0">{
                order, err := s.orderRepo.GetByID(ctx, orderID)
                if err != nil </span><span class="cov0" title="0">{
                        combinedErr = multierr.Append(combinedErr, fmt.Errorf("repo.GetByID: %w", err))
                        continue</span>
                }

                <span class="cov0" title="0">if order.ReceiverID != receiverID </span><span class="cov0" title="0">{
                        combinedErr = multierr.Append(combinedErr, fmt.Errorf("validation: %w",
                                domain.BelongsToDifferentReceiverError(orderID, receiverID, order.ReceiverID)))
                        continue</span>
                }

                <span class="cov0" title="0">if order.Status == domain.StatusInStorage </span><span class="cov0" title="0">{
                        combinedErr = multierr.Append(combinedErr, fmt.Errorf("validation: %w",
                                domain.AlreadyInStorageError(orderID)))
                        continue</span>
                }

                <span class="cov0" title="0">timeSinceGiven := currentTime.Sub(order.LastUpdateTime)
                twoDaysLimit := 48 * time.Hour
                if timeSinceGiven &gt; twoDaysLimit </span><span class="cov0" title="0">{
                        combinedErr = multierr.Append(combinedErr, fmt.Errorf("validation: %w",
                                domain.ReturnPeriodExpiredError(orderID, timeSinceGiven.Hours())))
                        continue</span>
                }

                <span class="cov0" title="0">order.Status = domain.StatusReturnedFromClient
                order.LastUpdateTime = currentTime
                if err := s.orderRepo.Update(ctx, order); err != nil </span><span class="cov0" title="0">{
                        combinedErr = multierr.Append(combinedErr, fmt.Errorf("repo.Update: %w", err))
                        continue</span>
                }

                <span class="cov0" title="0">history := domain.OrderHistory{
                        OrderID:   orderID,
                        Status:    domain.StatusReturnedFromClient,
                        ChangedAt: currentTime,
                }
                if err := s.orderRepo.SaveHistory(ctx, history); err != nil </span><span class="cov0" title="0">{
                        combinedErr = multierr.Append(combinedErr, fmt.Errorf("repo.SaveHistory: %w", err))
                        continue</span>
                }
        }
        <span class="cov0" title="0">return combinedErr</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package app

import (
        "context"
        "fmt"

        "gitlab.ozon.dev/safariproxd/homework/internal/adapter/cli"
        "gitlab.ozon.dev/safariproxd/homework/internal/domain"
)

func (s *PVZService) ReturnOrderToDelivery(ctx context.Context, orderID uint64) error <span class="cov10" title="10">{
        order, err := s.orderRepo.GetByID(ctx, orderID)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("repo.GetByID: %w", err)
        }</span>

        <span class="cov9" title="9">if order.Status != domain.StatusInStorage &amp;&amp; order.Status != domain.StatusReturnedFromClient </span><span class="cov3" title="2">{
                return fmt.Errorf("validation: %w", domain.ValidationFailedError(
                        fmt.Sprintf("order is not in storage (current status: %s)", order.GetStatusString())))
        }</span>
        <span class="cov8" title="7">if s.nowFn().Before(order.StorageUntil) </span><span class="cov1" title="1">{
                return fmt.Errorf("validation: %w", domain.StorageNotExpiredError(
                        orderID, cli.MapTimeToString(order.StorageUntil)))
        }</span>

        <span class="cov8" title="6">newStatus := domain.StatusReturnedWithoutClient
        if order.Status == domain.StatusReturnedFromClient </span><span class="cov3" title="2">{
                newStatus = domain.StatusGivenToCourier
        }</span>
        <span class="cov8" title="6">order.Status = newStatus
        order.LastUpdateTime = s.nowFn()

        if err := s.orderRepo.Update(ctx, order); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("repo.Update: %w", err)
        }</span>

        <span class="cov7" title="5">history := domain.OrderHistory{
                OrderID:   orderID,
                Status:    newStatus,
                ChangedAt: order.LastUpdateTime,
        }
        if err := s.orderRepo.SaveHistory(ctx, history); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("repo.SaveHistory: %w", err)
        }</span>

        <span class="cov6" title="4">return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package app

import (
        "context"
        "time"

        "gitlab.ozon.dev/safariproxd/homework/internal/domain"
)

type OrderRepository interface {
        Save(ctx context.Context, order domain.Order) error
        GetByID(ctx context.Context, orderID uint64) (domain.Order, error)
        Update(ctx context.Context, order domain.Order) error
        GetByReceiverID(ctx context.Context, receiverID uint64) ([]domain.Order, error)
        GetReturnedOrders(ctx context.Context) ([]domain.Order, error)
        GetAllOrders(ctx context.Context) ([]domain.Order, error)
        GetPackageRules(ctx context.Context, code string) ([]domain.PackageRules, error)
        SaveHistory(ctx context.Context, history domain.OrderHistory) error
        GetHistoryByOrderID(ctx context.Context, orderID uint64) ([]domain.OrderHistory, error)
}

type PVZService struct {
        orderRepo OrderRepository
        nowFn     func() time.Time
}

func NewPVZService(orderRepo OrderRepository, nowFn func() time.Time) *PVZService <span class="cov0" title="0">{
        if nowFn == nil </span><span class="cov0" title="0">{
                nowFn = time.Now
        }</span>
        <span class="cov0" title="0">return &amp;PVZService{
                orderRepo: orderRepo,
                nowFn:     nowFn,
        }</span>
}

func Paginate[T any](items []T, currentPage, itemsPerPage uint64) []T <span class="cov10" title="9">{
        totalItems := uint64(len(items))

        if itemsPerPage == 0 </span><span class="cov1" title="1">{
                return []T{}
        }</span>
        <span class="cov9" title="8">if currentPage == 0 </span><span class="cov1" title="1">{
                currentPage = 1
        }</span>

        <span class="cov9" title="8">startIndex := (currentPage - 1) * itemsPerPage
        endIndex := startIndex + itemsPerPage

        if startIndex &gt;= totalItems </span><span class="cov1" title="1">{
                return []T{}
        }</span>
        <span class="cov8" title="7">if endIndex &gt; totalItems </span><span class="cov5" title="3">{
                endIndex = totalItems
        }</span>

        <span class="cov8" title="7">return items[startIndex:endIndex]</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package app

import (
        "context"
        "testing"
        "time"

        "github.com/gojuno/minimock/v3"
        "gitlab.ozon.dev/safariproxd/homework/internal/app/mock"
        "gitlab.ozon.dev/safariproxd/homework/internal/domain"
)

var (
        someConstTime  = time.Date(2025, time.June, 28, 3, 26, 0, 0, time.UTC)
        contextBack    = context.Background()
        someRecieverID = uint64(100)
)

func Stored(id uint64, status domain.OrderStatus) domain.Order <span class="cov8" title="20">{
        return domain.Order{
                OrderID:        id,
                ReceiverID:     someRecieverID,
                StorageUntil:   someConstTime.Add(24 * time.Hour),
                Status:         status,
                LastUpdateTime: someConstTime.Add(time.Duration(id) * time.Minute),
        }
}</span>

func IdsOf(ord []domain.Order) (ids []uint64) <span class="cov5" title="6">{
        for _, o := range ord </span><span class="cov7" title="11">{
                ids = append(ids, o.OrderID)
        }</span>
        <span class="cov5" title="6">return</span>
}

func NewEnv(t *testing.T) (*mock.OrderRepositoryMock, *PVZService) <span class="cov10" title="33">{
        ctrl := minimock.NewController(t)
        repo := mock.NewOrderRepositoryMock(ctrl)
        svc := &amp;PVZService{orderRepo: repo, nowFn: func() time.Time </span><span class="cov9" title="29">{ return someConstTime }</span>}
        <span class="cov10" title="33">return repo, svc</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package config

import (
        "fmt"
        "os"
        "time"

        "github.com/caarlos0/env/v10"
        "github.com/pkg/errors"
        "gopkg.in/yaml.v3"
)

type Config struct {
        Service struct {
                GRPCAddress    string        `yaml:"grpc_address"`
                HTTPAddress    string        `yaml:"http_address"`
                SwaggerAddress string        `yaml:"swagger_address"`
                Timeout        time.Duration `yaml:"timeout"`
        } `yaml:"service"`

        DB struct {
                ReadHost  string `yaml:"read_host" env:"POSTGRES_READ_HOST"`
                WriteHost string `yaml:"write_host" env:"POSTGRES_WRITE_HOST"`
                Port      int    `yaml:"port" env:"POSTGRES_PORT"`
                Name      string `yaml:"name" env:"POSTGRES_DB"`
                User      string `yaml:"-" env:"POSTGRES_USER"`
                Pass      string `yaml:"-" env:"POSTGRES_PASSWORD"`
                SSL       string `yaml:"sslmode"`
                Pool      struct {
                        MaxOpen int `yaml:"max_open"`
                        MaxIdle int `yaml:"max_idle"`
                } `yaml:"pool"`
                MigrationsDir string `yaml:"migrations_dir"`
        } `yaml:"db"`
}

func (c *Config) ReadDSN() string <span class="cov0" title="0">{
        return fmt.Sprintf(
                "postgres://%s:%s@%s:%d/%s?sslmode=%s",
                c.DB.User, c.DB.Pass, c.DB.ReadHost, c.DB.Port, c.DB.Name, c.DB.SSL)
}</span>

func (c *Config) WriteDSN() string <span class="cov0" title="0">{
        return fmt.Sprintf(
                "postgres://%s:%s@%s:%d/%s?sslmode=%s",
                c.DB.User, c.DB.Pass, c.DB.WriteHost, c.DB.Port, c.DB.Name, c.DB.SSL)
}</span>

func Load(path string) (*Config, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "read yaml")
        }</span>

        <span class="cov0" title="0">var cfg Config
        if err := yaml.Unmarshal(data, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "parse yaml")
        }</span>

        <span class="cov0" title="0">if err := env.Parse(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "parse env")
        }</span>
        <span class="cov0" title="0">return &amp;cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package domain

import "fmt"

type ErrorCode int64

const (
        ErrorCodeNotFound               ErrorCode = 1
        ErrorCodeAlreadyExists          ErrorCode = 2
        ErrorCodeStorageExpired         ErrorCode = 3
        ErrorCodeValidationFailed       ErrorCode = 4
        ErrorCodeAlreadyGiven           ErrorCode = 5
        ErrorCodeBelongsToOtherReceiver ErrorCode = 6
        ErrorCodeAlreadyInStorage       ErrorCode = 7
        ErrorCodeReturnPeriodExpired    ErrorCode = 8
        ErrorCodeStorageNotExpired      ErrorCode = 9
        ErrorCodeUnavaliableReturned    ErrorCode = 10
        ErrorCodeNilOrder               ErrorCode = 11
        ErrorCodeInvalidPackage         ErrorCode = 12
        ErrorCodeWeightTooHeavy         ErrorCode = 13
)

type Error struct {
        Code    ErrorCode
        Message string
}

func (e Error) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

func EntityNotFoundError(entityName, entityID string) error <span class="cov8" title="1">{
        return Error{
                Code:    ErrorCodeNotFound,
                Message: fmt.Sprintf("Entity %q with ID %s not found", entityName, entityID),
        }
}</span>

func OrderAlreadyExistsError(orderID uint64) error <span class="cov8" title="1">{
        return Error{
                Code:    ErrorCodeAlreadyExists,
                Message: fmt.Sprintf("Order %d already exists", orderID),
        }
}</span>

func StorageExpiredError(orderID uint64, storageUntil string) error <span class="cov8" title="1">{
        return Error{
                Code:    ErrorCodeStorageExpired,
                Message: fmt.Sprintf("Order %d storage period expired (%s)", orderID, storageUntil),
        }
}</span>

func ValidationFailedError(message string) error <span class="cov0" title="0">{
        return Error{
                Code:    ErrorCodeValidationFailed,
                Message: message,
        }
}</span>

func OrderAlreadyGivenError(orderID uint64) error <span class="cov0" title="0">{
        return Error{
                Code:    ErrorCodeAlreadyGiven,
                Message: fmt.Sprintf("Order %d already given to client", orderID),
        }
}</span>

func BelongsToDifferentReceiverError(orderID, expectedReceiverID, actualReceiverID uint64) error <span class="cov0" title="0">{
        return Error{
                Code:    ErrorCodeBelongsToOtherReceiver,
                Message: fmt.Sprintf("Order %d belongs to a different receiver (expected %d, got %d)", orderID, expectedReceiverID, actualReceiverID),
        }
}</span>

func AlreadyInStorageError(orderID uint64) error <span class="cov0" title="0">{
        return Error{
                Code:    ErrorCodeAlreadyInStorage,
                Message: fmt.Sprintf("Order %d is already in storage", orderID),
        }
}</span>

func ReturnPeriodExpiredError(orderID uint64, hoursSinceGiven float64) error <span class="cov0" title="0">{
        return Error{
                Code:    ErrorCodeReturnPeriodExpired,
                Message: fmt.Sprintf("Order %d return period expired (%.1f hours)", orderID, hoursSinceGiven),
        }
}</span>

func StorageNotExpiredError(orderID uint64, storageUntil string) error <span class="cov0" title="0">{
        return Error{
                Code:    ErrorCodeStorageNotExpired,
                Message: fmt.Sprintf("Order %d storage period not expired (until %s)", orderID, storageUntil),
        }
}</span>

func UnavaliableReturnedOrderError(orderID uint64) error <span class="cov0" title="0">{
        return Error{
                Code:    ErrorCodeUnavaliableReturned,
                Message: fmt.Sprintf("Order %d is an unavailable returned order", orderID),
        }
}</span>

func NilOrderError(orderID uint64) error <span class="cov0" title="0">{
        return Error{
                Code:    ErrorCodeNilOrder,
                Message: fmt.Sprintf("Order %d is nil", orderID),
        }
}</span>

func InvalidPackageError(packageType string) error <span class="cov0" title="0">{
        return Error{
                Code:    ErrorCodeInvalidPackage,
                Message: fmt.Sprintf("Invalid package type: %s", packageType),
        }
}</span>

func WeightTooHeavyError(packageType string, weight float64, maxWeight float64) error <span class="cov8" title="1">{
        return Error{
                Code:    ErrorCodeWeightTooHeavy,
                Message: fmt.Sprintf("Weight %.2f kg exceeds maximum allowed for %s (%.2f kg)", weight, packageType, maxWeight),
        }
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package domain

import (
        "time"
)

type OrderStatus uint8

const (
        StatusInStorage OrderStatus = iota
        StatusGivenToClient
        StatusReturnedFromClient
        StatusReturnedWithoutClient
        StatusGivenToCourier
)

type Order struct {
        OrderID        uint64
        ReceiverID     uint64
        StorageUntil   time.Time
        Status         OrderStatus
        AcceptTime     time.Time
        LastUpdateTime time.Time
        PackageType    string
        Weight         float64
        Price          float64
}

type OrderHistory struct {
        OrderID   uint64
        Status    OrderStatus
        ChangedAt time.Time
}

type OrderToImport struct {
        OrderID      uint64  `json:"order_id"`
        ReceiverID   uint64  `json:"receiver_id"`
        StorageUntil string  `json:"storage_until"`
        PackageType  string  `json:"package_type"`
        Weight       float64 `json:"weight"`
        Price        float64 `json:"price"`
}

var OrdersToImport []OrderToImport

type AcceptOrderRequest struct {
        ReceiverID   uint64
        OrderID      uint64
        StorageUntil time.Time
        Weight       float64
        Price        float64
        PackageType  string
}

type ReceiverOrdersRequest struct {
        ReceiverID uint64
        InPVZ      bool
        LastN      uint64
        Page       uint64
        Limit      uint64
}

type PackageRules struct {
        MaxWeight float64 `json:"max_weight"`
        Price     float64 `json:"price"`
}

func (o Order) GetStatusString() string <span class="cov10" title="6">{
        switch o.Status </span>{
        case StatusInStorage:<span class="cov1" title="1">
                return "In Storage"</span>
        case StatusGivenToClient:<span class="cov1" title="1">
                return "Given to client"</span>
        case StatusReturnedFromClient:<span class="cov1" title="1">
                return "Returned from client"</span>
        case StatusGivenToCourier:<span class="cov1" title="1">
                return "Given to courier"</span>
        case StatusReturnedWithoutClient:<span class="cov1" title="1">
                return "Given to courier without client"</span>
        default:<span class="cov1" title="1">
                return "Unknown Status"</span>
        }
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "gitlab.ozon.dev/safariproxd/homework/internal/domain"
)

func (r *OrderRepository) Exists(ctx context.Context, orderID uint64) (bool, error) <span class="cov0" title="0">{
        query := `SELECT 1 FROM orders WHERE id = $1`
        var exists int
        err := r.client.QueryRow(ctx, query, orderID).Scan(&amp;exists)
        if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("check existence: %w", err)
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}

func (r *OrderRepository) Save(ctx context.Context, order domain.Order) error <span class="cov0" title="0">{
        query := `
                INSERT INTO orders (id, receiver_id, expires_at, status, accept_time, last_update_time, package_code, weight, price)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
        `
        tx, err := r.client.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("begin transaction: %w", err)
        }</span>

        <span class="cov0" title="0">exists, err := r.Exists(ctx, order.OrderID)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return fmt.Errorf("check existence: %w", err)
        }</span>
        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                tx.Rollback()
                return fmt.Errorf("save: %w", domain.OrderAlreadyExistsError(order.OrderID))
        }</span>

        <span class="cov0" title="0">_, err = tx.Exec(ctx, query,
                order.OrderID,
                order.ReceiverID,
                order.StorageUntil,
                order.Status,
                order.AcceptTime,
                order.LastUpdateTime,
                order.PackageType,
                order.Weight,
                order.Price,
        )
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return fmt.Errorf("exec insert: %w", err)
        }</span>

        <span class="cov0" title="0">return tx.Commit()</span>
}

func (r *OrderRepository) Update(ctx context.Context, order domain.Order) error <span class="cov0" title="0">{
        query := `
                UPDATE orders
                SET receiver_id = $2, expires_at = $3, status = $4, accept_time = $5, last_update_time = $6, package_code = $7, weight = $8, price = $9
                WHERE id = $1
        `
        tx, err := r.client.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("begin transaction: %w", err)
        }</span>

        <span class="cov0" title="0">result, err := tx.Exec(ctx, query,
                order.OrderID,
                order.ReceiverID,
                order.StorageUntil,
                order.Status,
                order.AcceptTime,
                order.LastUpdateTime,
                order.PackageType,
                order.Weight,
                order.Price,
        )
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return fmt.Errorf("exec update: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return fmt.Errorf("rows affected: %w", err)
        }</span>
        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                tx.Rollback()
                return fmt.Errorf("update: %w", domain.EntityNotFoundError("Order", fmt.Sprintf("%d", order.OrderID)))
        }</span>

        <span class="cov0" title="0">return tx.Commit()</span>
}

func (r *OrderRepository) SaveHistory(ctx context.Context, history domain.OrderHistory) error <span class="cov0" title="0">{
        query := `
                INSERT INTO order_history (order_id, status, changed_at)
                VALUES ($1, $2, $3)
        `

        tx, err := r.client.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("begin transaction: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = tx.Exec(ctx, query, history.OrderID, history.Status, history.ChangedAt)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return fmt.Errorf("exec insert: %w", err)
        }</span>

        <span class="cov0" title="0">return tx.Commit()</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "gitlab.ozon.dev/safariproxd/homework/internal/domain"
)

func (r *OrderRepository) GetByID(ctx context.Context, orderID uint64) (domain.Order, error) <span class="cov0" title="0">{
        query := `
                SELECT id, receiver_id, expires_at, status, accept_time, last_update_time, package_code, weight, price
                FROM orders
                WHERE id = $1
        `
        row := r.client.QueryRow(ctx, query, orderID)

        order, err := scanOrder(row)
        if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                return domain.Order{}, fmt.Errorf("get by id: %w", domain.EntityNotFoundError("Order", fmt.Sprintf("%d", orderID)))
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return domain.Order{}, err
        }</span>

        <span class="cov0" title="0">return order, nil</span>
}

func (r *OrderRepository) GetByReceiverID(ctx context.Context, receiverID uint64) ([]domain.Order, error) <span class="cov0" title="0">{
        query := `
                SELECT id, receiver_id, expires_at, status, accept_time, last_update_time, package_code, weight, price
                FROM orders
                WHERE receiver_id = $1
        `
        rows, err := r.client.Query(ctx, query, receiverID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var orders []domain.Order
        for rows.Next() </span><span class="cov0" title="0">{
                order, err := scanOrder(rows)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">orders = append(orders, order)</span>
        }

        <span class="cov0" title="0">return orders, nil</span>
}

func (r *OrderRepository) GetReturnedOrders(ctx context.Context) ([]domain.Order, error) <span class="cov0" title="0">{
        query := `
                SELECT id, receiver_id, expires_at, status, accept_time, last_update_time, package_code, weight, price
                FROM orders
                WHERE status IN ($1, $2)
                ORDER BY last_update_time DESC
        `
        rows, err := r.client.Query(ctx, query, domain.StatusReturnedFromClient, domain.StatusGivenToCourier)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var orders []domain.Order
        for rows.Next() </span><span class="cov0" title="0">{
                order, err := scanOrder(rows)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">orders = append(orders, order)</span>
        }

        <span class="cov0" title="0">return orders, nil</span>
}

func (r *OrderRepository) GetAllOrders(ctx context.Context) ([]domain.Order, error) <span class="cov0" title="0">{
        query := `
                SELECT id, receiver_id, expires_at, status, accept_time, last_update_time, package_code, weight, price
                FROM orders
                ORDER BY last_update_time DESC
        `
        rows, err := r.client.Query(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var orders []domain.Order
        for rows.Next() </span><span class="cov0" title="0">{
                order, err := scanOrder(rows)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">orders = append(orders, order)</span>
        }

        <span class="cov0" title="0">return orders, nil</span>
}

func (r *OrderRepository) GetPackageRules(ctx context.Context, code string) ([]domain.PackageRules, error) <span class="cov0" title="0">{
        query := `
                SELECT max_weight, extra_price
                FROM package_types
                WHERE code = $1
        `
        rows, err := r.client.Query(ctx, query, code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var rules []domain.PackageRules
        for rows.Next() </span><span class="cov0" title="0">{
                var rule domain.PackageRules
                err := rows.Scan(&amp;rule.MaxWeight, &amp;rule.Price)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("scan: %w", err)
                }</span>
                <span class="cov0" title="0">rules = append(rules, rule)</span>
        }

        <span class="cov0" title="0">if len(rules) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no rules found for package code %s", code)
        }</span>

        <span class="cov0" title="0">return rules, nil</span>
}

func (r *OrderRepository) GetHistoryByOrderID(ctx context.Context, orderID uint64) ([]domain.OrderHistory, error) <span class="cov0" title="0">{
        query := `
        SELECT order_id, status, changed_at
        FROM order_history
        WHERE order_id = $1
        ORDER BY changed_at DESC
    `

        rows, err := r.client.Query(ctx, query, orderID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var history []domain.OrderHistory
        for rows.Next() </span><span class="cov0" title="0">{
                var h domain.OrderHistory
                err := rows.Scan(&amp;h.OrderID, &amp;h.Status, &amp;h.ChangedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("scan: %w", err)
                }</span>
                <span class="cov0" title="0">history = append(history, h)</span>
        }

        <span class="cov0" title="0">return history, nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package postgres

import (
        "database/sql"
        "fmt"
        "time"

        "gitlab.ozon.dev/safariproxd/homework/internal/domain"
        "gitlab.ozon.dev/safariproxd/homework/pkg/db"
)

type Scanner interface {
        Scan(dest ...interface{}) error
}

func scanOrder(scanner Scanner) (domain.Order, error) <span class="cov0" title="0">{
        var order domain.Order
        var expiresAt, acceptTime, lastUpdateTime time.Time
        var packageCode sql.NullString

        err := scanner.Scan(
                &amp;order.OrderID,
                &amp;order.ReceiverID,
                &amp;expiresAt,
                &amp;order.Status,
                &amp;acceptTime,
                &amp;lastUpdateTime,
                &amp;packageCode,
                &amp;order.Weight,
                &amp;order.Price,
        )
        if err != nil </span><span class="cov0" title="0">{
                return domain.Order{}, fmt.Errorf("scan: %w", err)
        }</span>

        <span class="cov0" title="0">return domain.Order{
                OrderID:        order.OrderID,
                ReceiverID:     order.ReceiverID,
                StorageUntil:   expiresAt,
                Status:         order.Status,
                AcceptTime:     acceptTime,
                LastUpdateTime: lastUpdateTime,
                PackageType:    packageCode.String,
                Weight:         order.Weight,
                Price:          order.Price,
        }, nil</span>
}

type OrderRepository struct {
        client *db.Client
}

func NewOrderRepository(client *db.Client) *OrderRepository <span class="cov0" title="0">{
        return &amp;OrderRepository{client: client}
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.6
//         protoc        v6.31.1
// source: orders/contract.proto

package api

import (
        _ "github.com/envoyproxy/protoc-gen-validate/validate"
        _ "github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2/options"
        _ "google.golang.org/genproto/googleapis/api/annotations"
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type ActionType int32

const (
        ActionType_ACTION_TYPE_UNSPECIFIED ActionType = 0
        ActionType_ACTION_TYPE_ISSUE       ActionType = 1
        ActionType_ACTION_TYPE_RETURN      ActionType = 2
)

// Enum value maps for ActionType.
var (
        ActionType_name = map[int32]string{
                0: "ACTION_TYPE_UNSPECIFIED",
                1: "ACTION_TYPE_ISSUE",
                2: "ACTION_TYPE_RETURN",
        }
        ActionType_value = map[string]int32{
                "ACTION_TYPE_UNSPECIFIED": 0,
                "ACTION_TYPE_ISSUE":       1,
                "ACTION_TYPE_RETURN":      2,
        }
)

func (x ActionType) Enum() *ActionType <span class="cov0" title="0">{
        p := new(ActionType)
        *p = x
        return p
}</span>

func (x ActionType) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (ActionType) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_orders_contract_proto_enumTypes[0].Descriptor()
}</span>

func (ActionType) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_orders_contract_proto_enumTypes[0]
}</span>

func (x ActionType) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use ActionType.Descriptor instead.
func (ActionType) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_orders_contract_proto_rawDescGZIP(), []int{0}
}</span>

type PackageType int32

const (
        PackageType_PACKAGE_TYPE_UNSPECIFIED PackageType = 0
        PackageType_PACKAGE_TYPE_BAG         PackageType = 1
        PackageType_PACKAGE_TYPE_BOX         PackageType = 2
        PackageType_PACKAGE_TYPE_TAPE        PackageType = 3
        PackageType_PACKAGE_TYPE_BAG_TAPE    PackageType = 4
        PackageType_PACKAGE_TYPE_BOX_TAPE    PackageType = 5
)

// Enum value maps for PackageType.
var (
        PackageType_name = map[int32]string{
                0: "PACKAGE_TYPE_UNSPECIFIED",
                1: "PACKAGE_TYPE_BAG",
                2: "PACKAGE_TYPE_BOX",
                3: "PACKAGE_TYPE_TAPE",
                4: "PACKAGE_TYPE_BAG_TAPE",
                5: "PACKAGE_TYPE_BOX_TAPE",
        }
        PackageType_value = map[string]int32{
                "PACKAGE_TYPE_UNSPECIFIED": 0,
                "PACKAGE_TYPE_BAG":         1,
                "PACKAGE_TYPE_BOX":         2,
                "PACKAGE_TYPE_TAPE":        3,
                "PACKAGE_TYPE_BAG_TAPE":    4,
                "PACKAGE_TYPE_BOX_TAPE":    5,
        }
)

func (x PackageType) Enum() *PackageType <span class="cov0" title="0">{
        p := new(PackageType)
        *p = x
        return p
}</span>

func (x PackageType) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (PackageType) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_orders_contract_proto_enumTypes[1].Descriptor()
}</span>

func (PackageType) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_orders_contract_proto_enumTypes[1]
}</span>

func (x PackageType) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use PackageType.Descriptor instead.
func (PackageType) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_orders_contract_proto_rawDescGZIP(), []int{1}
}</span>

type OrderStatus int32

const (
        OrderStatus_ORDER_STATUS_UNSPECIFIED OrderStatus = 0
        OrderStatus_ORDER_STATUS_EXPECTS     OrderStatus = 1
        OrderStatus_ORDER_STATUS_ACCEPTED    OrderStatus = 2
        OrderStatus_ORDER_STATUS_RETURNED    OrderStatus = 3
        OrderStatus_ORDER_STATUS_DELETED     OrderStatus = 4
)

// Enum value maps for OrderStatus.
var (
        OrderStatus_name = map[int32]string{
                0: "ORDER_STATUS_UNSPECIFIED",
                1: "ORDER_STATUS_EXPECTS",
                2: "ORDER_STATUS_ACCEPTED",
                3: "ORDER_STATUS_RETURNED",
                4: "ORDER_STATUS_DELETED",
        }
        OrderStatus_value = map[string]int32{
                "ORDER_STATUS_UNSPECIFIED": 0,
                "ORDER_STATUS_EXPECTS":     1,
                "ORDER_STATUS_ACCEPTED":    2,
                "ORDER_STATUS_RETURNED":    3,
                "ORDER_STATUS_DELETED":     4,
        }
)

func (x OrderStatus) Enum() *OrderStatus <span class="cov0" title="0">{
        p := new(OrderStatus)
        *p = x
        return p
}</span>

func (x OrderStatus) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (OrderStatus) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_orders_contract_proto_enumTypes[2].Descriptor()
}</span>

func (OrderStatus) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_orders_contract_proto_enumTypes[2]
}</span>

func (x OrderStatus) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use OrderStatus.Descriptor instead.
func (OrderStatus) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_orders_contract_proto_rawDescGZIP(), []int{2}
}</span>

type AcceptOrderRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        OrderId       uint64                 `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
        UserId        uint64                 `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        ExpiresAt     *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
        Package       *PackageType           `protobuf:"varint,4,opt,name=package,proto3,enum=orders.PackageType,oneof" json:"package,omitempty"`
        Weight        float32                `protobuf:"fixed32,5,opt,name=weight,proto3" json:"weight,omitempty"`
        Price         float32                `protobuf:"fixed32,6,opt,name=price,proto3" json:"price,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *AcceptOrderRequest) Reset() <span class="cov0" title="0">{
        *x = AcceptOrderRequest{}
        mi := &amp;file_orders_contract_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *AcceptOrderRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AcceptOrderRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AcceptOrderRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_orders_contract_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AcceptOrderRequest.ProtoReflect.Descriptor instead.
func (*AcceptOrderRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_orders_contract_proto_rawDescGZIP(), []int{0}
}</span>

func (x *AcceptOrderRequest) GetOrderId() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OrderId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *AcceptOrderRequest) GetUserId() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *AcceptOrderRequest) GetExpiresAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExpiresAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *AcceptOrderRequest) GetPackage() PackageType <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Package != nil </span><span class="cov0" title="0">{
                return *x.Package
        }</span>
        <span class="cov0" title="0">return PackageType_PACKAGE_TYPE_UNSPECIFIED</span>
}

func (x *AcceptOrderRequest) GetWeight() float32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Weight
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *AcceptOrderRequest) GetPrice() float32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Price
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type OrderIdRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        OrderId       uint64                 `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *OrderIdRequest) Reset() <span class="cov0" title="0">{
        *x = OrderIdRequest{}
        mi := &amp;file_orders_contract_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *OrderIdRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*OrderIdRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *OrderIdRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_orders_contract_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use OrderIdRequest.ProtoReflect.Descriptor instead.
func (*OrderIdRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_orders_contract_proto_rawDescGZIP(), []int{1}
}</span>

func (x *OrderIdRequest) GetOrderId() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OrderId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type ProcessOrdersRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        UserId        uint64                 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        Action        ActionType             `protobuf:"varint,2,opt,name=action,proto3,enum=orders.ActionType" json:"action,omitempty"`
        OrderIds      []uint64               `protobuf:"varint,3,rep,packed,name=order_ids,json=orderIds,proto3" json:"order_ids,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ProcessOrdersRequest) Reset() <span class="cov0" title="0">{
        *x = ProcessOrdersRequest{}
        mi := &amp;file_orders_contract_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ProcessOrdersRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ProcessOrdersRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ProcessOrdersRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_orders_contract_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ProcessOrdersRequest.ProtoReflect.Descriptor instead.
func (*ProcessOrdersRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_orders_contract_proto_rawDescGZIP(), []int{2}
}</span>

func (x *ProcessOrdersRequest) GetUserId() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ProcessOrdersRequest) GetAction() ActionType <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Action
        }</span>
        <span class="cov0" title="0">return ActionType_ACTION_TYPE_UNSPECIFIED</span>
}

func (x *ProcessOrdersRequest) GetOrderIds() []uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OrderIds
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListOrdersRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        UserId        uint64                 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        InPvz         bool                   `protobuf:"varint,2,opt,name=in_pvz,json=inPvz,proto3" json:"in_pvz,omitempty"`
        LastN         *uint32                `protobuf:"varint,3,opt,name=last_n,json=lastN,proto3,oneof" json:"last_n,omitempty"`
        Pagination    *Pagination            `protobuf:"bytes,4,opt,name=pagination,proto3,oneof" json:"pagination,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ListOrdersRequest) Reset() <span class="cov0" title="0">{
        *x = ListOrdersRequest{}
        mi := &amp;file_orders_contract_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ListOrdersRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListOrdersRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListOrdersRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_orders_contract_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListOrdersRequest.ProtoReflect.Descriptor instead.
func (*ListOrdersRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_orders_contract_proto_rawDescGZIP(), []int{3}
}</span>

func (x *ListOrdersRequest) GetUserId() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ListOrdersRequest) GetInPvz() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.InPvz
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *ListOrdersRequest) GetLastN() uint32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.LastN != nil </span><span class="cov0" title="0">{
                return *x.LastN
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ListOrdersRequest) GetPagination() *Pagination <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Pagination
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Pagination struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Page          uint32                 `protobuf:"varint,1,opt,name=page,proto3" json:"page,omitempty"`
        CountOnPage   uint32                 `protobuf:"varint,2,opt,name=count_on_page,json=countOnPage,proto3" json:"count_on_page,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Pagination) Reset() <span class="cov0" title="0">{
        *x = Pagination{}
        mi := &amp;file_orders_contract_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Pagination) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Pagination) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Pagination) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_orders_contract_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Pagination.ProtoReflect.Descriptor instead.
func (*Pagination) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_orders_contract_proto_rawDescGZIP(), []int{4}
}</span>

func (x *Pagination) GetPage() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Page
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Pagination) GetCountOnPage() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CountOnPage
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type ListReturnsRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Pagination    *Pagination            `protobuf:"bytes,1,opt,name=pagination,proto3" json:"pagination,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ListReturnsRequest) Reset() <span class="cov0" title="0">{
        *x = ListReturnsRequest{}
        mi := &amp;file_orders_contract_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ListReturnsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListReturnsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListReturnsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_orders_contract_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListReturnsRequest.ProtoReflect.Descriptor instead.
func (*ListReturnsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_orders_contract_proto_rawDescGZIP(), []int{5}
}</span>

func (x *ListReturnsRequest) GetPagination() *Pagination <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Pagination
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ImportOrdersRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Orders        []*AcceptOrderRequest  `protobuf:"bytes,1,rep,name=orders,proto3" json:"orders,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ImportOrdersRequest) Reset() <span class="cov0" title="0">{
        *x = ImportOrdersRequest{}
        mi := &amp;file_orders_contract_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ImportOrdersRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ImportOrdersRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ImportOrdersRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_orders_contract_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ImportOrdersRequest.ProtoReflect.Descriptor instead.
func (*ImportOrdersRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_orders_contract_proto_rawDescGZIP(), []int{6}
}</span>

func (x *ImportOrdersRequest) GetOrders() []*AcceptOrderRequest <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Orders
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetHistoryRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Pagination    *Pagination            `protobuf:"bytes,1,opt,name=pagination,proto3" json:"pagination,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetHistoryRequest) Reset() <span class="cov0" title="0">{
        *x = GetHistoryRequest{}
        mi := &amp;file_orders_contract_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetHistoryRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetHistoryRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetHistoryRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_orders_contract_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetHistoryRequest.ProtoReflect.Descriptor instead.
func (*GetHistoryRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_orders_contract_proto_rawDescGZIP(), []int{7}
}</span>

func (x *GetHistoryRequest) GetPagination() *Pagination <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Pagination
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type OrderHistoryRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        OrderId       uint64                 `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *OrderHistoryRequest) Reset() <span class="cov0" title="0">{
        *x = OrderHistoryRequest{}
        mi := &amp;file_orders_contract_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *OrderHistoryRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*OrderHistoryRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *OrderHistoryRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_orders_contract_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use OrderHistoryRequest.ProtoReflect.Descriptor instead.
func (*OrderHistoryRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_orders_contract_proto_rawDescGZIP(), []int{8}
}</span>

func (x *OrderHistoryRequest) GetOrderId() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OrderId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type OrderHistoryResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        History       []*OrderHistory        `protobuf:"bytes,1,rep,name=history,proto3" json:"history,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *OrderHistoryResponse) Reset() <span class="cov0" title="0">{
        *x = OrderHistoryResponse{}
        mi := &amp;file_orders_contract_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *OrderHistoryResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*OrderHistoryResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *OrderHistoryResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_orders_contract_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use OrderHistoryResponse.ProtoReflect.Descriptor instead.
func (*OrderHistoryResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_orders_contract_proto_rawDescGZIP(), []int{9}
}</span>

func (x *OrderHistoryResponse) GetHistory() []*OrderHistory <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.History
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type OrderResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Status        OrderStatus            `protobuf:"varint,1,opt,name=status,proto3,enum=orders.OrderStatus" json:"status,omitempty"`
        OrderId       uint64                 `protobuf:"varint,2,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *OrderResponse) Reset() <span class="cov0" title="0">{
        *x = OrderResponse{}
        mi := &amp;file_orders_contract_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *OrderResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*OrderResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *OrderResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_orders_contract_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use OrderResponse.ProtoReflect.Descriptor instead.
func (*OrderResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_orders_contract_proto_rawDescGZIP(), []int{10}
}</span>

func (x *OrderResponse) GetStatus() OrderStatus <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return OrderStatus_ORDER_STATUS_UNSPECIFIED</span>
}

func (x *OrderResponse) GetOrderId() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OrderId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type ProcessResult struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Processed     []uint64               `protobuf:"varint,1,rep,packed,name=processed,proto3" json:"processed,omitempty"`
        Errors        []uint64               `protobuf:"varint,2,rep,packed,name=errors,proto3" json:"errors,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ProcessResult) Reset() <span class="cov0" title="0">{
        *x = ProcessResult{}
        mi := &amp;file_orders_contract_proto_msgTypes[11]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ProcessResult) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ProcessResult) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ProcessResult) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_orders_contract_proto_msgTypes[11]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ProcessResult.ProtoReflect.Descriptor instead.
func (*ProcessResult) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_orders_contract_proto_rawDescGZIP(), []int{11}
}</span>

func (x *ProcessResult) GetProcessed() []uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Processed
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ProcessResult) GetErrors() []uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Errors
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type OrdersList struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Orders        []*Order               `protobuf:"bytes,1,rep,name=orders,proto3" json:"orders,omitempty"`
        Total         int32                  `protobuf:"varint,2,opt,name=total,proto3" json:"total,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *OrdersList) Reset() <span class="cov0" title="0">{
        *x = OrdersList{}
        mi := &amp;file_orders_contract_proto_msgTypes[12]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *OrdersList) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*OrdersList) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *OrdersList) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_orders_contract_proto_msgTypes[12]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use OrdersList.ProtoReflect.Descriptor instead.
func (*OrdersList) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_orders_contract_proto_rawDescGZIP(), []int{12}
}</span>

func (x *OrdersList) GetOrders() []*Order <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Orders
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *OrdersList) GetTotal() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Total
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type ReturnsList struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Returns       []*Order               `protobuf:"bytes,1,rep,name=returns,proto3" json:"returns,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ReturnsList) Reset() <span class="cov0" title="0">{
        *x = ReturnsList{}
        mi := &amp;file_orders_contract_proto_msgTypes[13]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ReturnsList) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ReturnsList) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ReturnsList) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_orders_contract_proto_msgTypes[13]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ReturnsList.ProtoReflect.Descriptor instead.
func (*ReturnsList) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_orders_contract_proto_rawDescGZIP(), []int{13}
}</span>

func (x *ReturnsList) GetReturns() []*Order <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Returns
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type OrderHistoryList struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        History       []*OrderHistory        `protobuf:"bytes,1,rep,name=history,proto3" json:"history,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *OrderHistoryList) Reset() <span class="cov0" title="0">{
        *x = OrderHistoryList{}
        mi := &amp;file_orders_contract_proto_msgTypes[14]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *OrderHistoryList) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*OrderHistoryList) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *OrderHistoryList) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_orders_contract_proto_msgTypes[14]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use OrderHistoryList.ProtoReflect.Descriptor instead.
func (*OrderHistoryList) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_orders_contract_proto_rawDescGZIP(), []int{14}
}</span>

func (x *OrderHistoryList) GetHistory() []*OrderHistory <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.History
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ImportResult struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Imported      int32                  `protobuf:"varint,1,opt,name=imported,proto3" json:"imported,omitempty"`
        Errors        []uint64               `protobuf:"varint,2,rep,packed,name=errors,proto3" json:"errors,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ImportResult) Reset() <span class="cov0" title="0">{
        *x = ImportResult{}
        mi := &amp;file_orders_contract_proto_msgTypes[15]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ImportResult) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ImportResult) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ImportResult) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_orders_contract_proto_msgTypes[15]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ImportResult.ProtoReflect.Descriptor instead.
func (*ImportResult) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_orders_contract_proto_rawDescGZIP(), []int{15}
}</span>

func (x *ImportResult) GetImported() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Imported
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ImportResult) GetErrors() []uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Errors
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Order struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        OrderId       uint64                 `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
        UserId        uint64                 `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        Status        OrderStatus            `protobuf:"varint,3,opt,name=status,proto3,enum=orders.OrderStatus" json:"status,omitempty"`
        ExpiresAt     *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
        Weight        float32                `protobuf:"fixed32,5,opt,name=weight,proto3" json:"weight,omitempty"`
        TotalPrice    float32                `protobuf:"fixed32,6,opt,name=total_price,json=totalPrice,proto3" json:"total_price,omitempty"`
        Package       *PackageType           `protobuf:"varint,7,opt,name=package,proto3,enum=orders.PackageType,oneof" json:"package,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Order) Reset() <span class="cov0" title="0">{
        *x = Order{}
        mi := &amp;file_orders_contract_proto_msgTypes[16]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Order) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Order) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Order) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_orders_contract_proto_msgTypes[16]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Order.ProtoReflect.Descriptor instead.
func (*Order) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_orders_contract_proto_rawDescGZIP(), []int{16}
}</span>

func (x *Order) GetOrderId() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OrderId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Order) GetUserId() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Order) GetStatus() OrderStatus <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return OrderStatus_ORDER_STATUS_UNSPECIFIED</span>
}

func (x *Order) GetExpiresAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExpiresAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Order) GetWeight() float32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Weight
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Order) GetTotalPrice() float32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalPrice
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Order) GetPackage() PackageType <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Package != nil </span><span class="cov0" title="0">{
                return *x.Package
        }</span>
        <span class="cov0" title="0">return PackageType_PACKAGE_TYPE_UNSPECIFIED</span>
}

type OrderHistory struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        OrderId       uint64                 `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
        Status        OrderStatus            `protobuf:"varint,2,opt,name=status,proto3,enum=orders.OrderStatus" json:"status,omitempty"`
        CreatedAt     *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *OrderHistory) Reset() <span class="cov0" title="0">{
        *x = OrderHistory{}
        mi := &amp;file_orders_contract_proto_msgTypes[17]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *OrderHistory) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*OrderHistory) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *OrderHistory) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_orders_contract_proto_msgTypes[17]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use OrderHistory.ProtoReflect.Descriptor instead.
func (*OrderHistory) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_orders_contract_proto_rawDescGZIP(), []int{17}
}</span>

func (x *OrderHistory) GetOrderId() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OrderId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *OrderHistory) GetStatus() OrderStatus <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return OrderStatus_ORDER_STATUS_UNSPECIFIED</span>
}

func (x *OrderHistory) GetCreatedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_orders_contract_proto protoreflect.FileDescriptor

const file_orders_contract_proto_rawDesc = "" +
        "\n" +
        "\x15orders/contract.proto\x12\x06orders\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x17validate/validate.proto\x1a\x1cgoogle/api/annotations.proto\x1a.protoc-gen-openapiv2/options/annotations.proto\"\xa7\x02\n" +
        "\x12AcceptOrderRequest\x12\"\n" +
        "\border_id\x18\x01 \x01(\x04B\a\xfaB\x042\x02 \x00R\aorderId\x12 \n" +
        "\auser_id\x18\x02 \x01(\x04B\a\xfaB\x042\x02 \x00R\x06userId\x12E\n" +
        "\n" +
        "expires_at\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampB\n" +
        "\xfaB\a\xb2\x01\x04\b\x01@\x01R\texpiresAt\x122\n" +
        "\apackage\x18\x04 \x01(\x0e2\x13.orders.PackageTypeH\x00R\apackage\x88\x01\x01\x12\"\n" +
        "\x06weight\x18\x05 \x01(\x02B\n" +
        "\xfaB\a\n" +
        "\x05%\x00\x00\x00\x00R\x06weight\x12 \n" +
        "\x05price\x18\x06 \x01(\x02B\n" +
        "\xfaB\a\n" +
        "\x05%\x00\x00\x00\x00R\x05priceB\n" +
        "\n" +
        "\b_package\"4\n" +
        "\x0eOrderIdRequest\x12\"\n" +
        "\border_id\x18\x01 \x01(\x04B\a\xfaB\x042\x02 \x00R\aorderId\"\x9d\x01\n" +
        "\x14ProcessOrdersRequest\x12 \n" +
        "\auser_id\x18\x01 \x01(\x04B\a\xfaB\x042\x02 \x00R\x06userId\x126\n" +
        "\x06action\x18\x02 \x01(\x0e2\x12.orders.ActionTypeB\n" +
        "\xfaB\a\x82\x01\x04\x10\x01 \x00R\x06action\x12+\n" +
        "\torder_ids\x18\x03 \x03(\x04B\x0e\xfaB\v\x92\x01\b\b\x01\"\x042\x02 \x00R\borderIds\"\xc4\x01\n" +
        "\x11ListOrdersRequest\x12 \n" +
        "\auser_id\x18\x01 \x01(\x04B\a\xfaB\x042\x02 \x00R\x06userId\x12\x15\n" +
        "\x06in_pvz\x18\x02 \x01(\bR\x05inPvz\x12#\n" +
        "\x06last_n\x18\x03 \x01(\rB\a\xfaB\x04*\x02 \x00H\x00R\x05lastN\x88\x01\x01\x127\n" +
        "\n" +
        "pagination\x18\x04 \x01(\v2\x12.orders.PaginationH\x01R\n" +
        "pagination\x88\x01\x01B\t\n" +
        "\a_last_nB\r\n" +
        "\v_pagination\"V\n" +
        "\n" +
        "Pagination\x12\x1b\n" +
        "\x04page\x18\x01 \x01(\rB\a\xfaB\x04*\x02(\x00R\x04page\x12+\n" +
        "\rcount_on_page\x18\x02 \x01(\rB\a\xfaB\x04*\x02 \x00R\vcountOnPage\"H\n" +
        "\x12ListReturnsRequest\x122\n" +
        "\n" +
        "pagination\x18\x01 \x01(\v2\x12.orders.PaginationR\n" +
        "pagination\"S\n" +
        "\x13ImportOrdersRequest\x12&lt;\n" +
        "\x06orders\x18\x01 \x03(\v2\x1a.orders.AcceptOrderRequestB\b\xfaB\x05\x92\x01\x02\b\x01R\x06orders\"G\n" +
        "\x11GetHistoryRequest\x122\n" +
        "\n" +
        "pagination\x18\x01 \x01(\v2\x12.orders.PaginationR\n" +
        "pagination\"9\n" +
        "\x13OrderHistoryRequest\x12\"\n" +
        "\border_id\x18\x01 \x01(\x04B\a\xfaB\x042\x02 \x00R\aorderId\"F\n" +
        "\x14OrderHistoryResponse\x12.\n" +
        "\ahistory\x18\x01 \x03(\v2\x14.orders.OrderHistoryR\ahistory\"W\n" +
        "\rOrderResponse\x12+\n" +
        "\x06status\x18\x01 \x01(\x0e2\x13.orders.OrderStatusR\x06status\x12\x19\n" +
        "\border_id\x18\x02 \x01(\x04R\aorderId\"E\n" +
        "\rProcessResult\x12\x1c\n" +
        "\tprocessed\x18\x01 \x03(\x04R\tprocessed\x12\x16\n" +
        "\x06errors\x18\x02 \x03(\x04R\x06errors\"I\n" +
        "\n" +
        "OrdersList\x12%\n" +
        "\x06orders\x18\x01 \x03(\v2\r.orders.OrderR\x06orders\x12\x14\n" +
        "\x05total\x18\x02 \x01(\x05R\x05total\"6\n" +
        "\vReturnsList\x12'\n" +
        "\areturns\x18\x01 \x03(\v2\r.orders.OrderR\areturns\"B\n" +
        "\x10OrderHistoryList\x12.\n" +
        "\ahistory\x18\x01 \x03(\v2\x14.orders.OrderHistoryR\ahistory\"B\n" +
        "\fImportResult\x12\x1a\n" +
        "\bimported\x18\x01 \x01(\x05R\bimported\x12\x16\n" +
        "\x06errors\x18\x02 \x03(\x04R\x06errors\"\x9c\x02\n" +
        "\x05Order\x12\x19\n" +
        "\border_id\x18\x01 \x01(\x04R\aorderId\x12\x17\n" +
        "\auser_id\x18\x02 \x01(\x04R\x06userId\x12+\n" +
        "\x06status\x18\x03 \x01(\x0e2\x13.orders.OrderStatusR\x06status\x129\n" +
        "\n" +
        "expires_at\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\texpiresAt\x12\x16\n" +
        "\x06weight\x18\x05 \x01(\x02R\x06weight\x12\x1f\n" +
        "\vtotal_price\x18\x06 \x01(\x02R\n" +
        "totalPrice\x122\n" +
        "\apackage\x18\a \x01(\x0e2\x13.orders.PackageTypeH\x00R\apackage\x88\x01\x01B\n" +
        "\n" +
        "\b_package\"\x91\x01\n" +
        "\fOrderHistory\x12\x19\n" +
        "\border_id\x18\x01 \x01(\x04R\aorderId\x12+\n" +
        "\x06status\x18\x02 \x01(\x0e2\x13.orders.OrderStatusR\x06status\x129\n" +
        "\n" +
        "created_at\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt*X\n" +
        "\n" +
        "ActionType\x12\x1b\n" +
        "\x17ACTION_TYPE_UNSPECIFIED\x10\x00\x12\x15\n" +
        "\x11ACTION_TYPE_ISSUE\x10\x01\x12\x16\n" +
        "\x12ACTION_TYPE_RETURN\x10\x02*\xa4\x01\n" +
        "\vPackageType\x12\x1c\n" +
        "\x18PACKAGE_TYPE_UNSPECIFIED\x10\x00\x12\x14\n" +
        "\x10PACKAGE_TYPE_BAG\x10\x01\x12\x14\n" +
        "\x10PACKAGE_TYPE_BOX\x10\x02\x12\x15\n" +
        "\x11PACKAGE_TYPE_TAPE\x10\x03\x12\x19\n" +
        "\x15PACKAGE_TYPE_BAG_TAPE\x10\x04\x12\x19\n" +
        "\x15PACKAGE_TYPE_BOX_TAPE\x10\x05*\x95\x01\n" +
        "\vOrderStatus\x12\x1c\n" +
        "\x18ORDER_STATUS_UNSPECIFIED\x10\x00\x12\x18\n" +
        "\x14ORDER_STATUS_EXPECTS\x10\x01\x12\x19\n" +
        "\x15ORDER_STATUS_ACCEPTED\x10\x02\x12\x19\n" +
        "\x15ORDER_STATUS_RETURNED\x10\x03\x12\x18\n" +
        "\x14ORDER_STATUS_DELETED\x10\x042\xa0\x1b\n" +
        "\rOrdersService\x12\x90\x03\n" +
        "\vAcceptOrder\x12\x1a.orders.AcceptOrderRequest\x1a\x15.orders.OrderResponse\"\xcd\x02\x92A\xad\x02\x12-Принять заказ от курьера\x1a\xfb\x01Принимает заказ с указанным ID, ID получателя и сроком хранения. Заказ нельзя принять дважды. Если срок хранения в прошлом, выдается ошибка.\x82\xd3\xe4\x93\x02\x16:\x01*\"\x11/v1/orders/accept\x12\xc2\x03\n" +
        "\vReturnOrder\x12\x16.orders.OrderIdRequest\x1a\x15.orders.OrderResponse\"\x83\x03\x92A\xe3\x02\x12(Вернуть заказ курьеру\x1a\xb6\x02Возвращает заказ курьеру по указанному ID. Можно вернуть только заказы, которые не находятся у клиентов или у которых истек срок хранения. Заказ помечается как удаленный.\x82\xd3\xe4\x93\x02\x16:\x01*\"\x11/v1/orders/return\x12\xb0\x05\n" +
        "\rProcessOrders\x12\x1c.orders.ProcessOrdersRequest\x1a\x15.orders.ProcessResult\"\xe9\x04\x92A\xc8\x04\x12OВыдать заказы или принять возвраты клиента\x1a\xf4\x03Обрабатывает выдачу заказов или прием возвратов для указанного пользователя и списка заказов. Выдача возможна только для принятых заказов с неистекшим сроком хранения. Возврат возможен в течение двух суток с момента выдачи. Все заказы должны принадлежать одному клиенту.\x82\xd3\xe4\x93\x02\x17:\x01*\"\x12/v1/orders/process\x12\xb5\x03\n" +
        "\n" +
        "ListOrders\x12\x19.orders.ListOrdersRequest\x1a\x12.orders.OrdersList\"\xf7\x02\x92A\xd2\x02\x12,Получить список заказов\x1a\xa1\x02Возвращает список заказов для указанного пользователя. Поддерживает получение последних N заказов или заказов, находящихся в ПВЗ, с опциональной пагинацией.\x82\xd3\xe4\x93\x02\x1b\x12\x19/v1/orders/list/{user_id}\x12\xf5\x02\n" +
        "\vListReturns\x12\x1a.orders.ListReturnsRequest\x1a\x13.orders.ReturnsList\"\xb4\x02\x92A\x96\x02\x12AПолучить список возвратов клиентов\x1a\xd0\x01Возвращает список возвращенных заказов с постраничной пагинацией, отсортированный от свежих возвратов к старым.\x82\xd3\xe4\x93\x02\x14\x12\x12/v1/orders/returns\x12\xd1\x02\n" +
        "\n" +
        "GetHistory\x12\x19.orders.GetHistoryRequest\x1a\x18.orders.OrderHistoryList\"\x8d\x02\x92A\xef\x01\x12.Получить историю заказов\x1a\xbc\x01Возвращает историю изменений статуса всех заказов, отсортированную по времени последнего обновления.\x82\xd3\xe4\x93\x02\x14\x12\x12/v1/orders/history\x12\xa8\x02\n" +
        "\fImportOrders\x12\x1b.orders.ImportOrdersRequest\x1a\x14.orders.ImportResult\"\xe4\x01\x92A\xc4\x01\x12'Импортировать заказы\x1a\x98\x01Импортирует несколько заказов из предоставленного списка, валидируя каждый заказ.\x82\xd3\xe4\x93\x02\x16:\x01*\"\x11/v1/orders/import\x12\xd4\x03\n" +
        "\x0fGetOrderHistory\x12\x1b.orders.OrderHistoryRequest\x1a\x1c.orders.OrderHistoryResponse\"\x85\x03\x92A\xdc\x02\x12BПолучить историю статусов по заказу\x1a\x95\x02Возвращает историю изменений статуса для указанного заказа, отсортированную по убыванию времени изменения. Если заказ не найден, возвращается ошибка.\x82\xd3\xe4\x93\x02\x1f\x12\x1d/v1/orders/{order_id}/historyB\xf5\x01\x92A\xc3\x01\x12\x89\x01\n" +
        "\x12PVZ Orders Service\x12lAPI для управления заказами в системе пункта выдачи заказов.2\x051.0.0\x1a\x0elocalhost:8081*\x01\x012\x10application/json:\x10application/jsonZ,gitlab.ozon.dev/safariproxd/homework/pkg/apib\x06proto3"

var (
        file_orders_contract_proto_rawDescOnce sync.Once
        file_orders_contract_proto_rawDescData []byte
)

func file_orders_contract_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_orders_contract_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_orders_contract_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_orders_contract_proto_rawDesc), len(file_orders_contract_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_orders_contract_proto_rawDescData</span>
}

var file_orders_contract_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_orders_contract_proto_msgTypes = make([]protoimpl.MessageInfo, 18)
var file_orders_contract_proto_goTypes = []any{
        (ActionType)(0),               // 0: orders.ActionType
        (PackageType)(0),              // 1: orders.PackageType
        (OrderStatus)(0),              // 2: orders.OrderStatus
        (*AcceptOrderRequest)(nil),    // 3: orders.AcceptOrderRequest
        (*OrderIdRequest)(nil),        // 4: orders.OrderIdRequest
        (*ProcessOrdersRequest)(nil),  // 5: orders.ProcessOrdersRequest
        (*ListOrdersRequest)(nil),     // 6: orders.ListOrdersRequest
        (*Pagination)(nil),            // 7: orders.Pagination
        (*ListReturnsRequest)(nil),    // 8: orders.ListReturnsRequest
        (*ImportOrdersRequest)(nil),   // 9: orders.ImportOrdersRequest
        (*GetHistoryRequest)(nil),     // 10: orders.GetHistoryRequest
        (*OrderHistoryRequest)(nil),   // 11: orders.OrderHistoryRequest
        (*OrderHistoryResponse)(nil),  // 12: orders.OrderHistoryResponse
        (*OrderResponse)(nil),         // 13: orders.OrderResponse
        (*ProcessResult)(nil),         // 14: orders.ProcessResult
        (*OrdersList)(nil),            // 15: orders.OrdersList
        (*ReturnsList)(nil),           // 16: orders.ReturnsList
        (*OrderHistoryList)(nil),      // 17: orders.OrderHistoryList
        (*ImportResult)(nil),          // 18: orders.ImportResult
        (*Order)(nil),                 // 19: orders.Order
        (*OrderHistory)(nil),          // 20: orders.OrderHistory
        (*timestamppb.Timestamp)(nil), // 21: google.protobuf.Timestamp
}
var file_orders_contract_proto_depIdxs = []int32{
        21, // 0: orders.AcceptOrderRequest.expires_at:type_name -&gt; google.protobuf.Timestamp
        1,  // 1: orders.AcceptOrderRequest.package:type_name -&gt; orders.PackageType
        0,  // 2: orders.ProcessOrdersRequest.action:type_name -&gt; orders.ActionType
        7,  // 3: orders.ListOrdersRequest.pagination:type_name -&gt; orders.Pagination
        7,  // 4: orders.ListReturnsRequest.pagination:type_name -&gt; orders.Pagination
        3,  // 5: orders.ImportOrdersRequest.orders:type_name -&gt; orders.AcceptOrderRequest
        7,  // 6: orders.GetHistoryRequest.pagination:type_name -&gt; orders.Pagination
        20, // 7: orders.OrderHistoryResponse.history:type_name -&gt; orders.OrderHistory
        2,  // 8: orders.OrderResponse.status:type_name -&gt; orders.OrderStatus
        19, // 9: orders.OrdersList.orders:type_name -&gt; orders.Order
        19, // 10: orders.ReturnsList.returns:type_name -&gt; orders.Order
        20, // 11: orders.OrderHistoryList.history:type_name -&gt; orders.OrderHistory
        2,  // 12: orders.Order.status:type_name -&gt; orders.OrderStatus
        21, // 13: orders.Order.expires_at:type_name -&gt; google.protobuf.Timestamp
        1,  // 14: orders.Order.package:type_name -&gt; orders.PackageType
        2,  // 15: orders.OrderHistory.status:type_name -&gt; orders.OrderStatus
        21, // 16: orders.OrderHistory.created_at:type_name -&gt; google.protobuf.Timestamp
        3,  // 17: orders.OrdersService.AcceptOrder:input_type -&gt; orders.AcceptOrderRequest
        4,  // 18: orders.OrdersService.ReturnOrder:input_type -&gt; orders.OrderIdRequest
        5,  // 19: orders.OrdersService.ProcessOrders:input_type -&gt; orders.ProcessOrdersRequest
        6,  // 20: orders.OrdersService.ListOrders:input_type -&gt; orders.ListOrdersRequest
        8,  // 21: orders.OrdersService.ListReturns:input_type -&gt; orders.ListReturnsRequest
        10, // 22: orders.OrdersService.GetHistory:input_type -&gt; orders.GetHistoryRequest
        9,  // 23: orders.OrdersService.ImportOrders:input_type -&gt; orders.ImportOrdersRequest
        11, // 24: orders.OrdersService.GetOrderHistory:input_type -&gt; orders.OrderHistoryRequest
        13, // 25: orders.OrdersService.AcceptOrder:output_type -&gt; orders.OrderResponse
        13, // 26: orders.OrdersService.ReturnOrder:output_type -&gt; orders.OrderResponse
        14, // 27: orders.OrdersService.ProcessOrders:output_type -&gt; orders.ProcessResult
        15, // 28: orders.OrdersService.ListOrders:output_type -&gt; orders.OrdersList
        16, // 29: orders.OrdersService.ListReturns:output_type -&gt; orders.ReturnsList
        17, // 30: orders.OrdersService.GetHistory:output_type -&gt; orders.OrderHistoryList
        18, // 31: orders.OrdersService.ImportOrders:output_type -&gt; orders.ImportResult
        12, // 32: orders.OrdersService.GetOrderHistory:output_type -&gt; orders.OrderHistoryResponse
        25, // [25:33] is the sub-list for method output_type
        17, // [17:25] is the sub-list for method input_type
        17, // [17:17] is the sub-list for extension type_name
        17, // [17:17] is the sub-list for extension extendee
        0,  // [0:17] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_orders_contract_proto_init() }</span>
func file_orders_contract_proto_init() <span class="cov0" title="0">{
        if File_orders_contract_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">file_orders_contract_proto_msgTypes[0].OneofWrappers = []any{}
        file_orders_contract_proto_msgTypes[3].OneofWrappers = []any{}
        file_orders_contract_proto_msgTypes[16].OneofWrappers = []any{}
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_orders_contract_proto_rawDesc), len(file_orders_contract_proto_rawDesc)),
                        NumEnums:      3,
                        NumMessages:   18,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_orders_contract_proto_goTypes,
                DependencyIndexes: file_orders_contract_proto_depIdxs,
                EnumInfos:         file_orders_contract_proto_enumTypes,
                MessageInfos:      file_orders_contract_proto_msgTypes,
        }.Build()
        File_orders_contract_proto = out.File
        file_orders_contract_proto_goTypes = nil
        file_orders_contract_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">// Code generated by protoc-gen-grpc-gateway. DO NOT EDIT.
// source: orders/contract.proto

/*
Package api is a reverse proxy.

It translates gRPC into RESTful JSON APIs.
*/
package api

import (
        "context"
        "errors"
        "io"
        "net/http"

        "github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
        "github.com/grpc-ecosystem/grpc-gateway/v2/utilities"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/grpclog"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/proto"
)

// Suppress "imported and not used" errors
var (
        _ codes.Code
        _ io.Reader
        _ status.Status
        _ = errors.New
        _ = runtime.String
        _ = utilities.NewDoubleArray
        _ = metadata.Join
)

func request_OrdersService_AcceptOrder_0(ctx context.Context, marshaler runtime.Marshaler, client OrdersServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var (
                protoReq AcceptOrderRequest
                metadata runtime.ServerMetadata
        )
        if err := marshaler.NewDecoder(req.Body).Decode(&amp;protoReq); err != nil &amp;&amp; !errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">msg, err := client.AcceptOrder(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>
}

func local_request_OrdersService_AcceptOrder_0(ctx context.Context, marshaler runtime.Marshaler, server OrdersServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var (
                protoReq AcceptOrderRequest
                metadata runtime.ServerMetadata
        )
        if err := marshaler.NewDecoder(req.Body).Decode(&amp;protoReq); err != nil &amp;&amp; !errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">msg, err := server.AcceptOrder(ctx, &amp;protoReq)
        return msg, metadata, err</span>
}

func request_OrdersService_ReturnOrder_0(ctx context.Context, marshaler runtime.Marshaler, client OrdersServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var (
                protoReq OrderIdRequest
                metadata runtime.ServerMetadata
        )
        if err := marshaler.NewDecoder(req.Body).Decode(&amp;protoReq); err != nil &amp;&amp; !errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">msg, err := client.ReturnOrder(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>
}

func local_request_OrdersService_ReturnOrder_0(ctx context.Context, marshaler runtime.Marshaler, server OrdersServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var (
                protoReq OrderIdRequest
                metadata runtime.ServerMetadata
        )
        if err := marshaler.NewDecoder(req.Body).Decode(&amp;protoReq); err != nil &amp;&amp; !errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">msg, err := server.ReturnOrder(ctx, &amp;protoReq)
        return msg, metadata, err</span>
}

func request_OrdersService_ProcessOrders_0(ctx context.Context, marshaler runtime.Marshaler, client OrdersServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var (
                protoReq ProcessOrdersRequest
                metadata runtime.ServerMetadata
        )
        if err := marshaler.NewDecoder(req.Body).Decode(&amp;protoReq); err != nil &amp;&amp; !errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">msg, err := client.ProcessOrders(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>
}

func local_request_OrdersService_ProcessOrders_0(ctx context.Context, marshaler runtime.Marshaler, server OrdersServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var (
                protoReq ProcessOrdersRequest
                metadata runtime.ServerMetadata
        )
        if err := marshaler.NewDecoder(req.Body).Decode(&amp;protoReq); err != nil &amp;&amp; !errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">msg, err := server.ProcessOrders(ctx, &amp;protoReq)
        return msg, metadata, err</span>
}

var filter_OrdersService_ListOrders_0 = &amp;utilities.DoubleArray{Encoding: map[string]int{"user_id": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

func request_OrdersService_ListOrders_0(ctx context.Context, marshaler runtime.Marshaler, client OrdersServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var (
                protoReq ListOrdersRequest
                metadata runtime.ServerMetadata
                err      error
        )
        io.Copy(io.Discard, req.Body)
        val, ok := pathParams["user_id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "user_id")
        }</span>
        <span class="cov0" title="0">protoReq.UserId, err = runtime.Uint64(val)
        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "user_id", err)
        }</span>
        <span class="cov0" title="0">if err := req.ParseForm(); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">if err := runtime.PopulateQueryParameters(&amp;protoReq, req.Form, filter_OrdersService_ListOrders_0); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">msg, err := client.ListOrders(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>
}

func local_request_OrdersService_ListOrders_0(ctx context.Context, marshaler runtime.Marshaler, server OrdersServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var (
                protoReq ListOrdersRequest
                metadata runtime.ServerMetadata
                err      error
        )
        val, ok := pathParams["user_id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "user_id")
        }</span>
        <span class="cov0" title="0">protoReq.UserId, err = runtime.Uint64(val)
        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "user_id", err)
        }</span>
        <span class="cov0" title="0">if err := req.ParseForm(); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">if err := runtime.PopulateQueryParameters(&amp;protoReq, req.Form, filter_OrdersService_ListOrders_0); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">msg, err := server.ListOrders(ctx, &amp;protoReq)
        return msg, metadata, err</span>
}

var filter_OrdersService_ListReturns_0 = &amp;utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

func request_OrdersService_ListReturns_0(ctx context.Context, marshaler runtime.Marshaler, client OrdersServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var (
                protoReq ListReturnsRequest
                metadata runtime.ServerMetadata
        )
        io.Copy(io.Discard, req.Body)
        if err := req.ParseForm(); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">if err := runtime.PopulateQueryParameters(&amp;protoReq, req.Form, filter_OrdersService_ListReturns_0); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">msg, err := client.ListReturns(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>
}

func local_request_OrdersService_ListReturns_0(ctx context.Context, marshaler runtime.Marshaler, server OrdersServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var (
                protoReq ListReturnsRequest
                metadata runtime.ServerMetadata
        )
        if err := req.ParseForm(); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">if err := runtime.PopulateQueryParameters(&amp;protoReq, req.Form, filter_OrdersService_ListReturns_0); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">msg, err := server.ListReturns(ctx, &amp;protoReq)
        return msg, metadata, err</span>
}

var filter_OrdersService_GetHistory_0 = &amp;utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

func request_OrdersService_GetHistory_0(ctx context.Context, marshaler runtime.Marshaler, client OrdersServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var (
                protoReq GetHistoryRequest
                metadata runtime.ServerMetadata
        )
        io.Copy(io.Discard, req.Body)
        if err := req.ParseForm(); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">if err := runtime.PopulateQueryParameters(&amp;protoReq, req.Form, filter_OrdersService_GetHistory_0); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">msg, err := client.GetHistory(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>
}

func local_request_OrdersService_GetHistory_0(ctx context.Context, marshaler runtime.Marshaler, server OrdersServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var (
                protoReq GetHistoryRequest
                metadata runtime.ServerMetadata
        )
        if err := req.ParseForm(); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">if err := runtime.PopulateQueryParameters(&amp;protoReq, req.Form, filter_OrdersService_GetHistory_0); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">msg, err := server.GetHistory(ctx, &amp;protoReq)
        return msg, metadata, err</span>
}

func request_OrdersService_ImportOrders_0(ctx context.Context, marshaler runtime.Marshaler, client OrdersServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var (
                protoReq ImportOrdersRequest
                metadata runtime.ServerMetadata
        )
        if err := marshaler.NewDecoder(req.Body).Decode(&amp;protoReq); err != nil &amp;&amp; !errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">msg, err := client.ImportOrders(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>
}

func local_request_OrdersService_ImportOrders_0(ctx context.Context, marshaler runtime.Marshaler, server OrdersServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var (
                protoReq ImportOrdersRequest
                metadata runtime.ServerMetadata
        )
        if err := marshaler.NewDecoder(req.Body).Decode(&amp;protoReq); err != nil &amp;&amp; !errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">msg, err := server.ImportOrders(ctx, &amp;protoReq)
        return msg, metadata, err</span>
}

func request_OrdersService_GetOrderHistory_0(ctx context.Context, marshaler runtime.Marshaler, client OrdersServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var (
                protoReq OrderHistoryRequest
                metadata runtime.ServerMetadata
                err      error
        )
        io.Copy(io.Discard, req.Body)
        val, ok := pathParams["order_id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "order_id")
        }</span>
        <span class="cov0" title="0">protoReq.OrderId, err = runtime.Uint64(val)
        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "order_id", err)
        }</span>
        <span class="cov0" title="0">msg, err := client.GetOrderHistory(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>
}

func local_request_OrdersService_GetOrderHistory_0(ctx context.Context, marshaler runtime.Marshaler, server OrdersServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var (
                protoReq OrderHistoryRequest
                metadata runtime.ServerMetadata
                err      error
        )
        val, ok := pathParams["order_id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "order_id")
        }</span>
        <span class="cov0" title="0">protoReq.OrderId, err = runtime.Uint64(val)
        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "order_id", err)
        }</span>
        <span class="cov0" title="0">msg, err := server.GetOrderHistory(ctx, &amp;protoReq)
        return msg, metadata, err</span>
}

// RegisterOrdersServiceHandlerServer registers the http handlers for service OrdersService to "mux".
// UnaryRPC     :call OrdersServiceServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterOrdersServiceHandlerFromEndpoint instead.
// GRPC interceptors will not work for this type of registration. To use interceptors, you must use the "runtime.WithMiddlewares" option in the "runtime.NewServeMux" call.
func RegisterOrdersServiceHandlerServer(ctx context.Context, mux *runtime.ServeMux, server OrdersServiceServer) error <span class="cov0" title="0">{
        mux.Handle(http.MethodPost, pattern_OrdersService_AcceptOrder_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                annotatedContext, err := runtime.AnnotateIncomingContext(ctx, mux, req, "/orders.OrdersService/AcceptOrder", runtime.WithHTTPPathPattern("/v1/orders/accept"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_OrdersService_AcceptOrder_0(annotatedContext, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">forward_OrdersService_AcceptOrder_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>
        })
        <span class="cov0" title="0">mux.Handle(http.MethodPost, pattern_OrdersService_ReturnOrder_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                annotatedContext, err := runtime.AnnotateIncomingContext(ctx, mux, req, "/orders.OrdersService/ReturnOrder", runtime.WithHTTPPathPattern("/v1/orders/return"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_OrdersService_ReturnOrder_0(annotatedContext, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">forward_OrdersService_ReturnOrder_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>
        })
        <span class="cov0" title="0">mux.Handle(http.MethodPost, pattern_OrdersService_ProcessOrders_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                annotatedContext, err := runtime.AnnotateIncomingContext(ctx, mux, req, "/orders.OrdersService/ProcessOrders", runtime.WithHTTPPathPattern("/v1/orders/process"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_OrdersService_ProcessOrders_0(annotatedContext, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">forward_OrdersService_ProcessOrders_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>
        })
        <span class="cov0" title="0">mux.Handle(http.MethodGet, pattern_OrdersService_ListOrders_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                annotatedContext, err := runtime.AnnotateIncomingContext(ctx, mux, req, "/orders.OrdersService/ListOrders", runtime.WithHTTPPathPattern("/v1/orders/list/{user_id}"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_OrdersService_ListOrders_0(annotatedContext, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">forward_OrdersService_ListOrders_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>
        })
        <span class="cov0" title="0">mux.Handle(http.MethodGet, pattern_OrdersService_ListReturns_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                annotatedContext, err := runtime.AnnotateIncomingContext(ctx, mux, req, "/orders.OrdersService/ListReturns", runtime.WithHTTPPathPattern("/v1/orders/returns"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_OrdersService_ListReturns_0(annotatedContext, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">forward_OrdersService_ListReturns_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>
        })
        <span class="cov0" title="0">mux.Handle(http.MethodGet, pattern_OrdersService_GetHistory_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                annotatedContext, err := runtime.AnnotateIncomingContext(ctx, mux, req, "/orders.OrdersService/GetHistory", runtime.WithHTTPPathPattern("/v1/orders/history"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_OrdersService_GetHistory_0(annotatedContext, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">forward_OrdersService_GetHistory_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>
        })
        <span class="cov0" title="0">mux.Handle(http.MethodPost, pattern_OrdersService_ImportOrders_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                annotatedContext, err := runtime.AnnotateIncomingContext(ctx, mux, req, "/orders.OrdersService/ImportOrders", runtime.WithHTTPPathPattern("/v1/orders/import"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_OrdersService_ImportOrders_0(annotatedContext, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">forward_OrdersService_ImportOrders_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>
        })
        <span class="cov0" title="0">mux.Handle(http.MethodGet, pattern_OrdersService_GetOrderHistory_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                annotatedContext, err := runtime.AnnotateIncomingContext(ctx, mux, req, "/orders.OrdersService/GetOrderHistory", runtime.WithHTTPPathPattern("/v1/orders/{order_id}/history"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_OrdersService_GetOrderHistory_0(annotatedContext, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">forward_OrdersService_GetOrderHistory_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>
        })

        <span class="cov0" title="0">return nil</span>
}

// RegisterOrdersServiceHandlerFromEndpoint is same as RegisterOrdersServiceHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterOrdersServiceHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) <span class="cov0" title="0">{
        conn, err := grpc.NewClient(endpoint, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                grpclog.Errorf("Failed to close conn to %s: %v", endpoint, cerr)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                        &lt;-ctx.Done()
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                grpclog.Errorf("Failed to close conn to %s: %v", endpoint, cerr)
                        }</span>
                }()
        }()
        <span class="cov0" title="0">return RegisterOrdersServiceHandler(ctx, mux, conn)</span>
}

// RegisterOrdersServiceHandler registers the http handlers for service OrdersService to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterOrdersServiceHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error <span class="cov0" title="0">{
        return RegisterOrdersServiceHandlerClient(ctx, mux, NewOrdersServiceClient(conn))
}</span>

// RegisterOrdersServiceHandlerClient registers the http handlers for service OrdersService
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "OrdersServiceClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "OrdersServiceClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "OrdersServiceClient" to call the correct interceptors. This client ignores the HTTP middlewares.
func RegisterOrdersServiceHandlerClient(ctx context.Context, mux *runtime.ServeMux, client OrdersServiceClient) error <span class="cov0" title="0">{
        mux.Handle(http.MethodPost, pattern_OrdersService_AcceptOrder_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                annotatedContext, err := runtime.AnnotateContext(ctx, mux, req, "/orders.OrdersService/AcceptOrder", runtime.WithHTTPPathPattern("/v1/orders/accept"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_OrdersService_AcceptOrder_0(annotatedContext, inboundMarshaler, client, req, pathParams)
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">forward_OrdersService_AcceptOrder_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>
        })
        <span class="cov0" title="0">mux.Handle(http.MethodPost, pattern_OrdersService_ReturnOrder_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                annotatedContext, err := runtime.AnnotateContext(ctx, mux, req, "/orders.OrdersService/ReturnOrder", runtime.WithHTTPPathPattern("/v1/orders/return"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_OrdersService_ReturnOrder_0(annotatedContext, inboundMarshaler, client, req, pathParams)
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">forward_OrdersService_ReturnOrder_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>
        })
        <span class="cov0" title="0">mux.Handle(http.MethodPost, pattern_OrdersService_ProcessOrders_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                annotatedContext, err := runtime.AnnotateContext(ctx, mux, req, "/orders.OrdersService/ProcessOrders", runtime.WithHTTPPathPattern("/v1/orders/process"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_OrdersService_ProcessOrders_0(annotatedContext, inboundMarshaler, client, req, pathParams)
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">forward_OrdersService_ProcessOrders_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>
        })
        <span class="cov0" title="0">mux.Handle(http.MethodGet, pattern_OrdersService_ListOrders_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                annotatedContext, err := runtime.AnnotateContext(ctx, mux, req, "/orders.OrdersService/ListOrders", runtime.WithHTTPPathPattern("/v1/orders/list/{user_id}"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_OrdersService_ListOrders_0(annotatedContext, inboundMarshaler, client, req, pathParams)
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">forward_OrdersService_ListOrders_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>
        })
        <span class="cov0" title="0">mux.Handle(http.MethodGet, pattern_OrdersService_ListReturns_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                annotatedContext, err := runtime.AnnotateContext(ctx, mux, req, "/orders.OrdersService/ListReturns", runtime.WithHTTPPathPattern("/v1/orders/returns"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_OrdersService_ListReturns_0(annotatedContext, inboundMarshaler, client, req, pathParams)
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">forward_OrdersService_ListReturns_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>
        })
        <span class="cov0" title="0">mux.Handle(http.MethodGet, pattern_OrdersService_GetHistory_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                annotatedContext, err := runtime.AnnotateContext(ctx, mux, req, "/orders.OrdersService/GetHistory", runtime.WithHTTPPathPattern("/v1/orders/history"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_OrdersService_GetHistory_0(annotatedContext, inboundMarshaler, client, req, pathParams)
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">forward_OrdersService_GetHistory_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>
        })
        <span class="cov0" title="0">mux.Handle(http.MethodPost, pattern_OrdersService_ImportOrders_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                annotatedContext, err := runtime.AnnotateContext(ctx, mux, req, "/orders.OrdersService/ImportOrders", runtime.WithHTTPPathPattern("/v1/orders/import"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_OrdersService_ImportOrders_0(annotatedContext, inboundMarshaler, client, req, pathParams)
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">forward_OrdersService_ImportOrders_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>
        })
        <span class="cov0" title="0">mux.Handle(http.MethodGet, pattern_OrdersService_GetOrderHistory_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                annotatedContext, err := runtime.AnnotateContext(ctx, mux, req, "/orders.OrdersService/GetOrderHistory", runtime.WithHTTPPathPattern("/v1/orders/{order_id}/history"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_OrdersService_GetOrderHistory_0(annotatedContext, inboundMarshaler, client, req, pathParams)
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">forward_OrdersService_GetOrderHistory_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>
        })
        <span class="cov0" title="0">return nil</span>
}

var (
        pattern_OrdersService_AcceptOrder_0     = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"v1", "orders", "accept"}, ""))
        pattern_OrdersService_ReturnOrder_0     = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"v1", "orders", "return"}, ""))
        pattern_OrdersService_ProcessOrders_0   = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"v1", "orders", "process"}, ""))
        pattern_OrdersService_ListOrders_0      = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3}, []string{"v1", "orders", "list", "user_id"}, ""))
        pattern_OrdersService_ListReturns_0     = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"v1", "orders", "returns"}, ""))
        pattern_OrdersService_GetHistory_0      = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"v1", "orders", "history"}, ""))
        pattern_OrdersService_ImportOrders_0    = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"v1", "orders", "import"}, ""))
        pattern_OrdersService_GetOrderHistory_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 4, 1, 5, 2, 2, 3}, []string{"v1", "orders", "order_id", "history"}, ""))
)

var (
        forward_OrdersService_AcceptOrder_0     = runtime.ForwardResponseMessage
        forward_OrdersService_ReturnOrder_0     = runtime.ForwardResponseMessage
        forward_OrdersService_ProcessOrders_0   = runtime.ForwardResponseMessage
        forward_OrdersService_ListOrders_0      = runtime.ForwardResponseMessage
        forward_OrdersService_ListReturns_0     = runtime.ForwardResponseMessage
        forward_OrdersService_GetHistory_0      = runtime.ForwardResponseMessage
        forward_OrdersService_ImportOrders_0    = runtime.ForwardResponseMessage
        forward_OrdersService_GetOrderHistory_0 = runtime.ForwardResponseMessage
)
</pre>
		
		<pre class="file" id="file36" style="display: none">// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: orders/contract.proto

package api

import (
        "bytes"
        "errors"
        "fmt"
        "net"
        "net/mail"
        "net/url"
        "regexp"
        "sort"
        "strings"
        "time"
        "unicode/utf8"

        "google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
        _ = bytes.MinRead
        _ = errors.New("")
        _ = fmt.Print
        _ = utf8.UTFMax
        _ = (*regexp.Regexp)(nil)
        _ = (*strings.Reader)(nil)
        _ = net.IPv4len
        _ = time.Duration(0)
        _ = (*url.URL)(nil)
        _ = (*mail.Address)(nil)
        _ = anypb.Any{}
        _ = sort.Sort
)

// Validate checks the field values on AcceptOrderRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AcceptOrderRequest) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on AcceptOrderRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AcceptOrderRequestMultiError, or nil if none found.
func (m *AcceptOrderRequest) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *AcceptOrderRequest) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if m.GetOrderId() &lt;= 0 </span><span class="cov0" title="0">{
                err := AcceptOrderRequestValidationError{
                        field:  "OrderId",
                        reason: "value must be greater than 0",
                }
                if !all </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">errors = append(errors, err)</span>
        }

        <span class="cov0" title="0">if m.GetUserId() &lt;= 0 </span><span class="cov0" title="0">{
                err := AcceptOrderRequestValidationError{
                        field:  "UserId",
                        reason: "value must be greater than 0",
                }
                if !all </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">errors = append(errors, err)</span>
        }

        <span class="cov0" title="0">if m.GetExpiresAt() == nil </span><span class="cov0" title="0">{
                err := AcceptOrderRequestValidationError{
                        field:  "ExpiresAt",
                        reason: "value is required",
                }
                if !all </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">errors = append(errors, err)</span>
        }

        <span class="cov0" title="0">if t := m.GetExpiresAt(); t != nil </span><span class="cov0" title="0">{
                ts, err := t.AsTime(), t.CheckValid()
                if err != nil </span><span class="cov0" title="0">{
                        err = AcceptOrderRequestValidationError{
                                field:  "ExpiresAt",
                                reason: "value is not a valid timestamp",
                                cause:  err,
                        }
                        if !all </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">errors = append(errors, err)</span>
                } else<span class="cov0" title="0"> {

                        now := time.Now()

                        if ts.Sub(now) &lt;= 0 </span><span class="cov0" title="0">{
                                err := AcceptOrderRequestValidationError{
                                        field:  "ExpiresAt",
                                        reason: "value must be greater than now",
                                }
                                if !all </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">errors = append(errors, err)</span>
                        }

                }
        }

        <span class="cov0" title="0">if m.GetWeight() &lt;= 0 </span><span class="cov0" title="0">{
                err := AcceptOrderRequestValidationError{
                        field:  "Weight",
                        reason: "value must be greater than 0",
                }
                if !all </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">errors = append(errors, err)</span>
        }

        <span class="cov0" title="0">if m.GetPrice() &lt;= 0 </span><span class="cov0" title="0">{
                err := AcceptOrderRequestValidationError{
                        field:  "Price",
                        reason: "value must be greater than 0",
                }
                if !all </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">errors = append(errors, err)</span>
        }

        <span class="cov0" title="0">if m.Package != nil </span>{<span class="cov0" title="0">
                // no validation rules for Package
        }</span>

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return AcceptOrderRequestMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// AcceptOrderRequestMultiError is an error wrapping multiple validation errors
// returned by AcceptOrderRequest.ValidateAll() if the designated constraints
// aren't met.
type AcceptOrderRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AcceptOrderRequestMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m AcceptOrderRequestMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// AcceptOrderRequestValidationError is the validation error returned by
// AcceptOrderRequest.Validate if the designated constraints aren't met.
type AcceptOrderRequestValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e AcceptOrderRequestValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e AcceptOrderRequestValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e AcceptOrderRequestValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e AcceptOrderRequestValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e AcceptOrderRequestValidationError) ErrorName() string <span class="cov0" title="0">{
        return "AcceptOrderRequestValidationError"
}</span>

// Error satisfies the builtin error interface
func (e AcceptOrderRequestValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sAcceptOrderRequest.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = AcceptOrderRequestValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = AcceptOrderRequestValidationError{}

// Validate checks the field values on OrderIdRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OrderIdRequest) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on OrderIdRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OrderIdRequestMultiError,
// or nil if none found.
func (m *OrderIdRequest) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *OrderIdRequest) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if m.GetOrderId() &lt;= 0 </span><span class="cov0" title="0">{
                err := OrderIdRequestValidationError{
                        field:  "OrderId",
                        reason: "value must be greater than 0",
                }
                if !all </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">errors = append(errors, err)</span>
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return OrderIdRequestMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// OrderIdRequestMultiError is an error wrapping multiple validation errors
// returned by OrderIdRequest.ValidateAll() if the designated constraints
// aren't met.
type OrderIdRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderIdRequestMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m OrderIdRequestMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// OrderIdRequestValidationError is the validation error returned by
// OrderIdRequest.Validate if the designated constraints aren't met.
type OrderIdRequestValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e OrderIdRequestValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e OrderIdRequestValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e OrderIdRequestValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e OrderIdRequestValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e OrderIdRequestValidationError) ErrorName() string <span class="cov0" title="0">{ return "OrderIdRequestValidationError" }</span>

// Error satisfies the builtin error interface
func (e OrderIdRequestValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sOrderIdRequest.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = OrderIdRequestValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = OrderIdRequestValidationError{}

// Validate checks the field values on ProcessOrdersRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProcessOrdersRequest) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on ProcessOrdersRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProcessOrdersRequestMultiError, or nil if none found.
func (m *ProcessOrdersRequest) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *ProcessOrdersRequest) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if m.GetUserId() &lt;= 0 </span><span class="cov0" title="0">{
                err := ProcessOrdersRequestValidationError{
                        field:  "UserId",
                        reason: "value must be greater than 0",
                }
                if !all </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">errors = append(errors, err)</span>
        }

        <span class="cov0" title="0">if _, ok := _ProcessOrdersRequest_Action_NotInLookup[m.GetAction()]; ok </span><span class="cov0" title="0">{
                err := ProcessOrdersRequestValidationError{
                        field:  "Action",
                        reason: "value must not be in list [ACTION_TYPE_UNSPECIFIED]",
                }
                if !all </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">errors = append(errors, err)</span>
        }

        <span class="cov0" title="0">if _, ok := ActionType_name[int32(m.GetAction())]; !ok </span><span class="cov0" title="0">{
                err := ProcessOrdersRequestValidationError{
                        field:  "Action",
                        reason: "value must be one of the defined enum values",
                }
                if !all </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">errors = append(errors, err)</span>
        }

        <span class="cov0" title="0">if len(m.GetOrderIds()) &lt; 1 </span><span class="cov0" title="0">{
                err := ProcessOrdersRequestValidationError{
                        field:  "OrderIds",
                        reason: "value must contain at least 1 item(s)",
                }
                if !all </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">errors = append(errors, err)</span>
        }

        <span class="cov0" title="0">for idx, item := range m.GetOrderIds() </span><span class="cov0" title="0">{
                _, _ = idx, item

                if item &lt;= 0 </span><span class="cov0" title="0">{
                        err := ProcessOrdersRequestValidationError{
                                field:  fmt.Sprintf("OrderIds[%v]", idx),
                                reason: "value must be greater than 0",
                        }
                        if !all </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">errors = append(errors, err)</span>
                }

        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return ProcessOrdersRequestMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ProcessOrdersRequestMultiError is an error wrapping multiple validation
// errors returned by ProcessOrdersRequest.ValidateAll() if the designated
// constraints aren't met.
type ProcessOrdersRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProcessOrdersRequestMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m ProcessOrdersRequestMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// ProcessOrdersRequestValidationError is the validation error returned by
// ProcessOrdersRequest.Validate if the designated constraints aren't met.
type ProcessOrdersRequestValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e ProcessOrdersRequestValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e ProcessOrdersRequestValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e ProcessOrdersRequestValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e ProcessOrdersRequestValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e ProcessOrdersRequestValidationError) ErrorName() string <span class="cov0" title="0">{
        return "ProcessOrdersRequestValidationError"
}</span>

// Error satisfies the builtin error interface
func (e ProcessOrdersRequestValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sProcessOrdersRequest.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = ProcessOrdersRequestValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = ProcessOrdersRequestValidationError{}

var _ProcessOrdersRequest_Action_NotInLookup = map[ActionType]struct{}{
        0: {},
}

// Validate checks the field values on ListOrdersRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListOrdersRequest) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on ListOrdersRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListOrdersRequestMultiError, or nil if none found.
func (m *ListOrdersRequest) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *ListOrdersRequest) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if m.GetUserId() &lt;= 0 </span><span class="cov0" title="0">{
                err := ListOrdersRequestValidationError{
                        field:  "UserId",
                        reason: "value must be greater than 0",
                }
                if !all </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">errors = append(errors, err)</span>
        }

        // no validation rules for InPvz

        <span class="cov0" title="0">if m.LastN != nil </span><span class="cov0" title="0">{

                if m.GetLastN() &lt;= 0 </span><span class="cov0" title="0">{
                        err := ListOrdersRequestValidationError{
                                field:  "LastN",
                                reason: "value must be greater than 0",
                        }
                        if !all </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">errors = append(errors, err)</span>
                }

        }

        <span class="cov0" title="0">if m.Pagination != nil </span><span class="cov0" title="0">{

                if all </span><span class="cov0" title="0">{
                        switch v := interface{}(m.GetPagination()).(type) </span>{
                        case interface{ ValidateAll() error }:<span class="cov0" title="0">
                                if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, ListOrdersRequestValidationError{
                                                field:  "Pagination",
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        case interface{ Validate() error }:<span class="cov0" title="0">
                                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, ListOrdersRequestValidationError{
                                                field:  "Pagination",
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        }
                } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                return ListOrdersRequestValidationError{
                                        field:  "Pagination",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                }
                        }</span>
                }

        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return ListOrdersRequestMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ListOrdersRequestMultiError is an error wrapping multiple validation errors
// returned by ListOrdersRequest.ValidateAll() if the designated constraints
// aren't met.
type ListOrdersRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListOrdersRequestMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m ListOrdersRequestMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// ListOrdersRequestValidationError is the validation error returned by
// ListOrdersRequest.Validate if the designated constraints aren't met.
type ListOrdersRequestValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e ListOrdersRequestValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e ListOrdersRequestValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e ListOrdersRequestValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e ListOrdersRequestValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e ListOrdersRequestValidationError) ErrorName() string <span class="cov0" title="0">{
        return "ListOrdersRequestValidationError"
}</span>

// Error satisfies the builtin error interface
func (e ListOrdersRequestValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sListOrdersRequest.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = ListOrdersRequestValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = ListOrdersRequestValidationError{}

// Validate checks the field values on Pagination with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Pagination) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on Pagination with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PaginationMultiError, or
// nil if none found.
func (m *Pagination) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *Pagination) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if m.GetPage() &lt; 0 </span><span class="cov0" title="0">{
                err := PaginationValidationError{
                        field:  "Page",
                        reason: "value must be greater than or equal to 0",
                }
                if !all </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">errors = append(errors, err)</span>
        }

        <span class="cov0" title="0">if m.GetCountOnPage() &lt;= 0 </span><span class="cov0" title="0">{
                err := PaginationValidationError{
                        field:  "CountOnPage",
                        reason: "value must be greater than 0",
                }
                if !all </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">errors = append(errors, err)</span>
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return PaginationMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// PaginationMultiError is an error wrapping multiple validation errors
// returned by Pagination.ValidateAll() if the designated constraints aren't met.
type PaginationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PaginationMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m PaginationMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// PaginationValidationError is the validation error returned by
// Pagination.Validate if the designated constraints aren't met.
type PaginationValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e PaginationValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e PaginationValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e PaginationValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e PaginationValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e PaginationValidationError) ErrorName() string <span class="cov0" title="0">{ return "PaginationValidationError" }</span>

// Error satisfies the builtin error interface
func (e PaginationValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sPagination.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = PaginationValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = PaginationValidationError{}

// Validate checks the field values on ListReturnsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListReturnsRequest) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on ListReturnsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListReturnsRequestMultiError, or nil if none found.
func (m *ListReturnsRequest) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *ListReturnsRequest) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if all </span><span class="cov0" title="0">{
                switch v := interface{}(m.GetPagination()).(type) </span>{
                case interface{ ValidateAll() error }:<span class="cov0" title="0">
                        if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, ListReturnsRequestValidationError{
                                        field:  "Pagination",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                case interface{ Validate() error }:<span class="cov0" title="0">
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, ListReturnsRequestValidationError{
                                        field:  "Pagination",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                }
        } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                        return ListReturnsRequestValidationError{
                                field:  "Pagination",
                                reason: "embedded message failed validation",
                                cause:  err,
                        }
                }</span>
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return ListReturnsRequestMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ListReturnsRequestMultiError is an error wrapping multiple validation errors
// returned by ListReturnsRequest.ValidateAll() if the designated constraints
// aren't met.
type ListReturnsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListReturnsRequestMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m ListReturnsRequestMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// ListReturnsRequestValidationError is the validation error returned by
// ListReturnsRequest.Validate if the designated constraints aren't met.
type ListReturnsRequestValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e ListReturnsRequestValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e ListReturnsRequestValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e ListReturnsRequestValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e ListReturnsRequestValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e ListReturnsRequestValidationError) ErrorName() string <span class="cov0" title="0">{
        return "ListReturnsRequestValidationError"
}</span>

// Error satisfies the builtin error interface
func (e ListReturnsRequestValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sListReturnsRequest.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = ListReturnsRequestValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = ListReturnsRequestValidationError{}

// Validate checks the field values on ImportOrdersRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ImportOrdersRequest) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on ImportOrdersRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportOrdersRequestMultiError, or nil if none found.
func (m *ImportOrdersRequest) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *ImportOrdersRequest) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if len(m.GetOrders()) &lt; 1 </span><span class="cov0" title="0">{
                err := ImportOrdersRequestValidationError{
                        field:  "Orders",
                        reason: "value must contain at least 1 item(s)",
                }
                if !all </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">errors = append(errors, err)</span>
        }

        <span class="cov0" title="0">for idx, item := range m.GetOrders() </span><span class="cov0" title="0">{
                _, _ = idx, item

                if all </span><span class="cov0" title="0">{
                        switch v := interface{}(item).(type) </span>{
                        case interface{ ValidateAll() error }:<span class="cov0" title="0">
                                if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, ImportOrdersRequestValidationError{
                                                field:  fmt.Sprintf("Orders[%v]", idx),
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        case interface{ Validate() error }:<span class="cov0" title="0">
                                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, ImportOrdersRequestValidationError{
                                                field:  fmt.Sprintf("Orders[%v]", idx),
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        }
                } else<span class="cov0" title="0"> if v, ok := interface{}(item).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                return ImportOrdersRequestValidationError{
                                        field:  fmt.Sprintf("Orders[%v]", idx),
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                }
                        }</span>
                }

        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return ImportOrdersRequestMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ImportOrdersRequestMultiError is an error wrapping multiple validation
// errors returned by ImportOrdersRequest.ValidateAll() if the designated
// constraints aren't met.
type ImportOrdersRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportOrdersRequestMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m ImportOrdersRequestMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// ImportOrdersRequestValidationError is the validation error returned by
// ImportOrdersRequest.Validate if the designated constraints aren't met.
type ImportOrdersRequestValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e ImportOrdersRequestValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e ImportOrdersRequestValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e ImportOrdersRequestValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e ImportOrdersRequestValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e ImportOrdersRequestValidationError) ErrorName() string <span class="cov0" title="0">{
        return "ImportOrdersRequestValidationError"
}</span>

// Error satisfies the builtin error interface
func (e ImportOrdersRequestValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sImportOrdersRequest.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = ImportOrdersRequestValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = ImportOrdersRequestValidationError{}

// Validate checks the field values on GetHistoryRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetHistoryRequest) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on GetHistoryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetHistoryRequestMultiError, or nil if none found.
func (m *GetHistoryRequest) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *GetHistoryRequest) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if all </span><span class="cov0" title="0">{
                switch v := interface{}(m.GetPagination()).(type) </span>{
                case interface{ ValidateAll() error }:<span class="cov0" title="0">
                        if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, GetHistoryRequestValidationError{
                                        field:  "Pagination",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                case interface{ Validate() error }:<span class="cov0" title="0">
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, GetHistoryRequestValidationError{
                                        field:  "Pagination",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                }
        } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                        return GetHistoryRequestValidationError{
                                field:  "Pagination",
                                reason: "embedded message failed validation",
                                cause:  err,
                        }
                }</span>
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return GetHistoryRequestMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetHistoryRequestMultiError is an error wrapping multiple validation errors
// returned by GetHistoryRequest.ValidateAll() if the designated constraints
// aren't met.
type GetHistoryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetHistoryRequestMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m GetHistoryRequestMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// GetHistoryRequestValidationError is the validation error returned by
// GetHistoryRequest.Validate if the designated constraints aren't met.
type GetHistoryRequestValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e GetHistoryRequestValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e GetHistoryRequestValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e GetHistoryRequestValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e GetHistoryRequestValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e GetHistoryRequestValidationError) ErrorName() string <span class="cov0" title="0">{
        return "GetHistoryRequestValidationError"
}</span>

// Error satisfies the builtin error interface
func (e GetHistoryRequestValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sGetHistoryRequest.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = GetHistoryRequestValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = GetHistoryRequestValidationError{}

// Validate checks the field values on OrderHistoryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OrderHistoryRequest) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on OrderHistoryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OrderHistoryRequestMultiError, or nil if none found.
func (m *OrderHistoryRequest) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *OrderHistoryRequest) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if m.GetOrderId() &lt;= 0 </span><span class="cov0" title="0">{
                err := OrderHistoryRequestValidationError{
                        field:  "OrderId",
                        reason: "value must be greater than 0",
                }
                if !all </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">errors = append(errors, err)</span>
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return OrderHistoryRequestMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// OrderHistoryRequestMultiError is an error wrapping multiple validation
// errors returned by OrderHistoryRequest.ValidateAll() if the designated
// constraints aren't met.
type OrderHistoryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderHistoryRequestMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m OrderHistoryRequestMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// OrderHistoryRequestValidationError is the validation error returned by
// OrderHistoryRequest.Validate if the designated constraints aren't met.
type OrderHistoryRequestValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e OrderHistoryRequestValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e OrderHistoryRequestValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e OrderHistoryRequestValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e OrderHistoryRequestValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e OrderHistoryRequestValidationError) ErrorName() string <span class="cov0" title="0">{
        return "OrderHistoryRequestValidationError"
}</span>

// Error satisfies the builtin error interface
func (e OrderHistoryRequestValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sOrderHistoryRequest.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = OrderHistoryRequestValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = OrderHistoryRequestValidationError{}

// Validate checks the field values on OrderHistoryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OrderHistoryResponse) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on OrderHistoryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OrderHistoryResponseMultiError, or nil if none found.
func (m *OrderHistoryResponse) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *OrderHistoryResponse) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        for idx, item := range m.GetHistory() </span><span class="cov0" title="0">{
                _, _ = idx, item

                if all </span><span class="cov0" title="0">{
                        switch v := interface{}(item).(type) </span>{
                        case interface{ ValidateAll() error }:<span class="cov0" title="0">
                                if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, OrderHistoryResponseValidationError{
                                                field:  fmt.Sprintf("History[%v]", idx),
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        case interface{ Validate() error }:<span class="cov0" title="0">
                                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, OrderHistoryResponseValidationError{
                                                field:  fmt.Sprintf("History[%v]", idx),
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        }
                } else<span class="cov0" title="0"> if v, ok := interface{}(item).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                return OrderHistoryResponseValidationError{
                                        field:  fmt.Sprintf("History[%v]", idx),
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                }
                        }</span>
                }

        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return OrderHistoryResponseMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// OrderHistoryResponseMultiError is an error wrapping multiple validation
// errors returned by OrderHistoryResponse.ValidateAll() if the designated
// constraints aren't met.
type OrderHistoryResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderHistoryResponseMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m OrderHistoryResponseMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// OrderHistoryResponseValidationError is the validation error returned by
// OrderHistoryResponse.Validate if the designated constraints aren't met.
type OrderHistoryResponseValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e OrderHistoryResponseValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e OrderHistoryResponseValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e OrderHistoryResponseValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e OrderHistoryResponseValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e OrderHistoryResponseValidationError) ErrorName() string <span class="cov0" title="0">{
        return "OrderHistoryResponseValidationError"
}</span>

// Error satisfies the builtin error interface
func (e OrderHistoryResponseValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sOrderHistoryResponse.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = OrderHistoryResponseValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = OrderHistoryResponseValidationError{}

// Validate checks the field values on OrderResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OrderResponse) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on OrderResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OrderResponseMultiError, or
// nil if none found.
func (m *OrderResponse) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *OrderResponse) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        // no validation rules for Status

        // no validation rules for OrderId

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return OrderResponseMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// OrderResponseMultiError is an error wrapping multiple validation errors
// returned by OrderResponse.ValidateAll() if the designated constraints
// aren't met.
type OrderResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderResponseMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m OrderResponseMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// OrderResponseValidationError is the validation error returned by
// OrderResponse.Validate if the designated constraints aren't met.
type OrderResponseValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e OrderResponseValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e OrderResponseValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e OrderResponseValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e OrderResponseValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e OrderResponseValidationError) ErrorName() string <span class="cov0" title="0">{ return "OrderResponseValidationError" }</span>

// Error satisfies the builtin error interface
func (e OrderResponseValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sOrderResponse.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = OrderResponseValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = OrderResponseValidationError{}

// Validate checks the field values on ProcessResult with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProcessResult) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on ProcessResult with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProcessResultMultiError, or
// nil if none found.
func (m *ProcessResult) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *ProcessResult) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return ProcessResultMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ProcessResultMultiError is an error wrapping multiple validation errors
// returned by ProcessResult.ValidateAll() if the designated constraints
// aren't met.
type ProcessResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProcessResultMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m ProcessResultMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// ProcessResultValidationError is the validation error returned by
// ProcessResult.Validate if the designated constraints aren't met.
type ProcessResultValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e ProcessResultValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e ProcessResultValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e ProcessResultValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e ProcessResultValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e ProcessResultValidationError) ErrorName() string <span class="cov0" title="0">{ return "ProcessResultValidationError" }</span>

// Error satisfies the builtin error interface
func (e ProcessResultValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sProcessResult.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = ProcessResultValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = ProcessResultValidationError{}

// Validate checks the field values on OrdersList with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OrdersList) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on OrdersList with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OrdersListMultiError, or
// nil if none found.
func (m *OrdersList) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *OrdersList) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        for idx, item := range m.GetOrders() </span><span class="cov0" title="0">{
                _, _ = idx, item

                if all </span><span class="cov0" title="0">{
                        switch v := interface{}(item).(type) </span>{
                        case interface{ ValidateAll() error }:<span class="cov0" title="0">
                                if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, OrdersListValidationError{
                                                field:  fmt.Sprintf("Orders[%v]", idx),
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        case interface{ Validate() error }:<span class="cov0" title="0">
                                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, OrdersListValidationError{
                                                field:  fmt.Sprintf("Orders[%v]", idx),
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        }
                } else<span class="cov0" title="0"> if v, ok := interface{}(item).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                return OrdersListValidationError{
                                        field:  fmt.Sprintf("Orders[%v]", idx),
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                }
                        }</span>
                }

        }

        // no validation rules for Total

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return OrdersListMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// OrdersListMultiError is an error wrapping multiple validation errors
// returned by OrdersList.ValidateAll() if the designated constraints aren't met.
type OrdersListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrdersListMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m OrdersListMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// OrdersListValidationError is the validation error returned by
// OrdersList.Validate if the designated constraints aren't met.
type OrdersListValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e OrdersListValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e OrdersListValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e OrdersListValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e OrdersListValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e OrdersListValidationError) ErrorName() string <span class="cov0" title="0">{ return "OrdersListValidationError" }</span>

// Error satisfies the builtin error interface
func (e OrdersListValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sOrdersList.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = OrdersListValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = OrdersListValidationError{}

// Validate checks the field values on ReturnsList with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReturnsList) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on ReturnsList with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReturnsListMultiError, or
// nil if none found.
func (m *ReturnsList) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *ReturnsList) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        for idx, item := range m.GetReturns() </span><span class="cov0" title="0">{
                _, _ = idx, item

                if all </span><span class="cov0" title="0">{
                        switch v := interface{}(item).(type) </span>{
                        case interface{ ValidateAll() error }:<span class="cov0" title="0">
                                if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, ReturnsListValidationError{
                                                field:  fmt.Sprintf("Returns[%v]", idx),
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        case interface{ Validate() error }:<span class="cov0" title="0">
                                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, ReturnsListValidationError{
                                                field:  fmt.Sprintf("Returns[%v]", idx),
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        }
                } else<span class="cov0" title="0"> if v, ok := interface{}(item).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                return ReturnsListValidationError{
                                        field:  fmt.Sprintf("Returns[%v]", idx),
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                }
                        }</span>
                }

        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return ReturnsListMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ReturnsListMultiError is an error wrapping multiple validation errors
// returned by ReturnsList.ValidateAll() if the designated constraints aren't met.
type ReturnsListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReturnsListMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m ReturnsListMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// ReturnsListValidationError is the validation error returned by
// ReturnsList.Validate if the designated constraints aren't met.
type ReturnsListValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e ReturnsListValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e ReturnsListValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e ReturnsListValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e ReturnsListValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e ReturnsListValidationError) ErrorName() string <span class="cov0" title="0">{ return "ReturnsListValidationError" }</span>

// Error satisfies the builtin error interface
func (e ReturnsListValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sReturnsList.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = ReturnsListValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = ReturnsListValidationError{}

// Validate checks the field values on OrderHistoryList with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *OrderHistoryList) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on OrderHistoryList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OrderHistoryListMultiError, or nil if none found.
func (m *OrderHistoryList) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *OrderHistoryList) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        for idx, item := range m.GetHistory() </span><span class="cov0" title="0">{
                _, _ = idx, item

                if all </span><span class="cov0" title="0">{
                        switch v := interface{}(item).(type) </span>{
                        case interface{ ValidateAll() error }:<span class="cov0" title="0">
                                if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, OrderHistoryListValidationError{
                                                field:  fmt.Sprintf("History[%v]", idx),
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        case interface{ Validate() error }:<span class="cov0" title="0">
                                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, OrderHistoryListValidationError{
                                                field:  fmt.Sprintf("History[%v]", idx),
                                                reason: "embedded message failed validation",
                                                cause:  err,
                                        })
                                }</span>
                        }
                } else<span class="cov0" title="0"> if v, ok := interface{}(item).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                return OrderHistoryListValidationError{
                                        field:  fmt.Sprintf("History[%v]", idx),
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                }
                        }</span>
                }

        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return OrderHistoryListMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// OrderHistoryListMultiError is an error wrapping multiple validation errors
// returned by OrderHistoryList.ValidateAll() if the designated constraints
// aren't met.
type OrderHistoryListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderHistoryListMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m OrderHistoryListMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// OrderHistoryListValidationError is the validation error returned by
// OrderHistoryList.Validate if the designated constraints aren't met.
type OrderHistoryListValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e OrderHistoryListValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e OrderHistoryListValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e OrderHistoryListValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e OrderHistoryListValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e OrderHistoryListValidationError) ErrorName() string <span class="cov0" title="0">{ return "OrderHistoryListValidationError" }</span>

// Error satisfies the builtin error interface
func (e OrderHistoryListValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sOrderHistoryList.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = OrderHistoryListValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = OrderHistoryListValidationError{}

// Validate checks the field values on ImportResult with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ImportResult) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on ImportResult with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ImportResultMultiError, or
// nil if none found.
func (m *ImportResult) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *ImportResult) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        // no validation rules for Imported

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return ImportResultMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ImportResultMultiError is an error wrapping multiple validation errors
// returned by ImportResult.ValidateAll() if the designated constraints aren't met.
type ImportResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportResultMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m ImportResultMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// ImportResultValidationError is the validation error returned by
// ImportResult.Validate if the designated constraints aren't met.
type ImportResultValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e ImportResultValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e ImportResultValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e ImportResultValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e ImportResultValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e ImportResultValidationError) ErrorName() string <span class="cov0" title="0">{ return "ImportResultValidationError" }</span>

// Error satisfies the builtin error interface
func (e ImportResultValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sImportResult.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = ImportResultValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = ImportResultValidationError{}

// Validate checks the field values on Order with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Order) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on Order with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in OrderMultiError, or nil if none found.
func (m *Order) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *Order) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        // no validation rules for OrderId

        // no validation rules for UserId

        // no validation rules for Status

        if all </span><span class="cov0" title="0">{
                switch v := interface{}(m.GetExpiresAt()).(type) </span>{
                case interface{ ValidateAll() error }:<span class="cov0" title="0">
                        if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, OrderValidationError{
                                        field:  "ExpiresAt",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                case interface{ Validate() error }:<span class="cov0" title="0">
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, OrderValidationError{
                                        field:  "ExpiresAt",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                }
        } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetExpiresAt()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                        return OrderValidationError{
                                field:  "ExpiresAt",
                                reason: "embedded message failed validation",
                                cause:  err,
                        }
                }</span>
        }

        // no validation rules for Weight

        // no validation rules for TotalPrice

        <span class="cov0" title="0">if m.Package != nil </span>{<span class="cov0" title="0">
                // no validation rules for Package
        }</span>

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return OrderMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// OrderMultiError is an error wrapping multiple validation errors returned by
// Order.ValidateAll() if the designated constraints aren't met.
type OrderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m OrderMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// OrderValidationError is the validation error returned by Order.Validate if
// the designated constraints aren't met.
type OrderValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e OrderValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e OrderValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e OrderValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e OrderValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e OrderValidationError) ErrorName() string <span class="cov0" title="0">{ return "OrderValidationError" }</span>

// Error satisfies the builtin error interface
func (e OrderValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sOrder.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = OrderValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = OrderValidationError{}

// Validate checks the field values on OrderHistory with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OrderHistory) Validate() error <span class="cov0" title="0">{
        return m.validate(false)
}</span>

// ValidateAll checks the field values on OrderHistory with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OrderHistoryMultiError, or
// nil if none found.
func (m *OrderHistory) ValidateAll() error <span class="cov0" title="0">{
        return m.validate(true)
}</span>

func (m *OrderHistory) validate(all bool) error <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var errors []error

        // no validation rules for OrderId

        // no validation rules for Status

        if all </span><span class="cov0" title="0">{
                switch v := interface{}(m.GetCreatedAt()).(type) </span>{
                case interface{ ValidateAll() error }:<span class="cov0" title="0">
                        if err := v.ValidateAll(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, OrderHistoryValidationError{
                                        field:  "CreatedAt",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                case interface{ Validate() error }:<span class="cov0" title="0">
                        if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, OrderHistoryValidationError{
                                        field:  "CreatedAt",
                                        reason: "embedded message failed validation",
                                        cause:  err,
                                })
                        }</span>
                }
        } else<span class="cov0" title="0"> if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok </span><span class="cov0" title="0">{
                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                        return OrderHistoryValidationError{
                                field:  "CreatedAt",
                                reason: "embedded message failed validation",
                                cause:  err,
                        }
                }</span>
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return OrderHistoryMultiError(errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// OrderHistoryMultiError is an error wrapping multiple validation errors
// returned by OrderHistory.ValidateAll() if the designated constraints aren't met.
type OrderHistoryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderHistoryMultiError) Error() string <span class="cov0" title="0">{
        msgs := make([]string, 0, len(m))
        for _, err := range m </span><span class="cov0" title="0">{
                msgs = append(msgs, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(msgs, "; ")</span>
}

// AllErrors returns a list of validation violation errors.
func (m OrderHistoryMultiError) AllErrors() []error <span class="cov0" title="0">{ return m }</span>

// OrderHistoryValidationError is the validation error returned by
// OrderHistory.Validate if the designated constraints aren't met.
type OrderHistoryValidationError struct {
        field  string
        reason string
        cause  error
        key    bool
}

// Field function returns field value.
func (e OrderHistoryValidationError) Field() string <span class="cov0" title="0">{ return e.field }</span>

// Reason function returns reason value.
func (e OrderHistoryValidationError) Reason() string <span class="cov0" title="0">{ return e.reason }</span>

// Cause function returns cause value.
func (e OrderHistoryValidationError) Cause() error <span class="cov0" title="0">{ return e.cause }</span>

// Key function returns key value.
func (e OrderHistoryValidationError) Key() bool <span class="cov0" title="0">{ return e.key }</span>

// ErrorName returns error name.
func (e OrderHistoryValidationError) ErrorName() string <span class="cov0" title="0">{ return "OrderHistoryValidationError" }</span>

// Error satisfies the builtin error interface
func (e OrderHistoryValidationError) Error() string <span class="cov0" title="0">{
        cause := ""
        if e.cause != nil </span><span class="cov0" title="0">{
                cause = fmt.Sprintf(" | caused by: %v", e.cause)
        }</span>

        <span class="cov0" title="0">key := ""
        if e.key </span><span class="cov0" title="0">{
                key = "key for "
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "invalid %sOrderHistory.%s: %s%s",
                key,
                e.field,
                e.reason,
                cause)</span>
}

var _ error = OrderHistoryValidationError{}

var _ interface {
        Field() string
        Reason() string
        Key() bool
        Cause() error
        ErrorName() string
} = OrderHistoryValidationError{}
</pre>
		
		<pre class="file" id="file37" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.31.1
// source: orders/contract.proto

package api

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        OrdersService_AcceptOrder_FullMethodName     = "/orders.OrdersService/AcceptOrder"
        OrdersService_ReturnOrder_FullMethodName     = "/orders.OrdersService/ReturnOrder"
        OrdersService_ProcessOrders_FullMethodName   = "/orders.OrdersService/ProcessOrders"
        OrdersService_ListOrders_FullMethodName      = "/orders.OrdersService/ListOrders"
        OrdersService_ListReturns_FullMethodName     = "/orders.OrdersService/ListReturns"
        OrdersService_GetHistory_FullMethodName      = "/orders.OrdersService/GetHistory"
        OrdersService_ImportOrders_FullMethodName    = "/orders.OrdersService/ImportOrders"
        OrdersService_GetOrderHistory_FullMethodName = "/orders.OrdersService/GetOrderHistory"
)

// OrdersServiceClient is the client API for OrdersService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OrdersServiceClient interface {
        AcceptOrder(ctx context.Context, in *AcceptOrderRequest, opts ...grpc.CallOption) (*OrderResponse, error)
        ReturnOrder(ctx context.Context, in *OrderIdRequest, opts ...grpc.CallOption) (*OrderResponse, error)
        ProcessOrders(ctx context.Context, in *ProcessOrdersRequest, opts ...grpc.CallOption) (*ProcessResult, error)
        ListOrders(ctx context.Context, in *ListOrdersRequest, opts ...grpc.CallOption) (*OrdersList, error)
        ListReturns(ctx context.Context, in *ListReturnsRequest, opts ...grpc.CallOption) (*ReturnsList, error)
        GetHistory(ctx context.Context, in *GetHistoryRequest, opts ...grpc.CallOption) (*OrderHistoryList, error)
        ImportOrders(ctx context.Context, in *ImportOrdersRequest, opts ...grpc.CallOption) (*ImportResult, error)
        GetOrderHistory(ctx context.Context, in *OrderHistoryRequest, opts ...grpc.CallOption) (*OrderHistoryResponse, error)
}

type ordersServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewOrdersServiceClient(cc grpc.ClientConnInterface) OrdersServiceClient <span class="cov0" title="0">{
        return &amp;ordersServiceClient{cc}
}</span>

func (c *ordersServiceClient) AcceptOrder(ctx context.Context, in *AcceptOrderRequest, opts ...grpc.CallOption) (*OrderResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(OrderResponse)
        err := c.cc.Invoke(ctx, OrdersService_AcceptOrder_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *ordersServiceClient) ReturnOrder(ctx context.Context, in *OrderIdRequest, opts ...grpc.CallOption) (*OrderResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(OrderResponse)
        err := c.cc.Invoke(ctx, OrdersService_ReturnOrder_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *ordersServiceClient) ProcessOrders(ctx context.Context, in *ProcessOrdersRequest, opts ...grpc.CallOption) (*ProcessResult, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ProcessResult)
        err := c.cc.Invoke(ctx, OrdersService_ProcessOrders_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *ordersServiceClient) ListOrders(ctx context.Context, in *ListOrdersRequest, opts ...grpc.CallOption) (*OrdersList, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(OrdersList)
        err := c.cc.Invoke(ctx, OrdersService_ListOrders_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *ordersServiceClient) ListReturns(ctx context.Context, in *ListReturnsRequest, opts ...grpc.CallOption) (*ReturnsList, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ReturnsList)
        err := c.cc.Invoke(ctx, OrdersService_ListReturns_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *ordersServiceClient) GetHistory(ctx context.Context, in *GetHistoryRequest, opts ...grpc.CallOption) (*OrderHistoryList, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(OrderHistoryList)
        err := c.cc.Invoke(ctx, OrdersService_GetHistory_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *ordersServiceClient) ImportOrders(ctx context.Context, in *ImportOrdersRequest, opts ...grpc.CallOption) (*ImportResult, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ImportResult)
        err := c.cc.Invoke(ctx, OrdersService_ImportOrders_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *ordersServiceClient) GetOrderHistory(ctx context.Context, in *OrderHistoryRequest, opts ...grpc.CallOption) (*OrderHistoryResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(OrderHistoryResponse)
        err := c.cc.Invoke(ctx, OrdersService_GetOrderHistory_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// OrdersServiceServer is the server API for OrdersService service.
// All implementations must embed UnimplementedOrdersServiceServer
// for forward compatibility.
type OrdersServiceServer interface {
        AcceptOrder(context.Context, *AcceptOrderRequest) (*OrderResponse, error)
        ReturnOrder(context.Context, *OrderIdRequest) (*OrderResponse, error)
        ProcessOrders(context.Context, *ProcessOrdersRequest) (*ProcessResult, error)
        ListOrders(context.Context, *ListOrdersRequest) (*OrdersList, error)
        ListReturns(context.Context, *ListReturnsRequest) (*ReturnsList, error)
        GetHistory(context.Context, *GetHistoryRequest) (*OrderHistoryList, error)
        ImportOrders(context.Context, *ImportOrdersRequest) (*ImportResult, error)
        GetOrderHistory(context.Context, *OrderHistoryRequest) (*OrderHistoryResponse, error)
        mustEmbedUnimplementedOrdersServiceServer()
}

// UnimplementedOrdersServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedOrdersServiceServer struct{}

func (UnimplementedOrdersServiceServer) AcceptOrder(context.Context, *AcceptOrderRequest) (*OrderResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method AcceptOrder not implemented")
}</span>
func (UnimplementedOrdersServiceServer) ReturnOrder(context.Context, *OrderIdRequest) (*OrderResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ReturnOrder not implemented")
}</span>
func (UnimplementedOrdersServiceServer) ProcessOrders(context.Context, *ProcessOrdersRequest) (*ProcessResult, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ProcessOrders not implemented")
}</span>
func (UnimplementedOrdersServiceServer) ListOrders(context.Context, *ListOrdersRequest) (*OrdersList, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListOrders not implemented")
}</span>
func (UnimplementedOrdersServiceServer) ListReturns(context.Context, *ListReturnsRequest) (*ReturnsList, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListReturns not implemented")
}</span>
func (UnimplementedOrdersServiceServer) GetHistory(context.Context, *GetHistoryRequest) (*OrderHistoryList, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetHistory not implemented")
}</span>
func (UnimplementedOrdersServiceServer) ImportOrders(context.Context, *ImportOrdersRequest) (*ImportResult, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ImportOrders not implemented")
}</span>
func (UnimplementedOrdersServiceServer) GetOrderHistory(context.Context, *OrderHistoryRequest) (*OrderHistoryResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetOrderHistory not implemented")
}</span>
func (UnimplementedOrdersServiceServer) mustEmbedUnimplementedOrdersServiceServer() {<span class="cov0" title="0">}</span>
func (UnimplementedOrdersServiceServer) testEmbeddedByValue()                       {<span class="cov0" title="0">}</span>

// UnsafeOrdersServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OrdersServiceServer will
// result in compilation errors.
type UnsafeOrdersServiceServer interface {
        mustEmbedUnimplementedOrdersServiceServer()
}

func RegisterOrdersServiceServer(s grpc.ServiceRegistrar, srv OrdersServiceServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedOrdersServiceServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;OrdersService_ServiceDesc, srv)</span>
}

func _OrdersService_AcceptOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(AcceptOrderRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(OrdersServiceServer).AcceptOrder(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: OrdersService_AcceptOrder_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(OrdersServiceServer).AcceptOrder(ctx, req.(*AcceptOrderRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _OrdersService_ReturnOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(OrderIdRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(OrdersServiceServer).ReturnOrder(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: OrdersService_ReturnOrder_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(OrdersServiceServer).ReturnOrder(ctx, req.(*OrderIdRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _OrdersService_ProcessOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ProcessOrdersRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(OrdersServiceServer).ProcessOrders(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: OrdersService_ProcessOrders_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(OrdersServiceServer).ProcessOrders(ctx, req.(*ProcessOrdersRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _OrdersService_ListOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ListOrdersRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(OrdersServiceServer).ListOrders(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: OrdersService_ListOrders_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(OrdersServiceServer).ListOrders(ctx, req.(*ListOrdersRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _OrdersService_ListReturns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ListReturnsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(OrdersServiceServer).ListReturns(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: OrdersService_ListReturns_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(OrdersServiceServer).ListReturns(ctx, req.(*ListReturnsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _OrdersService_GetHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetHistoryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(OrdersServiceServer).GetHistory(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: OrdersService_GetHistory_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(OrdersServiceServer).GetHistory(ctx, req.(*GetHistoryRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _OrdersService_ImportOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ImportOrdersRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(OrdersServiceServer).ImportOrders(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: OrdersService_ImportOrders_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(OrdersServiceServer).ImportOrders(ctx, req.(*ImportOrdersRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _OrdersService_GetOrderHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(OrderHistoryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(OrdersServiceServer).GetOrderHistory(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: OrdersService_GetOrderHistory_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(OrdersServiceServer).GetOrderHistory(ctx, req.(*OrderHistoryRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// OrdersService_ServiceDesc is the grpc.ServiceDesc for OrdersService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OrdersService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "orders.OrdersService",
        HandlerType: (*OrdersServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "AcceptOrder",
                        Handler:    _OrdersService_AcceptOrder_Handler,
                },
                {
                        MethodName: "ReturnOrder",
                        Handler:    _OrdersService_ReturnOrder_Handler,
                },
                {
                        MethodName: "ProcessOrders",
                        Handler:    _OrdersService_ProcessOrders_Handler,
                },
                {
                        MethodName: "ListOrders",
                        Handler:    _OrdersService_ListOrders_Handler,
                },
                {
                        MethodName: "ListReturns",
                        Handler:    _OrdersService_ListReturns_Handler,
                },
                {
                        MethodName: "GetHistory",
                        Handler:    _OrdersService_GetHistory_Handler,
                },
                {
                        MethodName: "ImportOrders",
                        Handler:    _OrdersService_ImportOrders_Handler,
                },
                {
                        MethodName: "GetOrderHistory",
                        Handler:    _OrdersService_GetOrderHistory_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "orders/contract.proto",
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package db

import (
        "context"
        "database/sql"
        "fmt"
        "log/slog"

        _ "github.com/lib/pq"
)

type ClientMode string

const (
        ModeRead  ClientMode = "read"
        ModeWrite ClientMode = "write"
)

type Client struct {
        readDB  *sql.DB
        writeDB *sql.DB
        logger  *slog.Logger
}

type Config struct {
        ReadDSN  string
        WriteDSN string
        MaxOpen  int
        MaxIdle  int
}

func NewClient(cfg Config) (*Client, error) <span class="cov0" title="0">{
        logger := slog.Default()

        readDB, err := sql.Open("postgres", cfg.ReadDSN)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open read DB: %w", err)
        }</span>
        <span class="cov0" title="0">readDB.SetMaxOpenConns(cfg.MaxOpen)
        readDB.SetMaxIdleConns(cfg.MaxIdle)

        writeDB, err := sql.Open("postgres", cfg.WriteDSN)
        if err != nil </span><span class="cov0" title="0">{
                readDB.Close()
                return nil, fmt.Errorf("failed to open write DB: %w", err)
        }</span>
        <span class="cov0" title="0">writeDB.SetMaxOpenConns(cfg.MaxOpen)
        writeDB.SetMaxIdleConns(cfg.MaxIdle)

        return &amp;Client{
                readDB:  readDB,
                writeDB: writeDB,
                logger:  logger,
        }, nil</span>
}

func (c *Client) Close() error <span class="cov0" title="0">{
        var err error
        if c.readDB != nil </span><span class="cov0" title="0">{
                if closeErr := c.readDB.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("failed to close read DB: %w", closeErr)
                }</span>
        }
        <span class="cov0" title="0">if c.writeDB != nil </span><span class="cov0" title="0">{
                if closeErr := c.writeDB.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("%v; failed to close write DB: %w", err, closeErr)
                }</span>
        }
        <span class="cov0" title="0">return err</span>
}

func (c *Client) Exec(ctx context.Context, mode ClientMode, query string, args ...interface{}) (sql.Result, error) <span class="cov0" title="0">{
        db := c.getDB(mode)
        result, err := db.ExecContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Error executing query", "error", err)
                return nil, fmt.Errorf("exec query: %w", err)
        }</span>
        <span class="cov0" title="0">c.logger.Info("Query executed successfully")
        return result, nil</span>
}

func (c *Client) Query(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) <span class="cov0" title="0">{
        rows, err := c.readDB.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Error executing query", "error", err)
                return nil, fmt.Errorf("query: %w", err)
        }</span>
        <span class="cov0" title="0">c.logger.Info("Query executed successfully")
        return rows, nil</span>
}

func (c *Client) QueryRow(ctx context.Context, query string, args ...interface{}) *sql.Row <span class="cov0" title="0">{
        row := c.readDB.QueryRowContext(ctx, query, args...)
        return row
}</span>

func (c *Client) BeginTx(ctx context.Context) (*Tx, error) <span class="cov0" title="0">{
        tx, err := c.writeDB.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Error starting transaction", "error", err)
                return nil, fmt.Errorf("begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">c.logger.Info("Transaction started")
        return &amp;Tx{tx: tx, logger: c.logger}, nil</span>
}

func (c *Client) getDB(mode ClientMode) *sql.DB <span class="cov0" title="0">{
        if mode == ModeRead </span><span class="cov0" title="0">{
                return c.readDB
        }</span>
        <span class="cov0" title="0">return c.writeDB</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package db

import (
        "context"
        "database/sql"
        "fmt"
        "log/slog"
)

type Tx struct {
        tx     *sql.Tx
        logger *slog.Logger
}

func (t *Tx) Exec(ctx context.Context, query string, args ...interface{}) (sql.Result, error) <span class="cov0" title="0">{
        result, err := t.tx.ExecContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                t.logger.Error("Error executing query", "error", err)
                return nil, fmt.Errorf("exec query: %w", err)
        }</span>
        <span class="cov0" title="0">t.logger.Info("Query executed successfully")
        return result, nil</span>
}

func (t *Tx) Query(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) <span class="cov0" title="0">{
        rows, err := t.tx.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                t.logger.Error("Error executing query", "error", err)
                return nil, fmt.Errorf("query: %w", err)
        }</span>
        <span class="cov0" title="0">t.logger.Info("Query executed successfully")
        return rows, nil</span>
}

func (t *Tx) QueryRow(ctx context.Context, query string, args ...interface{}) *sql.Row <span class="cov0" title="0">{
        row := t.tx.QueryRowContext(ctx, query, args...)
        return row
}</span>

func (t *Tx) Commit() error <span class="cov0" title="0">{
        err := t.tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                t.logger.Error("Error committing transaction", "error", err)
                return fmt.Errorf("commit transaction: %w", err)
        }</span>
        <span class="cov0" title="0">t.logger.Info("Transaction committed")
        return nil</span>
}

func (t *Tx) Rollback() error <span class="cov0" title="0">{
        err := t.tx.Rollback()
        if err != nil </span><span class="cov0" title="0">{
                t.logger.Error("Error rolling back transaction", "error", err)
                return fmt.Errorf("rollback transaction: %w", err)
        }</span>
        <span class="cov0" title="0">t.logger.Info("Transaction rolled back")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.0
//         protoc        (unknown)
// source: protoc-gen-openapiv2/options/annotations.proto

//go:build !protoopaque

package options

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        descriptorpb "google.golang.org/protobuf/types/descriptorpb"
        reflect "reflect"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

var file_protoc_gen_openapiv2_options_annotations_proto_extTypes = []protoimpl.ExtensionInfo{
        {
                ExtendedType:  (*descriptorpb.FileOptions)(nil),
                ExtensionType: (*Swagger)(nil),
                Field:         1042,
                Name:          "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger",
                Tag:           "bytes,1042,opt,name=openapiv2_swagger",
                Filename:      "protoc-gen-openapiv2/options/annotations.proto",
        },
        {
                ExtendedType:  (*descriptorpb.MethodOptions)(nil),
                ExtensionType: (*Operation)(nil),
                Field:         1042,
                Name:          "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation",
                Tag:           "bytes,1042,opt,name=openapiv2_operation",
                Filename:      "protoc-gen-openapiv2/options/annotations.proto",
        },
        {
                ExtendedType:  (*descriptorpb.MessageOptions)(nil),
                ExtensionType: (*Schema)(nil),
                Field:         1042,
                Name:          "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema",
                Tag:           "bytes,1042,opt,name=openapiv2_schema",
                Filename:      "protoc-gen-openapiv2/options/annotations.proto",
        },
        {
                ExtendedType:  (*descriptorpb.EnumOptions)(nil),
                ExtensionType: (*EnumSchema)(nil),
                Field:         1042,
                Name:          "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_enum",
                Tag:           "bytes,1042,opt,name=openapiv2_enum",
                Filename:      "protoc-gen-openapiv2/options/annotations.proto",
        },
        {
                ExtendedType:  (*descriptorpb.ServiceOptions)(nil),
                ExtensionType: (*Tag)(nil),
                Field:         1042,
                Name:          "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_tag",
                Tag:           "bytes,1042,opt,name=openapiv2_tag",
                Filename:      "protoc-gen-openapiv2/options/annotations.proto",
        },
        {
                ExtendedType:  (*descriptorpb.FieldOptions)(nil),
                ExtensionType: (*JSONSchema)(nil),
                Field:         1042,
                Name:          "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field",
                Tag:           "bytes,1042,opt,name=openapiv2_field",
                Filename:      "protoc-gen-openapiv2/options/annotations.proto",
        },
}

// Extension fields to descriptorpb.FileOptions.
var (
        // ID assigned by protobuf-global-extension-registry@google.com for gRPC-Gateway project.
        //
        // All IDs are the same, as assigned. It is okay that they are the same, as they extend
        // different descriptor messages.
        //
        // optional grpc.gateway.protoc_gen_openapiv2.options.Swagger openapiv2_swagger = 1042;
        E_Openapiv2Swagger = &amp;file_protoc_gen_openapiv2_options_annotations_proto_extTypes[0]
)

// Extension fields to descriptorpb.MethodOptions.
var (
        // ID assigned by protobuf-global-extension-registry@google.com for gRPC-Gateway project.
        //
        // All IDs are the same, as assigned. It is okay that they are the same, as they extend
        // different descriptor messages.
        //
        // optional grpc.gateway.protoc_gen_openapiv2.options.Operation openapiv2_operation = 1042;
        E_Openapiv2Operation = &amp;file_protoc_gen_openapiv2_options_annotations_proto_extTypes[1]
)

// Extension fields to descriptorpb.MessageOptions.
var (
        // ID assigned by protobuf-global-extension-registry@google.com for gRPC-Gateway project.
        //
        // All IDs are the same, as assigned. It is okay that they are the same, as they extend
        // different descriptor messages.
        //
        // optional grpc.gateway.protoc_gen_openapiv2.options.Schema openapiv2_schema = 1042;
        E_Openapiv2Schema = &amp;file_protoc_gen_openapiv2_options_annotations_proto_extTypes[2]
)

// Extension fields to descriptorpb.EnumOptions.
var (
        // ID assigned by protobuf-global-extension-registry@google.com for gRPC-Gateway project.
        //
        // All IDs are the same, as assigned. It is okay that they are the same, as they extend
        // different descriptor messages.
        //
        // optional grpc.gateway.protoc_gen_openapiv2.options.EnumSchema openapiv2_enum = 1042;
        E_Openapiv2Enum = &amp;file_protoc_gen_openapiv2_options_annotations_proto_extTypes[3]
)

// Extension fields to descriptorpb.ServiceOptions.
var (
        // ID assigned by protobuf-global-extension-registry@google.com for gRPC-Gateway project.
        //
        // All IDs are the same, as assigned. It is okay that they are the same, as they extend
        // different descriptor messages.
        //
        // optional grpc.gateway.protoc_gen_openapiv2.options.Tag openapiv2_tag = 1042;
        E_Openapiv2Tag = &amp;file_protoc_gen_openapiv2_options_annotations_proto_extTypes[4]
)

// Extension fields to descriptorpb.FieldOptions.
var (
        // ID assigned by protobuf-global-extension-registry@google.com for gRPC-Gateway project.
        //
        // All IDs are the same, as assigned. It is okay that they are the same, as they extend
        // different descriptor messages.
        //
        // optional grpc.gateway.protoc_gen_openapiv2.options.JSONSchema openapiv2_field = 1042;
        E_Openapiv2Field = &amp;file_protoc_gen_openapiv2_options_annotations_proto_extTypes[5]
)

var File_protoc_gen_openapiv2_options_annotations_proto protoreflect.FileDescriptor

var file_protoc_gen_openapiv2_options_annotations_proto_rawDesc = []byte{
        0x0a, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x2d, 0x67, 0x65, 0x6e, 0x2d, 0x6f, 0x70, 0x65,
        0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2f, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2f, 0x61,
        0x6e, 0x6e, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x12, 0x29, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70,
        0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x1a, 0x20, 0x67, 0x6f, 0x6f,
        0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x64, 0x65, 0x73,
        0x63, 0x72, 0x69, 0x70, 0x74, 0x6f, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x2c, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x63, 0x2d, 0x67, 0x65, 0x6e, 0x2d, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70,
        0x69, 0x76, 0x32, 0x2f, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2f, 0x6f, 0x70, 0x65, 0x6e,
        0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x3a, 0x7e, 0x0a, 0x11, 0x6f,
        0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x5f, 0x73, 0x77, 0x61, 0x67, 0x67, 0x65, 0x72,
        0x12, 0x1c, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62,
        0x75, 0x66, 0x2e, 0x46, 0x69, 0x6c, 0x65, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x92,
        0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x32, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74,
        0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f,
        0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e,
        0x73, 0x2e, 0x53, 0x77, 0x61, 0x67, 0x67, 0x65, 0x72, 0x52, 0x10, 0x6f, 0x70, 0x65, 0x6e, 0x61,
        0x70, 0x69, 0x76, 0x32, 0x53, 0x77, 0x61, 0x67, 0x67, 0x65, 0x72, 0x3a, 0x86, 0x01, 0x0a, 0x13,
        0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x5f, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74,
        0x69, 0x6f, 0x6e, 0x12, 0x1e, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x4d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x4f, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x18, 0x92, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x34, 0x2e, 0x67, 0x72, 0x70,
        0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63,
        0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f,
        0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
        0x52, 0x12, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x4f, 0x70, 0x65, 0x72, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x3a, 0x7e, 0x0a, 0x10, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76,
        0x32, 0x5f, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x12, 0x1f, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
        0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x4d, 0x65, 0x73, 0x73, 0x61,
        0x67, 0x65, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x92, 0x08, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x31, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61,
        0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x63, 0x68,
        0x65, 0x6d, 0x61, 0x52, 0x0f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x53, 0x63,
        0x68, 0x65, 0x6d, 0x61, 0x3a, 0x7b, 0x0a, 0x0e, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76,
        0x32, 0x5f, 0x65, 0x6e, 0x75, 0x6d, 0x12, 0x1c, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6e, 0x75, 0x6d, 0x4f, 0x70, 0x74,
        0x69, 0x6f, 0x6e, 0x73, 0x18, 0x92, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x35, 0x2e, 0x67, 0x72,
        0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e,
        0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x45, 0x6e, 0x75, 0x6d, 0x53, 0x63, 0x68, 0x65,
        0x6d, 0x61, 0x52, 0x0d, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x45, 0x6e, 0x75,
        0x6d, 0x3a, 0x75, 0x0a, 0x0d, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x5f, 0x74,
        0x61, 0x67, 0x12, 0x1f, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x62, 0x75, 0x66, 0x2e, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x4f, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x18, 0x92, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2e, 0x2e, 0x67, 0x72, 0x70,
        0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63,
        0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f,
        0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x54, 0x61, 0x67, 0x52, 0x0c, 0x6f, 0x70, 0x65, 0x6e,
        0x61, 0x70, 0x69, 0x76, 0x32, 0x54, 0x61, 0x67, 0x3a, 0x7e, 0x0a, 0x0f, 0x6f, 0x70, 0x65, 0x6e,
        0x61, 0x70, 0x69, 0x76, 0x32, 0x5f, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x12, 0x1d, 0x2e, 0x67, 0x6f,
        0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x46, 0x69,
        0x65, 0x6c, 0x64, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x92, 0x08, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x35, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e,
        0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x4a, 0x53,
        0x4f, 0x4e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x52, 0x0e, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70,
        0x69, 0x76, 0x32, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x42, 0x48, 0x5a, 0x46, 0x67, 0x69, 0x74, 0x68,
        0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x67, 0x72, 0x70, 0x63, 0x2d, 0x65, 0x63, 0x6f, 0x73,
        0x79, 0x73, 0x74, 0x65, 0x6d, 0x2f, 0x67, 0x72, 0x70, 0x63, 0x2d, 0x67, 0x61, 0x74, 0x65, 0x77,
        0x61, 0x79, 0x2f, 0x76, 0x32, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x2d, 0x67, 0x65, 0x6e,
        0x2d, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2f, 0x6f, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x73, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var file_protoc_gen_openapiv2_options_annotations_proto_goTypes = []any{
        (*descriptorpb.FileOptions)(nil),    // 0: google.protobuf.FileOptions
        (*descriptorpb.MethodOptions)(nil),  // 1: google.protobuf.MethodOptions
        (*descriptorpb.MessageOptions)(nil), // 2: google.protobuf.MessageOptions
        (*descriptorpb.EnumOptions)(nil),    // 3: google.protobuf.EnumOptions
        (*descriptorpb.ServiceOptions)(nil), // 4: google.protobuf.ServiceOptions
        (*descriptorpb.FieldOptions)(nil),   // 5: google.protobuf.FieldOptions
        (*Swagger)(nil),                     // 6: grpc.gateway.protoc_gen_openapiv2.options.Swagger
        (*Operation)(nil),                   // 7: grpc.gateway.protoc_gen_openapiv2.options.Operation
        (*Schema)(nil),                      // 8: grpc.gateway.protoc_gen_openapiv2.options.Schema
        (*EnumSchema)(nil),                  // 9: grpc.gateway.protoc_gen_openapiv2.options.EnumSchema
        (*Tag)(nil),                         // 10: grpc.gateway.protoc_gen_openapiv2.options.Tag
        (*JSONSchema)(nil),                  // 11: grpc.gateway.protoc_gen_openapiv2.options.JSONSchema
}
var file_protoc_gen_openapiv2_options_annotations_proto_depIdxs = []int32{
        0,  // 0: grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger:extendee -&gt; google.protobuf.FileOptions
        1,  // 1: grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation:extendee -&gt; google.protobuf.MethodOptions
        2,  // 2: grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema:extendee -&gt; google.protobuf.MessageOptions
        3,  // 3: grpc.gateway.protoc_gen_openapiv2.options.openapiv2_enum:extendee -&gt; google.protobuf.EnumOptions
        4,  // 4: grpc.gateway.protoc_gen_openapiv2.options.openapiv2_tag:extendee -&gt; google.protobuf.ServiceOptions
        5,  // 5: grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field:extendee -&gt; google.protobuf.FieldOptions
        6,  // 6: grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Swagger
        7,  // 7: grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Operation
        8,  // 8: grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Schema
        9,  // 9: grpc.gateway.protoc_gen_openapiv2.options.openapiv2_enum:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.EnumSchema
        10, // 10: grpc.gateway.protoc_gen_openapiv2.options.openapiv2_tag:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Tag
        11, // 11: grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.JSONSchema
        12, // [12:12] is the sub-list for method output_type
        12, // [12:12] is the sub-list for method input_type
        6,  // [6:12] is the sub-list for extension type_name
        0,  // [0:6] is the sub-list for extension extendee
        0,  // [0:0] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_protoc_gen_openapiv2_options_annotations_proto_init() }</span>
func file_protoc_gen_openapiv2_options_annotations_proto_init() <span class="cov0" title="0">{
        if File_protoc_gen_openapiv2_options_annotations_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">file_protoc_gen_openapiv2_options_openapiv2_proto_init()
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_protoc_gen_openapiv2_options_annotations_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   0,
                        NumExtensions: 6,
                        NumServices:   0,
                },
                GoTypes:           file_protoc_gen_openapiv2_options_annotations_proto_goTypes,
                DependencyIndexes: file_protoc_gen_openapiv2_options_annotations_proto_depIdxs,
                ExtensionInfos:    file_protoc_gen_openapiv2_options_annotations_proto_extTypes,
        }.Build()
        File_protoc_gen_openapiv2_options_annotations_proto = out.File
        file_protoc_gen_openapiv2_options_annotations_proto_rawDesc = nil
        file_protoc_gen_openapiv2_options_annotations_proto_goTypes = nil
        file_protoc_gen_openapiv2_options_annotations_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.0
//         protoc        (unknown)
// source: protoc-gen-openapiv2/options/openapiv2.proto

//go:build !protoopaque

package options

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        structpb "google.golang.org/protobuf/types/known/structpb"
        reflect "reflect"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Scheme describes the schemes supported by the OpenAPI Swagger
// and Operation objects.
type Scheme int32

const (
        Scheme_UNKNOWN Scheme = 0
        Scheme_HTTP    Scheme = 1
        Scheme_HTTPS   Scheme = 2
        Scheme_WS      Scheme = 3
        Scheme_WSS     Scheme = 4
)

// Enum value maps for Scheme.
var (
        Scheme_name = map[int32]string{
                0: "UNKNOWN",
                1: "HTTP",
                2: "HTTPS",
                3: "WS",
                4: "WSS",
        }
        Scheme_value = map[string]int32{
                "UNKNOWN": 0,
                "HTTP":    1,
                "HTTPS":   2,
                "WS":      3,
                "WSS":     4,
        }
)

func (x Scheme) Enum() *Scheme <span class="cov0" title="0">{
        p := new(Scheme)
        *p = x
        return p
}</span>

func (x Scheme) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (Scheme) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes[0].Descriptor()
}</span>

func (Scheme) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes[0]
}</span>

func (x Scheme) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// `Type` is a supported HTTP header type.
// See https://swagger.io/specification/v2/#parameterType.
type HeaderParameter_Type int32

const (
        HeaderParameter_UNKNOWN HeaderParameter_Type = 0
        HeaderParameter_STRING  HeaderParameter_Type = 1
        HeaderParameter_NUMBER  HeaderParameter_Type = 2
        HeaderParameter_INTEGER HeaderParameter_Type = 3
        HeaderParameter_BOOLEAN HeaderParameter_Type = 4
)

// Enum value maps for HeaderParameter_Type.
var (
        HeaderParameter_Type_name = map[int32]string{
                0: "UNKNOWN",
                1: "STRING",
                2: "NUMBER",
                3: "INTEGER",
                4: "BOOLEAN",
        }
        HeaderParameter_Type_value = map[string]int32{
                "UNKNOWN": 0,
                "STRING":  1,
                "NUMBER":  2,
                "INTEGER": 3,
                "BOOLEAN": 4,
        }
)

func (x HeaderParameter_Type) Enum() *HeaderParameter_Type <span class="cov0" title="0">{
        p := new(HeaderParameter_Type)
        *p = x
        return p
}</span>

func (x HeaderParameter_Type) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (HeaderParameter_Type) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes[1].Descriptor()
}</span>

func (HeaderParameter_Type) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes[1]
}</span>

func (x HeaderParameter_Type) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

type JSONSchema_JSONSchemaSimpleTypes int32

const (
        JSONSchema_UNKNOWN JSONSchema_JSONSchemaSimpleTypes = 0
        JSONSchema_ARRAY   JSONSchema_JSONSchemaSimpleTypes = 1
        JSONSchema_BOOLEAN JSONSchema_JSONSchemaSimpleTypes = 2
        JSONSchema_INTEGER JSONSchema_JSONSchemaSimpleTypes = 3
        JSONSchema_NULL    JSONSchema_JSONSchemaSimpleTypes = 4
        JSONSchema_NUMBER  JSONSchema_JSONSchemaSimpleTypes = 5
        JSONSchema_OBJECT  JSONSchema_JSONSchemaSimpleTypes = 6
        JSONSchema_STRING  JSONSchema_JSONSchemaSimpleTypes = 7
)

// Enum value maps for JSONSchema_JSONSchemaSimpleTypes.
var (
        JSONSchema_JSONSchemaSimpleTypes_name = map[int32]string{
                0: "UNKNOWN",
                1: "ARRAY",
                2: "BOOLEAN",
                3: "INTEGER",
                4: "NULL",
                5: "NUMBER",
                6: "OBJECT",
                7: "STRING",
        }
        JSONSchema_JSONSchemaSimpleTypes_value = map[string]int32{
                "UNKNOWN": 0,
                "ARRAY":   1,
                "BOOLEAN": 2,
                "INTEGER": 3,
                "NULL":    4,
                "NUMBER":  5,
                "OBJECT":  6,
                "STRING":  7,
        }
)

func (x JSONSchema_JSONSchemaSimpleTypes) Enum() *JSONSchema_JSONSchemaSimpleTypes <span class="cov0" title="0">{
        p := new(JSONSchema_JSONSchemaSimpleTypes)
        *p = x
        return p
}</span>

func (x JSONSchema_JSONSchemaSimpleTypes) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (JSONSchema_JSONSchemaSimpleTypes) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes[2].Descriptor()
}</span>

func (JSONSchema_JSONSchemaSimpleTypes) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes[2]
}</span>

func (x JSONSchema_JSONSchemaSimpleTypes) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// The type of the security scheme. Valid values are "basic",
// "apiKey" or "oauth2".
type SecurityScheme_Type int32

const (
        SecurityScheme_TYPE_INVALID SecurityScheme_Type = 0
        SecurityScheme_TYPE_BASIC   SecurityScheme_Type = 1
        SecurityScheme_TYPE_API_KEY SecurityScheme_Type = 2
        SecurityScheme_TYPE_OAUTH2  SecurityScheme_Type = 3
)

// Enum value maps for SecurityScheme_Type.
var (
        SecurityScheme_Type_name = map[int32]string{
                0: "TYPE_INVALID",
                1: "TYPE_BASIC",
                2: "TYPE_API_KEY",
                3: "TYPE_OAUTH2",
        }
        SecurityScheme_Type_value = map[string]int32{
                "TYPE_INVALID": 0,
                "TYPE_BASIC":   1,
                "TYPE_API_KEY": 2,
                "TYPE_OAUTH2":  3,
        }
)

func (x SecurityScheme_Type) Enum() *SecurityScheme_Type <span class="cov0" title="0">{
        p := new(SecurityScheme_Type)
        *p = x
        return p
}</span>

func (x SecurityScheme_Type) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (SecurityScheme_Type) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes[3].Descriptor()
}</span>

func (SecurityScheme_Type) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes[3]
}</span>

func (x SecurityScheme_Type) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// The location of the API key. Valid values are "query" or "header".
type SecurityScheme_In int32

const (
        SecurityScheme_IN_INVALID SecurityScheme_In = 0
        SecurityScheme_IN_QUERY   SecurityScheme_In = 1
        SecurityScheme_IN_HEADER  SecurityScheme_In = 2
)

// Enum value maps for SecurityScheme_In.
var (
        SecurityScheme_In_name = map[int32]string{
                0: "IN_INVALID",
                1: "IN_QUERY",
                2: "IN_HEADER",
        }
        SecurityScheme_In_value = map[string]int32{
                "IN_INVALID": 0,
                "IN_QUERY":   1,
                "IN_HEADER":  2,
        }
)

func (x SecurityScheme_In) Enum() *SecurityScheme_In <span class="cov0" title="0">{
        p := new(SecurityScheme_In)
        *p = x
        return p
}</span>

func (x SecurityScheme_In) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (SecurityScheme_In) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes[4].Descriptor()
}</span>

func (SecurityScheme_In) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes[4]
}</span>

func (x SecurityScheme_In) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// The flow used by the OAuth2 security scheme. Valid values are
// "implicit", "password", "application" or "accessCode".
type SecurityScheme_Flow int32

const (
        SecurityScheme_FLOW_INVALID     SecurityScheme_Flow = 0
        SecurityScheme_FLOW_IMPLICIT    SecurityScheme_Flow = 1
        SecurityScheme_FLOW_PASSWORD    SecurityScheme_Flow = 2
        SecurityScheme_FLOW_APPLICATION SecurityScheme_Flow = 3
        SecurityScheme_FLOW_ACCESS_CODE SecurityScheme_Flow = 4
)

// Enum value maps for SecurityScheme_Flow.
var (
        SecurityScheme_Flow_name = map[int32]string{
                0: "FLOW_INVALID",
                1: "FLOW_IMPLICIT",
                2: "FLOW_PASSWORD",
                3: "FLOW_APPLICATION",
                4: "FLOW_ACCESS_CODE",
        }
        SecurityScheme_Flow_value = map[string]int32{
                "FLOW_INVALID":     0,
                "FLOW_IMPLICIT":    1,
                "FLOW_PASSWORD":    2,
                "FLOW_APPLICATION": 3,
                "FLOW_ACCESS_CODE": 4,
        }
)

func (x SecurityScheme_Flow) Enum() *SecurityScheme_Flow <span class="cov0" title="0">{
        p := new(SecurityScheme_Flow)
        *p = x
        return p
}</span>

func (x SecurityScheme_Flow) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (SecurityScheme_Flow) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes[5].Descriptor()
}</span>

func (SecurityScheme_Flow) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes[5]
}</span>

func (x SecurityScheme_Flow) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// `Swagger` is a representation of OpenAPI v2 specification's Swagger object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#swaggerObject
//
// Example:
//
//        option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
//          info: {
//            title: "Echo API";
//            version: "1.0";
//            description: "";
//            contact: {
//              name: "gRPC-Gateway project";
//              url: "https://github.com/grpc-ecosystem/grpc-gateway";
//              email: "none@example.com";
//            };
//            license: {
//              name: "BSD 3-Clause License";
//              url: "https://github.com/grpc-ecosystem/grpc-gateway/blob/main/LICENSE";
//            };
//          };
//          schemes: HTTPS;
//          consumes: "application/json";
//          produces: "application/json";
//        };
type Swagger struct {
        state protoimpl.MessageState `protogen:"hybrid.v1"`
        // Specifies the OpenAPI Specification version being used. It can be
        // used by the OpenAPI UI and other clients to interpret the API listing. The
        // value MUST be "2.0".
        Swagger string `protobuf:"bytes,1,opt,name=swagger,proto3" json:"swagger,omitempty"`
        // Provides metadata about the API. The metadata can be used by the
        // clients if needed.
        Info *Info `protobuf:"bytes,2,opt,name=info,proto3" json:"info,omitempty"`
        // The host (name or ip) serving the API. This MUST be the host only and does
        // not include the scheme nor sub-paths. It MAY include a port. If the host is
        // not included, the host serving the documentation is to be used (including
        // the port). The host does not support path templating.
        Host string `protobuf:"bytes,3,opt,name=host,proto3" json:"host,omitempty"`
        // The base path on which the API is served, which is relative to the host. If
        // it is not included, the API is served directly under the host. The value
        // MUST start with a leading slash (/). The basePath does not support path
        // templating.
        // Note that using `base_path` does not change the endpoint paths that are
        // generated in the resulting OpenAPI file. If you wish to use `base_path`
        // with relatively generated OpenAPI paths, the `base_path` prefix must be
        // manually removed from your `google.api.http` paths and your code changed to
        // serve the API from the `base_path`.
        BasePath string `protobuf:"bytes,4,opt,name=base_path,json=basePath,proto3" json:"base_path,omitempty"`
        // The transfer protocol of the API. Values MUST be from the list: "http",
        // "https", "ws", "wss". If the schemes is not included, the default scheme to
        // be used is the one used to access the OpenAPI definition itself.
        Schemes []Scheme `protobuf:"varint,5,rep,packed,name=schemes,proto3,enum=grpc.gateway.protoc_gen_openapiv2.options.Scheme" json:"schemes,omitempty"`
        // A list of MIME types the APIs can consume. This is global to all APIs but
        // can be overridden on specific API calls. Value MUST be as described under
        // Mime Types.
        Consumes []string `protobuf:"bytes,6,rep,name=consumes,proto3" json:"consumes,omitempty"`
        // A list of MIME types the APIs can produce. This is global to all APIs but
        // can be overridden on specific API calls. Value MUST be as described under
        // Mime Types.
        Produces []string `protobuf:"bytes,7,rep,name=produces,proto3" json:"produces,omitempty"`
        // An object to hold responses that can be used across operations. This
        // property does not define global responses for all operations.
        Responses map[string]*Response `protobuf:"bytes,10,rep,name=responses,proto3" json:"responses,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        // Security scheme definitions that can be used across the specification.
        SecurityDefinitions *SecurityDefinitions `protobuf:"bytes,11,opt,name=security_definitions,json=securityDefinitions,proto3" json:"security_definitions,omitempty"`
        // A declaration of which security schemes are applied for the API as a whole.
        // The list of values describes alternative security schemes that can be used
        // (that is, there is a logical OR between the security requirements).
        // Individual operations can override this definition.
        Security []*SecurityRequirement `protobuf:"bytes,12,rep,name=security,proto3" json:"security,omitempty"`
        // A list of tags for API documentation control. Tags can be used for logical
        // grouping of operations by resources or any other qualifier.
        Tags []*Tag `protobuf:"bytes,13,rep,name=tags,proto3" json:"tags,omitempty"`
        // Additional external documentation.
        ExternalDocs *ExternalDocumentation `protobuf:"bytes,14,opt,name=external_docs,json=externalDocs,proto3" json:"external_docs,omitempty"`
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions    map[string]*structpb.Value `protobuf:"bytes,15,rep,name=extensions,proto3" json:"extensions,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Swagger) Reset() <span class="cov0" title="0">{
        *x = Swagger{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Swagger) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Swagger) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Swagger) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *Swagger) GetSwagger() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Swagger
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Swagger) GetInfo() *Info <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Info
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Swagger) GetHost() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Host
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Swagger) GetBasePath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BasePath
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Swagger) GetSchemes() []Scheme <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Schemes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Swagger) GetConsumes() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Consumes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Swagger) GetProduces() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Produces
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Swagger) GetResponses() map[string]*Response <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Responses
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Swagger) GetSecurityDefinitions() *SecurityDefinitions <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SecurityDefinitions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Swagger) GetSecurity() []*SecurityRequirement <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Security
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Swagger) GetTags() []*Tag <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tags
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Swagger) GetExternalDocs() *ExternalDocumentation <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExternalDocs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Swagger) GetExtensions() map[string]*structpb.Value <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Extensions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Swagger) SetSwagger(v string) <span class="cov0" title="0">{
        x.Swagger = v
}</span>

func (x *Swagger) SetInfo(v *Info) <span class="cov0" title="0">{
        x.Info = v
}</span>

func (x *Swagger) SetHost(v string) <span class="cov0" title="0">{
        x.Host = v
}</span>

func (x *Swagger) SetBasePath(v string) <span class="cov0" title="0">{
        x.BasePath = v
}</span>

func (x *Swagger) SetSchemes(v []Scheme) <span class="cov0" title="0">{
        x.Schemes = v
}</span>

func (x *Swagger) SetConsumes(v []string) <span class="cov0" title="0">{
        x.Consumes = v
}</span>

func (x *Swagger) SetProduces(v []string) <span class="cov0" title="0">{
        x.Produces = v
}</span>

func (x *Swagger) SetResponses(v map[string]*Response) <span class="cov0" title="0">{
        x.Responses = v
}</span>

func (x *Swagger) SetSecurityDefinitions(v *SecurityDefinitions) <span class="cov0" title="0">{
        x.SecurityDefinitions = v
}</span>

func (x *Swagger) SetSecurity(v []*SecurityRequirement) <span class="cov0" title="0">{
        x.Security = v
}</span>

func (x *Swagger) SetTags(v []*Tag) <span class="cov0" title="0">{
        x.Tags = v
}</span>

func (x *Swagger) SetExternalDocs(v *ExternalDocumentation) <span class="cov0" title="0">{
        x.ExternalDocs = v
}</span>

func (x *Swagger) SetExtensions(v map[string]*structpb.Value) <span class="cov0" title="0">{
        x.Extensions = v
}</span>

func (x *Swagger) HasInfo() bool <span class="cov0" title="0">{
        if x == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return x.Info != nil</span>
}

func (x *Swagger) HasSecurityDefinitions() bool <span class="cov0" title="0">{
        if x == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return x.SecurityDefinitions != nil</span>
}

func (x *Swagger) HasExternalDocs() bool <span class="cov0" title="0">{
        if x == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return x.ExternalDocs != nil</span>
}

func (x *Swagger) ClearInfo() <span class="cov0" title="0">{
        x.Info = nil
}</span>

func (x *Swagger) ClearSecurityDefinitions() <span class="cov0" title="0">{
        x.SecurityDefinitions = nil
}</span>

func (x *Swagger) ClearExternalDocs() <span class="cov0" title="0">{
        x.ExternalDocs = nil
}</span>

type Swagger_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        // Specifies the OpenAPI Specification version being used. It can be
        // used by the OpenAPI UI and other clients to interpret the API listing. The
        // value MUST be "2.0".
        Swagger string
        // Provides metadata about the API. The metadata can be used by the
        // clients if needed.
        Info *Info
        // The host (name or ip) serving the API. This MUST be the host only and does
        // not include the scheme nor sub-paths. It MAY include a port. If the host is
        // not included, the host serving the documentation is to be used (including
        // the port). The host does not support path templating.
        Host string
        // The base path on which the API is served, which is relative to the host. If
        // it is not included, the API is served directly under the host. The value
        // MUST start with a leading slash (/). The basePath does not support path
        // templating.
        // Note that using `base_path` does not change the endpoint paths that are
        // generated in the resulting OpenAPI file. If you wish to use `base_path`
        // with relatively generated OpenAPI paths, the `base_path` prefix must be
        // manually removed from your `google.api.http` paths and your code changed to
        // serve the API from the `base_path`.
        BasePath string
        // The transfer protocol of the API. Values MUST be from the list: "http",
        // "https", "ws", "wss". If the schemes is not included, the default scheme to
        // be used is the one used to access the OpenAPI definition itself.
        Schemes []Scheme
        // A list of MIME types the APIs can consume. This is global to all APIs but
        // can be overridden on specific API calls. Value MUST be as described under
        // Mime Types.
        Consumes []string
        // A list of MIME types the APIs can produce. This is global to all APIs but
        // can be overridden on specific API calls. Value MUST be as described under
        // Mime Types.
        Produces []string
        // An object to hold responses that can be used across operations. This
        // property does not define global responses for all operations.
        Responses map[string]*Response
        // Security scheme definitions that can be used across the specification.
        SecurityDefinitions *SecurityDefinitions
        // A declaration of which security schemes are applied for the API as a whole.
        // The list of values describes alternative security schemes that can be used
        // (that is, there is a logical OR between the security requirements).
        // Individual operations can override this definition.
        Security []*SecurityRequirement
        // A list of tags for API documentation control. Tags can be used for logical
        // grouping of operations by resources or any other qualifier.
        Tags []*Tag
        // Additional external documentation.
        ExternalDocs *ExternalDocumentation
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions map[string]*structpb.Value
}

func (b0 Swagger_builder) Build() *Swagger <span class="cov0" title="0">{
        m0 := &amp;Swagger{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.Swagger = b.Swagger
        x.Info = b.Info
        x.Host = b.Host
        x.BasePath = b.BasePath
        x.Schemes = b.Schemes
        x.Consumes = b.Consumes
        x.Produces = b.Produces
        x.Responses = b.Responses
        x.SecurityDefinitions = b.SecurityDefinitions
        x.Security = b.Security
        x.Tags = b.Tags
        x.ExternalDocs = b.ExternalDocs
        x.Extensions = b.Extensions
        return m0
}</span>

// `Operation` is a representation of OpenAPI v2 specification's Operation object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#operationObject
//
// Example:
//
//        service EchoService {
//          rpc Echo(SimpleMessage) returns (SimpleMessage) {
//            option (google.api.http) = {
//              get: "/v1/example/echo/{id}"
//            };
//
//            option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
//              summary: "Get a message.";
//              operation_id: "getMessage";
//              tags: "echo";
//              responses: {
//                key: "200"
//                  value: {
//                  description: "OK";
//                }
//              }
//            };
//          }
//        }
type Operation struct {
        state protoimpl.MessageState `protogen:"hybrid.v1"`
        // A list of tags for API documentation control. Tags can be used for logical
        // grouping of operations by resources or any other qualifier.
        Tags []string `protobuf:"bytes,1,rep,name=tags,proto3" json:"tags,omitempty"`
        // A short summary of what the operation does. For maximum readability in the
        // swagger-ui, this field SHOULD be less than 120 characters.
        Summary string `protobuf:"bytes,2,opt,name=summary,proto3" json:"summary,omitempty"`
        // A verbose explanation of the operation behavior. GFM syntax can be used for
        // rich text representation.
        Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
        // Additional external documentation for this operation.
        ExternalDocs *ExternalDocumentation `protobuf:"bytes,4,opt,name=external_docs,json=externalDocs,proto3" json:"external_docs,omitempty"`
        // Unique string used to identify the operation. The id MUST be unique among
        // all operations described in the API. Tools and libraries MAY use the
        // operationId to uniquely identify an operation, therefore, it is recommended
        // to follow common programming naming conventions.
        OperationId string `protobuf:"bytes,5,opt,name=operation_id,json=operationId,proto3" json:"operation_id,omitempty"`
        // A list of MIME types the operation can consume. This overrides the consumes
        // definition at the OpenAPI Object. An empty value MAY be used to clear the
        // global definition. Value MUST be as described under Mime Types.
        Consumes []string `protobuf:"bytes,6,rep,name=consumes,proto3" json:"consumes,omitempty"`
        // A list of MIME types the operation can produce. This overrides the produces
        // definition at the OpenAPI Object. An empty value MAY be used to clear the
        // global definition. Value MUST be as described under Mime Types.
        Produces []string `protobuf:"bytes,7,rep,name=produces,proto3" json:"produces,omitempty"`
        // The list of possible responses as they are returned from executing this
        // operation.
        Responses map[string]*Response `protobuf:"bytes,9,rep,name=responses,proto3" json:"responses,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        // The transfer protocol for the operation. Values MUST be from the list:
        // "http", "https", "ws", "wss". The value overrides the OpenAPI Object
        // schemes definition.
        Schemes []Scheme `protobuf:"varint,10,rep,packed,name=schemes,proto3,enum=grpc.gateway.protoc_gen_openapiv2.options.Scheme" json:"schemes,omitempty"`
        // Declares this operation to be deprecated. Usage of the declared operation
        // should be refrained. Default value is false.
        Deprecated bool `protobuf:"varint,11,opt,name=deprecated,proto3" json:"deprecated,omitempty"`
        // A declaration of which security schemes are applied for this operation. The
        // list of values describes alternative security schemes that can be used
        // (that is, there is a logical OR between the security requirements). This
        // definition overrides any declared top-level security. To remove a top-level
        // security declaration, an empty array can be used.
        Security []*SecurityRequirement `protobuf:"bytes,12,rep,name=security,proto3" json:"security,omitempty"`
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions map[string]*structpb.Value `protobuf:"bytes,13,rep,name=extensions,proto3" json:"extensions,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        // Custom parameters such as HTTP request headers.
        // See: https://swagger.io/docs/specification/2-0/describing-parameters/
        // and https://swagger.io/specification/v2/#parameter-object.
        Parameters    *Parameters `protobuf:"bytes,14,opt,name=parameters,proto3" json:"parameters,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Operation) Reset() <span class="cov0" title="0">{
        *x = Operation{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Operation) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Operation) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Operation) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *Operation) GetTags() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tags
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Operation) GetSummary() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Summary
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Operation) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Operation) GetExternalDocs() *ExternalDocumentation <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExternalDocs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Operation) GetOperationId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OperationId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Operation) GetConsumes() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Consumes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Operation) GetProduces() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Produces
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Operation) GetResponses() map[string]*Response <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Responses
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Operation) GetSchemes() []Scheme <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Schemes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Operation) GetDeprecated() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Deprecated
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *Operation) GetSecurity() []*SecurityRequirement <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Security
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Operation) GetExtensions() map[string]*structpb.Value <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Extensions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Operation) GetParameters() *Parameters <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Parameters
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Operation) SetTags(v []string) <span class="cov0" title="0">{
        x.Tags = v
}</span>

func (x *Operation) SetSummary(v string) <span class="cov0" title="0">{
        x.Summary = v
}</span>

func (x *Operation) SetDescription(v string) <span class="cov0" title="0">{
        x.Description = v
}</span>

func (x *Operation) SetExternalDocs(v *ExternalDocumentation) <span class="cov0" title="0">{
        x.ExternalDocs = v
}</span>

func (x *Operation) SetOperationId(v string) <span class="cov0" title="0">{
        x.OperationId = v
}</span>

func (x *Operation) SetConsumes(v []string) <span class="cov0" title="0">{
        x.Consumes = v
}</span>

func (x *Operation) SetProduces(v []string) <span class="cov0" title="0">{
        x.Produces = v
}</span>

func (x *Operation) SetResponses(v map[string]*Response) <span class="cov0" title="0">{
        x.Responses = v
}</span>

func (x *Operation) SetSchemes(v []Scheme) <span class="cov0" title="0">{
        x.Schemes = v
}</span>

func (x *Operation) SetDeprecated(v bool) <span class="cov0" title="0">{
        x.Deprecated = v
}</span>

func (x *Operation) SetSecurity(v []*SecurityRequirement) <span class="cov0" title="0">{
        x.Security = v
}</span>

func (x *Operation) SetExtensions(v map[string]*structpb.Value) <span class="cov0" title="0">{
        x.Extensions = v
}</span>

func (x *Operation) SetParameters(v *Parameters) <span class="cov0" title="0">{
        x.Parameters = v
}</span>

func (x *Operation) HasExternalDocs() bool <span class="cov0" title="0">{
        if x == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return x.ExternalDocs != nil</span>
}

func (x *Operation) HasParameters() bool <span class="cov0" title="0">{
        if x == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return x.Parameters != nil</span>
}

func (x *Operation) ClearExternalDocs() <span class="cov0" title="0">{
        x.ExternalDocs = nil
}</span>

func (x *Operation) ClearParameters() <span class="cov0" title="0">{
        x.Parameters = nil
}</span>

type Operation_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        // A list of tags for API documentation control. Tags can be used for logical
        // grouping of operations by resources or any other qualifier.
        Tags []string
        // A short summary of what the operation does. For maximum readability in the
        // swagger-ui, this field SHOULD be less than 120 characters.
        Summary string
        // A verbose explanation of the operation behavior. GFM syntax can be used for
        // rich text representation.
        Description string
        // Additional external documentation for this operation.
        ExternalDocs *ExternalDocumentation
        // Unique string used to identify the operation. The id MUST be unique among
        // all operations described in the API. Tools and libraries MAY use the
        // operationId to uniquely identify an operation, therefore, it is recommended
        // to follow common programming naming conventions.
        OperationId string
        // A list of MIME types the operation can consume. This overrides the consumes
        // definition at the OpenAPI Object. An empty value MAY be used to clear the
        // global definition. Value MUST be as described under Mime Types.
        Consumes []string
        // A list of MIME types the operation can produce. This overrides the produces
        // definition at the OpenAPI Object. An empty value MAY be used to clear the
        // global definition. Value MUST be as described under Mime Types.
        Produces []string
        // The list of possible responses as they are returned from executing this
        // operation.
        Responses map[string]*Response
        // The transfer protocol for the operation. Values MUST be from the list:
        // "http", "https", "ws", "wss". The value overrides the OpenAPI Object
        // schemes definition.
        Schemes []Scheme
        // Declares this operation to be deprecated. Usage of the declared operation
        // should be refrained. Default value is false.
        Deprecated bool
        // A declaration of which security schemes are applied for this operation. The
        // list of values describes alternative security schemes that can be used
        // (that is, there is a logical OR between the security requirements). This
        // definition overrides any declared top-level security. To remove a top-level
        // security declaration, an empty array can be used.
        Security []*SecurityRequirement
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions map[string]*structpb.Value
        // Custom parameters such as HTTP request headers.
        // See: https://swagger.io/docs/specification/2-0/describing-parameters/
        // and https://swagger.io/specification/v2/#parameter-object.
        Parameters *Parameters
}

func (b0 Operation_builder) Build() *Operation <span class="cov0" title="0">{
        m0 := &amp;Operation{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.Tags = b.Tags
        x.Summary = b.Summary
        x.Description = b.Description
        x.ExternalDocs = b.ExternalDocs
        x.OperationId = b.OperationId
        x.Consumes = b.Consumes
        x.Produces = b.Produces
        x.Responses = b.Responses
        x.Schemes = b.Schemes
        x.Deprecated = b.Deprecated
        x.Security = b.Security
        x.Extensions = b.Extensions
        x.Parameters = b.Parameters
        return m0
}</span>

// `Parameters` is a representation of OpenAPI v2 specification's parameters object.
// Note: This technically breaks compatibility with the OpenAPI 2 definition structure as we only
// allow header parameters to be set here since we do not want users specifying custom non-header
// parameters beyond those inferred from the Protobuf schema.
// See: https://swagger.io/specification/v2/#parameter-object
type Parameters struct {
        state protoimpl.MessageState `protogen:"hybrid.v1"`
        // `Headers` is one or more HTTP header parameter.
        // See: https://swagger.io/docs/specification/2-0/describing-parameters/#header-parameters
        Headers       []*HeaderParameter `protobuf:"bytes,1,rep,name=headers,proto3" json:"headers,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Parameters) Reset() <span class="cov0" title="0">{
        *x = Parameters{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Parameters) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Parameters) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Parameters) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *Parameters) GetHeaders() []*HeaderParameter <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Headers
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Parameters) SetHeaders(v []*HeaderParameter) <span class="cov0" title="0">{
        x.Headers = v
}</span>

type Parameters_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        // `Headers` is one or more HTTP header parameter.
        // See: https://swagger.io/docs/specification/2-0/describing-parameters/#header-parameters
        Headers []*HeaderParameter
}

func (b0 Parameters_builder) Build() *Parameters <span class="cov0" title="0">{
        m0 := &amp;Parameters{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.Headers = b.Headers
        return m0
}</span>

// `HeaderParameter` a HTTP header parameter.
// See: https://swagger.io/specification/v2/#parameter-object
type HeaderParameter struct {
        state protoimpl.MessageState `protogen:"hybrid.v1"`
        // `Name` is the header name.
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // `Description` is a short description of the header.
        Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
        // `Type` is the type of the object. The value MUST be one of "string", "number", "integer", or "boolean". The "array" type is not supported.
        // See: https://swagger.io/specification/v2/#parameterType.
        Type HeaderParameter_Type `protobuf:"varint,3,opt,name=type,proto3,enum=grpc.gateway.protoc_gen_openapiv2.options.HeaderParameter_Type" json:"type,omitempty"`
        // `Format` The extending format for the previously mentioned type.
        Format string `protobuf:"bytes,4,opt,name=format,proto3" json:"format,omitempty"`
        // `Required` indicates if the header is optional
        Required      bool `protobuf:"varint,5,opt,name=required,proto3" json:"required,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *HeaderParameter) Reset() <span class="cov0" title="0">{
        *x = HeaderParameter{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *HeaderParameter) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*HeaderParameter) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *HeaderParameter) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *HeaderParameter) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *HeaderParameter) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *HeaderParameter) GetType() HeaderParameter_Type <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return HeaderParameter_UNKNOWN</span>
}

func (x *HeaderParameter) GetFormat() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Format
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *HeaderParameter) GetRequired() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Required
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *HeaderParameter) SetName(v string) <span class="cov0" title="0">{
        x.Name = v
}</span>

func (x *HeaderParameter) SetDescription(v string) <span class="cov0" title="0">{
        x.Description = v
}</span>

func (x *HeaderParameter) SetType(v HeaderParameter_Type) <span class="cov0" title="0">{
        x.Type = v
}</span>

func (x *HeaderParameter) SetFormat(v string) <span class="cov0" title="0">{
        x.Format = v
}</span>

func (x *HeaderParameter) SetRequired(v bool) <span class="cov0" title="0">{
        x.Required = v
}</span>

type HeaderParameter_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        // `Name` is the header name.
        Name string
        // `Description` is a short description of the header.
        Description string
        // `Type` is the type of the object. The value MUST be one of "string", "number", "integer", or "boolean". The "array" type is not supported.
        // See: https://swagger.io/specification/v2/#parameterType.
        Type HeaderParameter_Type
        // `Format` The extending format for the previously mentioned type.
        Format string
        // `Required` indicates if the header is optional
        Required bool
}

func (b0 HeaderParameter_builder) Build() *HeaderParameter <span class="cov0" title="0">{
        m0 := &amp;HeaderParameter{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.Name = b.Name
        x.Description = b.Description
        x.Type = b.Type
        x.Format = b.Format
        x.Required = b.Required
        return m0
}</span>

// `Header` is a representation of OpenAPI v2 specification's Header object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#headerObject
type Header struct {
        state protoimpl.MessageState `protogen:"hybrid.v1"`
        // `Description` is a short description of the header.
        Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
        // The type of the object. The value MUST be one of "string", "number", "integer", or "boolean". The "array" type is not supported.
        Type string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
        // `Format` The extending format for the previously mentioned type.
        Format string `protobuf:"bytes,3,opt,name=format,proto3" json:"format,omitempty"`
        // `Default` Declares the value of the header that the server will use if none is provided.
        // See: https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-6.2.
        // Unlike JSON Schema this value MUST conform to the defined type for the header.
        Default string `protobuf:"bytes,6,opt,name=default,proto3" json:"default,omitempty"`
        // 'Pattern' See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.2.3.
        Pattern       string `protobuf:"bytes,13,opt,name=pattern,proto3" json:"pattern,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Header) Reset() <span class="cov0" title="0">{
        *x = Header{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Header) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Header) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Header) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *Header) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Header) GetType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Header) GetFormat() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Format
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Header) GetDefault() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Default
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Header) GetPattern() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Pattern
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Header) SetDescription(v string) <span class="cov0" title="0">{
        x.Description = v
}</span>

func (x *Header) SetType(v string) <span class="cov0" title="0">{
        x.Type = v
}</span>

func (x *Header) SetFormat(v string) <span class="cov0" title="0">{
        x.Format = v
}</span>

func (x *Header) SetDefault(v string) <span class="cov0" title="0">{
        x.Default = v
}</span>

func (x *Header) SetPattern(v string) <span class="cov0" title="0">{
        x.Pattern = v
}</span>

type Header_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        // `Description` is a short description of the header.
        Description string
        // The type of the object. The value MUST be one of "string", "number", "integer", or "boolean". The "array" type is not supported.
        Type string
        // `Format` The extending format for the previously mentioned type.
        Format string
        // `Default` Declares the value of the header that the server will use if none is provided.
        // See: https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-6.2.
        // Unlike JSON Schema this value MUST conform to the defined type for the header.
        Default string
        // 'Pattern' See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.2.3.
        Pattern string
}

func (b0 Header_builder) Build() *Header <span class="cov0" title="0">{
        m0 := &amp;Header{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.Description = b.Description
        x.Type = b.Type
        x.Format = b.Format
        x.Default = b.Default
        x.Pattern = b.Pattern
        return m0
}</span>

// `Response` is a representation of OpenAPI v2 specification's Response object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#responseObject
type Response struct {
        state protoimpl.MessageState `protogen:"hybrid.v1"`
        // `Description` is a short description of the response.
        // GFM syntax can be used for rich text representation.
        Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
        // `Schema` optionally defines the structure of the response.
        // If `Schema` is not provided, it means there is no content to the response.
        Schema *Schema `protobuf:"bytes,2,opt,name=schema,proto3" json:"schema,omitempty"`
        // `Headers` A list of headers that are sent with the response.
        // `Header` name is expected to be a string in the canonical format of the MIME header key
        // See: https://golang.org/pkg/net/textproto/#CanonicalMIMEHeaderKey
        Headers map[string]*Header `protobuf:"bytes,3,rep,name=headers,proto3" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        // `Examples` gives per-mimetype response examples.
        // See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#example-object
        Examples map[string]string `protobuf:"bytes,4,rep,name=examples,proto3" json:"examples,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions    map[string]*structpb.Value `protobuf:"bytes,5,rep,name=extensions,proto3" json:"extensions,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Response) Reset() <span class="cov0" title="0">{
        *x = Response{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Response) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Response) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Response) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *Response) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Response) GetSchema() *Schema <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Schema
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Response) GetHeaders() map[string]*Header <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Headers
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Response) GetExamples() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Examples
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Response) GetExtensions() map[string]*structpb.Value <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Extensions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Response) SetDescription(v string) <span class="cov0" title="0">{
        x.Description = v
}</span>

func (x *Response) SetSchema(v *Schema) <span class="cov0" title="0">{
        x.Schema = v
}</span>

func (x *Response) SetHeaders(v map[string]*Header) <span class="cov0" title="0">{
        x.Headers = v
}</span>

func (x *Response) SetExamples(v map[string]string) <span class="cov0" title="0">{
        x.Examples = v
}</span>

func (x *Response) SetExtensions(v map[string]*structpb.Value) <span class="cov0" title="0">{
        x.Extensions = v
}</span>

func (x *Response) HasSchema() bool <span class="cov0" title="0">{
        if x == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return x.Schema != nil</span>
}

func (x *Response) ClearSchema() <span class="cov0" title="0">{
        x.Schema = nil
}</span>

type Response_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        // `Description` is a short description of the response.
        // GFM syntax can be used for rich text representation.
        Description string
        // `Schema` optionally defines the structure of the response.
        // If `Schema` is not provided, it means there is no content to the response.
        Schema *Schema
        // `Headers` A list of headers that are sent with the response.
        // `Header` name is expected to be a string in the canonical format of the MIME header key
        // See: https://golang.org/pkg/net/textproto/#CanonicalMIMEHeaderKey
        Headers map[string]*Header
        // `Examples` gives per-mimetype response examples.
        // See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#example-object
        Examples map[string]string
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions map[string]*structpb.Value
}

func (b0 Response_builder) Build() *Response <span class="cov0" title="0">{
        m0 := &amp;Response{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.Description = b.Description
        x.Schema = b.Schema
        x.Headers = b.Headers
        x.Examples = b.Examples
        x.Extensions = b.Extensions
        return m0
}</span>

// `Info` is a representation of OpenAPI v2 specification's Info object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#infoObject
//
// Example:
//
//        option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
//          info: {
//            title: "Echo API";
//            version: "1.0";
//            description: "";
//            contact: {
//              name: "gRPC-Gateway project";
//              url: "https://github.com/grpc-ecosystem/grpc-gateway";
//              email: "none@example.com";
//            };
//            license: {
//              name: "BSD 3-Clause License";
//              url: "https://github.com/grpc-ecosystem/grpc-gateway/blob/main/LICENSE";
//            };
//          };
//          ...
//        };
type Info struct {
        state protoimpl.MessageState `protogen:"hybrid.v1"`
        // The title of the application.
        Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
        // A short description of the application. GFM syntax can be used for rich
        // text representation.
        Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
        // The Terms of Service for the API.
        TermsOfService string `protobuf:"bytes,3,opt,name=terms_of_service,json=termsOfService,proto3" json:"terms_of_service,omitempty"`
        // The contact information for the exposed API.
        Contact *Contact `protobuf:"bytes,4,opt,name=contact,proto3" json:"contact,omitempty"`
        // The license information for the exposed API.
        License *License `protobuf:"bytes,5,opt,name=license,proto3" json:"license,omitempty"`
        // Provides the version of the application API (not to be confused
        // with the specification version).
        Version string `protobuf:"bytes,6,opt,name=version,proto3" json:"version,omitempty"`
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions    map[string]*structpb.Value `protobuf:"bytes,7,rep,name=extensions,proto3" json:"extensions,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Info) Reset() <span class="cov0" title="0">{
        *x = Info{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Info) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Info) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Info) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *Info) GetTitle() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Title
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Info) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Info) GetTermsOfService() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TermsOfService
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Info) GetContact() *Contact <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Contact
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Info) GetLicense() *License <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.License
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Info) GetVersion() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Version
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Info) GetExtensions() map[string]*structpb.Value <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Extensions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Info) SetTitle(v string) <span class="cov0" title="0">{
        x.Title = v
}</span>

func (x *Info) SetDescription(v string) <span class="cov0" title="0">{
        x.Description = v
}</span>

func (x *Info) SetTermsOfService(v string) <span class="cov0" title="0">{
        x.TermsOfService = v
}</span>

func (x *Info) SetContact(v *Contact) <span class="cov0" title="0">{
        x.Contact = v
}</span>

func (x *Info) SetLicense(v *License) <span class="cov0" title="0">{
        x.License = v
}</span>

func (x *Info) SetVersion(v string) <span class="cov0" title="0">{
        x.Version = v
}</span>

func (x *Info) SetExtensions(v map[string]*structpb.Value) <span class="cov0" title="0">{
        x.Extensions = v
}</span>

func (x *Info) HasContact() bool <span class="cov0" title="0">{
        if x == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return x.Contact != nil</span>
}

func (x *Info) HasLicense() bool <span class="cov0" title="0">{
        if x == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return x.License != nil</span>
}

func (x *Info) ClearContact() <span class="cov0" title="0">{
        x.Contact = nil
}</span>

func (x *Info) ClearLicense() <span class="cov0" title="0">{
        x.License = nil
}</span>

type Info_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        // The title of the application.
        Title string
        // A short description of the application. GFM syntax can be used for rich
        // text representation.
        Description string
        // The Terms of Service for the API.
        TermsOfService string
        // The contact information for the exposed API.
        Contact *Contact
        // The license information for the exposed API.
        License *License
        // Provides the version of the application API (not to be confused
        // with the specification version).
        Version string
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions map[string]*structpb.Value
}

func (b0 Info_builder) Build() *Info <span class="cov0" title="0">{
        m0 := &amp;Info{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.Title = b.Title
        x.Description = b.Description
        x.TermsOfService = b.TermsOfService
        x.Contact = b.Contact
        x.License = b.License
        x.Version = b.Version
        x.Extensions = b.Extensions
        return m0
}</span>

// `Contact` is a representation of OpenAPI v2 specification's Contact object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#contactObject
//
// Example:
//
//        option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
//          info: {
//            ...
//            contact: {
//              name: "gRPC-Gateway project";
//              url: "https://github.com/grpc-ecosystem/grpc-gateway";
//              email: "none@example.com";
//            };
//            ...
//          };
//          ...
//        };
type Contact struct {
        state protoimpl.MessageState `protogen:"hybrid.v1"`
        // The identifying name of the contact person/organization.
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // The URL pointing to the contact information. MUST be in the format of a
        // URL.
        Url string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
        // The email address of the contact person/organization. MUST be in the format
        // of an email address.
        Email         string `protobuf:"bytes,3,opt,name=email,proto3" json:"email,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Contact) Reset() <span class="cov0" title="0">{
        *x = Contact{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Contact) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Contact) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Contact) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *Contact) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Contact) GetUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Url
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Contact) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Contact) SetName(v string) <span class="cov0" title="0">{
        x.Name = v
}</span>

func (x *Contact) SetUrl(v string) <span class="cov0" title="0">{
        x.Url = v
}</span>

func (x *Contact) SetEmail(v string) <span class="cov0" title="0">{
        x.Email = v
}</span>

type Contact_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        // The identifying name of the contact person/organization.
        Name string
        // The URL pointing to the contact information. MUST be in the format of a
        // URL.
        Url string
        // The email address of the contact person/organization. MUST be in the format
        // of an email address.
        Email string
}

func (b0 Contact_builder) Build() *Contact <span class="cov0" title="0">{
        m0 := &amp;Contact{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.Name = b.Name
        x.Url = b.Url
        x.Email = b.Email
        return m0
}</span>

// `License` is a representation of OpenAPI v2 specification's License object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#licenseObject
//
// Example:
//
//        option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
//          info: {
//            ...
//            license: {
//              name: "BSD 3-Clause License";
//              url: "https://github.com/grpc-ecosystem/grpc-gateway/blob/main/LICENSE";
//            };
//            ...
//          };
//          ...
//        };
type License struct {
        state protoimpl.MessageState `protogen:"hybrid.v1"`
        // The license name used for the API.
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // A URL to the license used for the API. MUST be in the format of a URL.
        Url           string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *License) Reset() <span class="cov0" title="0">{
        *x = License{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *License) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*License) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *License) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *License) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *License) GetUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Url
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *License) SetName(v string) <span class="cov0" title="0">{
        x.Name = v
}</span>

func (x *License) SetUrl(v string) <span class="cov0" title="0">{
        x.Url = v
}</span>

type License_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        // The license name used for the API.
        Name string
        // A URL to the license used for the API. MUST be in the format of a URL.
        Url string
}

func (b0 License_builder) Build() *License <span class="cov0" title="0">{
        m0 := &amp;License{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.Name = b.Name
        x.Url = b.Url
        return m0
}</span>

// `ExternalDocumentation` is a representation of OpenAPI v2 specification's
// ExternalDocumentation object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#externalDocumentationObject
//
// Example:
//
//        option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
//          ...
//          external_docs: {
//            description: "More about gRPC-Gateway";
//            url: "https://github.com/grpc-ecosystem/grpc-gateway";
//          }
//          ...
//        };
type ExternalDocumentation struct {
        state protoimpl.MessageState `protogen:"hybrid.v1"`
        // A short description of the target documentation. GFM syntax can be used for
        // rich text representation.
        Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
        // The URL for the target documentation. Value MUST be in the format
        // of a URL.
        Url           string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ExternalDocumentation) Reset() <span class="cov0" title="0">{
        *x = ExternalDocumentation{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ExternalDocumentation) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ExternalDocumentation) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ExternalDocumentation) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *ExternalDocumentation) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ExternalDocumentation) GetUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Url
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ExternalDocumentation) SetDescription(v string) <span class="cov0" title="0">{
        x.Description = v
}</span>

func (x *ExternalDocumentation) SetUrl(v string) <span class="cov0" title="0">{
        x.Url = v
}</span>

type ExternalDocumentation_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        // A short description of the target documentation. GFM syntax can be used for
        // rich text representation.
        Description string
        // The URL for the target documentation. Value MUST be in the format
        // of a URL.
        Url string
}

func (b0 ExternalDocumentation_builder) Build() *ExternalDocumentation <span class="cov0" title="0">{
        m0 := &amp;ExternalDocumentation{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.Description = b.Description
        x.Url = b.Url
        return m0
}</span>

// `Schema` is a representation of OpenAPI v2 specification's Schema object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#schemaObject
type Schema struct {
        state      protoimpl.MessageState `protogen:"hybrid.v1"`
        JsonSchema *JSONSchema            `protobuf:"bytes,1,opt,name=json_schema,json=jsonSchema,proto3" json:"json_schema,omitempty"`
        // Adds support for polymorphism. The discriminator is the schema property
        // name that is used to differentiate between other schema that inherit this
        // schema. The property name used MUST be defined at this schema and it MUST
        // be in the required property list. When used, the value MUST be the name of
        // this schema or any schema that inherits it.
        Discriminator string `protobuf:"bytes,2,opt,name=discriminator,proto3" json:"discriminator,omitempty"`
        // Relevant only for Schema "properties" definitions. Declares the property as
        // "read only". This means that it MAY be sent as part of a response but MUST
        // NOT be sent as part of the request. Properties marked as readOnly being
        // true SHOULD NOT be in the required list of the defined schema. Default
        // value is false.
        ReadOnly bool `protobuf:"varint,3,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
        // Additional external documentation for this schema.
        ExternalDocs *ExternalDocumentation `protobuf:"bytes,5,opt,name=external_docs,json=externalDocs,proto3" json:"external_docs,omitempty"`
        // A free-form property to include an example of an instance for this schema in JSON.
        // This is copied verbatim to the output.
        Example       string `protobuf:"bytes,6,opt,name=example,proto3" json:"example,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Schema) Reset() <span class="cov0" title="0">{
        *x = Schema{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Schema) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Schema) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Schema) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *Schema) GetJsonSchema() *JSONSchema <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.JsonSchema
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Schema) GetDiscriminator() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Discriminator
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Schema) GetReadOnly() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ReadOnly
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *Schema) GetExternalDocs() *ExternalDocumentation <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExternalDocs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Schema) GetExample() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Example
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Schema) SetJsonSchema(v *JSONSchema) <span class="cov0" title="0">{
        x.JsonSchema = v
}</span>

func (x *Schema) SetDiscriminator(v string) <span class="cov0" title="0">{
        x.Discriminator = v
}</span>

func (x *Schema) SetReadOnly(v bool) <span class="cov0" title="0">{
        x.ReadOnly = v
}</span>

func (x *Schema) SetExternalDocs(v *ExternalDocumentation) <span class="cov0" title="0">{
        x.ExternalDocs = v
}</span>

func (x *Schema) SetExample(v string) <span class="cov0" title="0">{
        x.Example = v
}</span>

func (x *Schema) HasJsonSchema() bool <span class="cov0" title="0">{
        if x == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return x.JsonSchema != nil</span>
}

func (x *Schema) HasExternalDocs() bool <span class="cov0" title="0">{
        if x == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return x.ExternalDocs != nil</span>
}

func (x *Schema) ClearJsonSchema() <span class="cov0" title="0">{
        x.JsonSchema = nil
}</span>

func (x *Schema) ClearExternalDocs() <span class="cov0" title="0">{
        x.ExternalDocs = nil
}</span>

type Schema_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        JsonSchema *JSONSchema
        // Adds support for polymorphism. The discriminator is the schema property
        // name that is used to differentiate between other schema that inherit this
        // schema. The property name used MUST be defined at this schema and it MUST
        // be in the required property list. When used, the value MUST be the name of
        // this schema or any schema that inherits it.
        Discriminator string
        // Relevant only for Schema "properties" definitions. Declares the property as
        // "read only". This means that it MAY be sent as part of a response but MUST
        // NOT be sent as part of the request. Properties marked as readOnly being
        // true SHOULD NOT be in the required list of the defined schema. Default
        // value is false.
        ReadOnly bool
        // Additional external documentation for this schema.
        ExternalDocs *ExternalDocumentation
        // A free-form property to include an example of an instance for this schema in JSON.
        // This is copied verbatim to the output.
        Example string
}

func (b0 Schema_builder) Build() *Schema <span class="cov0" title="0">{
        m0 := &amp;Schema{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.JsonSchema = b.JsonSchema
        x.Discriminator = b.Discriminator
        x.ReadOnly = b.ReadOnly
        x.ExternalDocs = b.ExternalDocs
        x.Example = b.Example
        return m0
}</span>

// `EnumSchema` is subset of fields from the OpenAPI v2 specification's Schema object.
// Only fields that are applicable to Enums are included
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#schemaObject
//
// Example:
//
//        option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_enum) = {
//          ...
//          title: "MyEnum";
//          description:"This is my nice enum";
//          example: "ZERO";
//          required: true;
//          ...
//        };
type EnumSchema struct {
        state protoimpl.MessageState `protogen:"hybrid.v1"`
        // A short description of the schema.
        Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
        Default     string `protobuf:"bytes,2,opt,name=default,proto3" json:"default,omitempty"`
        // The title of the schema.
        Title    string `protobuf:"bytes,3,opt,name=title,proto3" json:"title,omitempty"`
        Required bool   `protobuf:"varint,4,opt,name=required,proto3" json:"required,omitempty"`
        ReadOnly bool   `protobuf:"varint,5,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
        // Additional external documentation for this schema.
        ExternalDocs *ExternalDocumentation `protobuf:"bytes,6,opt,name=external_docs,json=externalDocs,proto3" json:"external_docs,omitempty"`
        Example      string                 `protobuf:"bytes,7,opt,name=example,proto3" json:"example,omitempty"`
        // Ref is used to define an external reference to include in the message.
        // This could be a fully qualified proto message reference, and that type must
        // be imported into the protofile. If no message is identified, the Ref will
        // be used verbatim in the output.
        // For example:
        //
        //        `ref: ".google.protobuf.Timestamp"`.
        Ref string `protobuf:"bytes,8,opt,name=ref,proto3" json:"ref,omitempty"`
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions    map[string]*structpb.Value `protobuf:"bytes,9,rep,name=extensions,proto3" json:"extensions,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *EnumSchema) Reset() <span class="cov0" title="0">{
        *x = EnumSchema{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[11]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *EnumSchema) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*EnumSchema) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *EnumSchema) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[11]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *EnumSchema) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *EnumSchema) GetDefault() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Default
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *EnumSchema) GetTitle() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Title
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *EnumSchema) GetRequired() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Required
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *EnumSchema) GetReadOnly() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ReadOnly
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *EnumSchema) GetExternalDocs() *ExternalDocumentation <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExternalDocs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *EnumSchema) GetExample() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Example
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *EnumSchema) GetRef() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Ref
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *EnumSchema) GetExtensions() map[string]*structpb.Value <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Extensions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *EnumSchema) SetDescription(v string) <span class="cov0" title="0">{
        x.Description = v
}</span>

func (x *EnumSchema) SetDefault(v string) <span class="cov0" title="0">{
        x.Default = v
}</span>

func (x *EnumSchema) SetTitle(v string) <span class="cov0" title="0">{
        x.Title = v
}</span>

func (x *EnumSchema) SetRequired(v bool) <span class="cov0" title="0">{
        x.Required = v
}</span>

func (x *EnumSchema) SetReadOnly(v bool) <span class="cov0" title="0">{
        x.ReadOnly = v
}</span>

func (x *EnumSchema) SetExternalDocs(v *ExternalDocumentation) <span class="cov0" title="0">{
        x.ExternalDocs = v
}</span>

func (x *EnumSchema) SetExample(v string) <span class="cov0" title="0">{
        x.Example = v
}</span>

func (x *EnumSchema) SetRef(v string) <span class="cov0" title="0">{
        x.Ref = v
}</span>

func (x *EnumSchema) SetExtensions(v map[string]*structpb.Value) <span class="cov0" title="0">{
        x.Extensions = v
}</span>

func (x *EnumSchema) HasExternalDocs() bool <span class="cov0" title="0">{
        if x == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return x.ExternalDocs != nil</span>
}

func (x *EnumSchema) ClearExternalDocs() <span class="cov0" title="0">{
        x.ExternalDocs = nil
}</span>

type EnumSchema_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        // A short description of the schema.
        Description string
        Default     string
        // The title of the schema.
        Title    string
        Required bool
        ReadOnly bool
        // Additional external documentation for this schema.
        ExternalDocs *ExternalDocumentation
        Example      string
        // Ref is used to define an external reference to include in the message.
        // This could be a fully qualified proto message reference, and that type must
        // be imported into the protofile. If no message is identified, the Ref will
        // be used verbatim in the output.
        // For example:
        //
        //        `ref: ".google.protobuf.Timestamp"`.
        Ref string
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions map[string]*structpb.Value
}

func (b0 EnumSchema_builder) Build() *EnumSchema <span class="cov0" title="0">{
        m0 := &amp;EnumSchema{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.Description = b.Description
        x.Default = b.Default
        x.Title = b.Title
        x.Required = b.Required
        x.ReadOnly = b.ReadOnly
        x.ExternalDocs = b.ExternalDocs
        x.Example = b.Example
        x.Ref = b.Ref
        x.Extensions = b.Extensions
        return m0
}</span>

// `JSONSchema` represents properties from JSON Schema taken, and as used, in
// the OpenAPI v2 spec.
//
// This includes changes made by OpenAPI v2.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#schemaObject
//
// See also: https://cswr.github.io/JsonSchema/spec/basic_types/,
// https://github.com/json-schema-org/json-schema-spec/blob/master/schema.json
//
// Example:
//
//        message SimpleMessage {
//          option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
//            json_schema: {
//              title: "SimpleMessage"
//              description: "A simple message."
//              required: ["id"]
//            }
//          };
//
//          // Id represents the message identifier.
//          string id = 1; [
//              (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
//                description: "The unique identifier of the simple message."
//              }];
//        }
type JSONSchema struct {
        state protoimpl.MessageState `protogen:"hybrid.v1"`
        // Ref is used to define an external reference to include in the message.
        // This could be a fully qualified proto message reference, and that type must
        // be imported into the protofile. If no message is identified, the Ref will
        // be used verbatim in the output.
        // For example:
        //
        //        `ref: ".google.protobuf.Timestamp"`.
        Ref string `protobuf:"bytes,3,opt,name=ref,proto3" json:"ref,omitempty"`
        // The title of the schema.
        Title string `protobuf:"bytes,5,opt,name=title,proto3" json:"title,omitempty"`
        // A short description of the schema.
        Description string `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
        Default     string `protobuf:"bytes,7,opt,name=default,proto3" json:"default,omitempty"`
        ReadOnly    bool   `protobuf:"varint,8,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
        // A free-form property to include a JSON example of this field. This is copied
        // verbatim to the output swagger.json. Quotes must be escaped.
        // This property is the same for 2.0 and 3.0.0 https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/3.0.0.md#schemaObject  https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#schemaObject
        Example    string  `protobuf:"bytes,9,opt,name=example,proto3" json:"example,omitempty"`
        MultipleOf float64 `protobuf:"fixed64,10,opt,name=multiple_of,json=multipleOf,proto3" json:"multiple_of,omitempty"`
        // Maximum represents an inclusive upper limit for a numeric instance. The
        // value of MUST be a number,
        Maximum          float64 `protobuf:"fixed64,11,opt,name=maximum,proto3" json:"maximum,omitempty"`
        ExclusiveMaximum bool    `protobuf:"varint,12,opt,name=exclusive_maximum,json=exclusiveMaximum,proto3" json:"exclusive_maximum,omitempty"`
        // minimum represents an inclusive lower limit for a numeric instance. The
        // value of MUST be a number,
        Minimum          float64  `protobuf:"fixed64,13,opt,name=minimum,proto3" json:"minimum,omitempty"`
        ExclusiveMinimum bool     `protobuf:"varint,14,opt,name=exclusive_minimum,json=exclusiveMinimum,proto3" json:"exclusive_minimum,omitempty"`
        MaxLength        uint64   `protobuf:"varint,15,opt,name=max_length,json=maxLength,proto3" json:"max_length,omitempty"`
        MinLength        uint64   `protobuf:"varint,16,opt,name=min_length,json=minLength,proto3" json:"min_length,omitempty"`
        Pattern          string   `protobuf:"bytes,17,opt,name=pattern,proto3" json:"pattern,omitempty"`
        MaxItems         uint64   `protobuf:"varint,20,opt,name=max_items,json=maxItems,proto3" json:"max_items,omitempty"`
        MinItems         uint64   `protobuf:"varint,21,opt,name=min_items,json=minItems,proto3" json:"min_items,omitempty"`
        UniqueItems      bool     `protobuf:"varint,22,opt,name=unique_items,json=uniqueItems,proto3" json:"unique_items,omitempty"`
        MaxProperties    uint64   `protobuf:"varint,24,opt,name=max_properties,json=maxProperties,proto3" json:"max_properties,omitempty"`
        MinProperties    uint64   `protobuf:"varint,25,opt,name=min_properties,json=minProperties,proto3" json:"min_properties,omitempty"`
        Required         []string `protobuf:"bytes,26,rep,name=required,proto3" json:"required,omitempty"`
        // Items in 'array' must be unique.
        Array []string                           `protobuf:"bytes,34,rep,name=array,proto3" json:"array,omitempty"`
        Type  []JSONSchema_JSONSchemaSimpleTypes `protobuf:"varint,35,rep,packed,name=type,proto3,enum=grpc.gateway.protoc_gen_openapiv2.options.JSONSchema_JSONSchemaSimpleTypes" json:"type,omitempty"`
        // `Format`
        Format string `protobuf:"bytes,36,opt,name=format,proto3" json:"format,omitempty"`
        // Items in `enum` must be unique https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.5.1
        Enum []string `protobuf:"bytes,46,rep,name=enum,proto3" json:"enum,omitempty"`
        // Additional field level properties used when generating the OpenAPI v2 file.
        FieldConfiguration *JSONSchema_FieldConfiguration `protobuf:"bytes,1001,opt,name=field_configuration,json=fieldConfiguration,proto3" json:"field_configuration,omitempty"`
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions    map[string]*structpb.Value `protobuf:"bytes,48,rep,name=extensions,proto3" json:"extensions,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *JSONSchema) Reset() <span class="cov0" title="0">{
        *x = JSONSchema{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[12]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *JSONSchema) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*JSONSchema) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *JSONSchema) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[12]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *JSONSchema) GetRef() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Ref
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *JSONSchema) GetTitle() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Title
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *JSONSchema) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *JSONSchema) GetDefault() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Default
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *JSONSchema) GetReadOnly() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ReadOnly
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *JSONSchema) GetExample() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Example
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *JSONSchema) GetMultipleOf() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MultipleOf
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *JSONSchema) GetMaximum() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Maximum
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *JSONSchema) GetExclusiveMaximum() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExclusiveMaximum
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *JSONSchema) GetMinimum() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Minimum
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *JSONSchema) GetExclusiveMinimum() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExclusiveMinimum
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *JSONSchema) GetMaxLength() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxLength
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *JSONSchema) GetMinLength() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MinLength
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *JSONSchema) GetPattern() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Pattern
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *JSONSchema) GetMaxItems() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxItems
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *JSONSchema) GetMinItems() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MinItems
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *JSONSchema) GetUniqueItems() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UniqueItems
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *JSONSchema) GetMaxProperties() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxProperties
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *JSONSchema) GetMinProperties() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MinProperties
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *JSONSchema) GetRequired() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Required
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *JSONSchema) GetArray() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Array
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *JSONSchema) GetType() []JSONSchema_JSONSchemaSimpleTypes <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *JSONSchema) GetFormat() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Format
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *JSONSchema) GetEnum() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Enum
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *JSONSchema) GetFieldConfiguration() *JSONSchema_FieldConfiguration <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FieldConfiguration
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *JSONSchema) GetExtensions() map[string]*structpb.Value <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Extensions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *JSONSchema) SetRef(v string) <span class="cov0" title="0">{
        x.Ref = v
}</span>

func (x *JSONSchema) SetTitle(v string) <span class="cov0" title="0">{
        x.Title = v
}</span>

func (x *JSONSchema) SetDescription(v string) <span class="cov0" title="0">{
        x.Description = v
}</span>

func (x *JSONSchema) SetDefault(v string) <span class="cov0" title="0">{
        x.Default = v
}</span>

func (x *JSONSchema) SetReadOnly(v bool) <span class="cov0" title="0">{
        x.ReadOnly = v
}</span>

func (x *JSONSchema) SetExample(v string) <span class="cov0" title="0">{
        x.Example = v
}</span>

func (x *JSONSchema) SetMultipleOf(v float64) <span class="cov0" title="0">{
        x.MultipleOf = v
}</span>

func (x *JSONSchema) SetMaximum(v float64) <span class="cov0" title="0">{
        x.Maximum = v
}</span>

func (x *JSONSchema) SetExclusiveMaximum(v bool) <span class="cov0" title="0">{
        x.ExclusiveMaximum = v
}</span>

func (x *JSONSchema) SetMinimum(v float64) <span class="cov0" title="0">{
        x.Minimum = v
}</span>

func (x *JSONSchema) SetExclusiveMinimum(v bool) <span class="cov0" title="0">{
        x.ExclusiveMinimum = v
}</span>

func (x *JSONSchema) SetMaxLength(v uint64) <span class="cov0" title="0">{
        x.MaxLength = v
}</span>

func (x *JSONSchema) SetMinLength(v uint64) <span class="cov0" title="0">{
        x.MinLength = v
}</span>

func (x *JSONSchema) SetPattern(v string) <span class="cov0" title="0">{
        x.Pattern = v
}</span>

func (x *JSONSchema) SetMaxItems(v uint64) <span class="cov0" title="0">{
        x.MaxItems = v
}</span>

func (x *JSONSchema) SetMinItems(v uint64) <span class="cov0" title="0">{
        x.MinItems = v
}</span>

func (x *JSONSchema) SetUniqueItems(v bool) <span class="cov0" title="0">{
        x.UniqueItems = v
}</span>

func (x *JSONSchema) SetMaxProperties(v uint64) <span class="cov0" title="0">{
        x.MaxProperties = v
}</span>

func (x *JSONSchema) SetMinProperties(v uint64) <span class="cov0" title="0">{
        x.MinProperties = v
}</span>

func (x *JSONSchema) SetRequired(v []string) <span class="cov0" title="0">{
        x.Required = v
}</span>

func (x *JSONSchema) SetArray(v []string) <span class="cov0" title="0">{
        x.Array = v
}</span>

func (x *JSONSchema) SetType(v []JSONSchema_JSONSchemaSimpleTypes) <span class="cov0" title="0">{
        x.Type = v
}</span>

func (x *JSONSchema) SetFormat(v string) <span class="cov0" title="0">{
        x.Format = v
}</span>

func (x *JSONSchema) SetEnum(v []string) <span class="cov0" title="0">{
        x.Enum = v
}</span>

func (x *JSONSchema) SetFieldConfiguration(v *JSONSchema_FieldConfiguration) <span class="cov0" title="0">{
        x.FieldConfiguration = v
}</span>

func (x *JSONSchema) SetExtensions(v map[string]*structpb.Value) <span class="cov0" title="0">{
        x.Extensions = v
}</span>

func (x *JSONSchema) HasFieldConfiguration() bool <span class="cov0" title="0">{
        if x == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return x.FieldConfiguration != nil</span>
}

func (x *JSONSchema) ClearFieldConfiguration() <span class="cov0" title="0">{
        x.FieldConfiguration = nil
}</span>

type JSONSchema_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        // Ref is used to define an external reference to include in the message.
        // This could be a fully qualified proto message reference, and that type must
        // be imported into the protofile. If no message is identified, the Ref will
        // be used verbatim in the output.
        // For example:
        //
        //        `ref: ".google.protobuf.Timestamp"`.
        Ref string
        // The title of the schema.
        Title string
        // A short description of the schema.
        Description string
        Default     string
        ReadOnly    bool
        // A free-form property to include a JSON example of this field. This is copied
        // verbatim to the output swagger.json. Quotes must be escaped.
        // This property is the same for 2.0 and 3.0.0 https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/3.0.0.md#schemaObject  https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#schemaObject
        Example    string
        MultipleOf float64
        // Maximum represents an inclusive upper limit for a numeric instance. The
        // value of MUST be a number,
        Maximum          float64
        ExclusiveMaximum bool
        // minimum represents an inclusive lower limit for a numeric instance. The
        // value of MUST be a number,
        Minimum          float64
        ExclusiveMinimum bool
        MaxLength        uint64
        MinLength        uint64
        Pattern          string
        MaxItems         uint64
        MinItems         uint64
        UniqueItems      bool
        MaxProperties    uint64
        MinProperties    uint64
        Required         []string
        // Items in 'array' must be unique.
        Array []string
        Type  []JSONSchema_JSONSchemaSimpleTypes
        // `Format`
        Format string
        // Items in `enum` must be unique https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.5.1
        Enum []string
        // Additional field level properties used when generating the OpenAPI v2 file.
        FieldConfiguration *JSONSchema_FieldConfiguration
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions map[string]*structpb.Value
}

func (b0 JSONSchema_builder) Build() *JSONSchema <span class="cov0" title="0">{
        m0 := &amp;JSONSchema{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.Ref = b.Ref
        x.Title = b.Title
        x.Description = b.Description
        x.Default = b.Default
        x.ReadOnly = b.ReadOnly
        x.Example = b.Example
        x.MultipleOf = b.MultipleOf
        x.Maximum = b.Maximum
        x.ExclusiveMaximum = b.ExclusiveMaximum
        x.Minimum = b.Minimum
        x.ExclusiveMinimum = b.ExclusiveMinimum
        x.MaxLength = b.MaxLength
        x.MinLength = b.MinLength
        x.Pattern = b.Pattern
        x.MaxItems = b.MaxItems
        x.MinItems = b.MinItems
        x.UniqueItems = b.UniqueItems
        x.MaxProperties = b.MaxProperties
        x.MinProperties = b.MinProperties
        x.Required = b.Required
        x.Array = b.Array
        x.Type = b.Type
        x.Format = b.Format
        x.Enum = b.Enum
        x.FieldConfiguration = b.FieldConfiguration
        x.Extensions = b.Extensions
        return m0
}</span>

// `Tag` is a representation of OpenAPI v2 specification's Tag object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#tagObject
type Tag struct {
        state protoimpl.MessageState `protogen:"hybrid.v1"`
        // The name of the tag. Use it to allow override of the name of a
        // global Tag object, then use that name to reference the tag throughout the
        // OpenAPI file.
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // A short description for the tag. GFM syntax can be used for rich text
        // representation.
        Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
        // Additional external documentation for this tag.
        ExternalDocs *ExternalDocumentation `protobuf:"bytes,3,opt,name=external_docs,json=externalDocs,proto3" json:"external_docs,omitempty"`
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions    map[string]*structpb.Value `protobuf:"bytes,4,rep,name=extensions,proto3" json:"extensions,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Tag) Reset() <span class="cov0" title="0">{
        *x = Tag{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[13]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Tag) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Tag) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Tag) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[13]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *Tag) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Tag) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Tag) GetExternalDocs() *ExternalDocumentation <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExternalDocs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Tag) GetExtensions() map[string]*structpb.Value <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Extensions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Tag) SetName(v string) <span class="cov0" title="0">{
        x.Name = v
}</span>

func (x *Tag) SetDescription(v string) <span class="cov0" title="0">{
        x.Description = v
}</span>

func (x *Tag) SetExternalDocs(v *ExternalDocumentation) <span class="cov0" title="0">{
        x.ExternalDocs = v
}</span>

func (x *Tag) SetExtensions(v map[string]*structpb.Value) <span class="cov0" title="0">{
        x.Extensions = v
}</span>

func (x *Tag) HasExternalDocs() bool <span class="cov0" title="0">{
        if x == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return x.ExternalDocs != nil</span>
}

func (x *Tag) ClearExternalDocs() <span class="cov0" title="0">{
        x.ExternalDocs = nil
}</span>

type Tag_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        // The name of the tag. Use it to allow override of the name of a
        // global Tag object, then use that name to reference the tag throughout the
        // OpenAPI file.
        Name string
        // A short description for the tag. GFM syntax can be used for rich text
        // representation.
        Description string
        // Additional external documentation for this tag.
        ExternalDocs *ExternalDocumentation
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions map[string]*structpb.Value
}

func (b0 Tag_builder) Build() *Tag <span class="cov0" title="0">{
        m0 := &amp;Tag{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.Name = b.Name
        x.Description = b.Description
        x.ExternalDocs = b.ExternalDocs
        x.Extensions = b.Extensions
        return m0
}</span>

// `SecurityDefinitions` is a representation of OpenAPI v2 specification's
// Security Definitions object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#securityDefinitionsObject
//
// A declaration of the security schemes available to be used in the
// specification. This does not enforce the security schemes on the operations
// and only serves to provide the relevant details for each scheme.
type SecurityDefinitions struct {
        state protoimpl.MessageState `protogen:"hybrid.v1"`
        // A single security scheme definition, mapping a "name" to the scheme it
        // defines.
        Security      map[string]*SecurityScheme `protobuf:"bytes,1,rep,name=security,proto3" json:"security,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SecurityDefinitions) Reset() <span class="cov0" title="0">{
        *x = SecurityDefinitions{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[14]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SecurityDefinitions) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SecurityDefinitions) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SecurityDefinitions) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[14]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *SecurityDefinitions) GetSecurity() map[string]*SecurityScheme <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Security
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SecurityDefinitions) SetSecurity(v map[string]*SecurityScheme) <span class="cov0" title="0">{
        x.Security = v
}</span>

type SecurityDefinitions_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        // A single security scheme definition, mapping a "name" to the scheme it
        // defines.
        Security map[string]*SecurityScheme
}

func (b0 SecurityDefinitions_builder) Build() *SecurityDefinitions <span class="cov0" title="0">{
        m0 := &amp;SecurityDefinitions{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.Security = b.Security
        return m0
}</span>

// `SecurityScheme` is a representation of OpenAPI v2 specification's
// Security Scheme object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#securitySchemeObject
//
// Allows the definition of a security scheme that can be used by the
// operations. Supported schemes are basic authentication, an API key (either as
// a header or as a query parameter) and OAuth2's common flows (implicit,
// password, application and access code).
type SecurityScheme struct {
        state protoimpl.MessageState `protogen:"hybrid.v1"`
        // The type of the security scheme. Valid values are "basic",
        // "apiKey" or "oauth2".
        Type SecurityScheme_Type `protobuf:"varint,1,opt,name=type,proto3,enum=grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme_Type" json:"type,omitempty"`
        // A short description for security scheme.
        Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
        // The name of the header or query parameter to be used.
        // Valid for apiKey.
        Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
        // The location of the API key. Valid values are "query" or
        // "header".
        // Valid for apiKey.
        In SecurityScheme_In `protobuf:"varint,4,opt,name=in,proto3,enum=grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme_In" json:"in,omitempty"`
        // The flow used by the OAuth2 security scheme. Valid values are
        // "implicit", "password", "application" or "accessCode".
        // Valid for oauth2.
        Flow SecurityScheme_Flow `protobuf:"varint,5,opt,name=flow,proto3,enum=grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme_Flow" json:"flow,omitempty"`
        // The authorization URL to be used for this flow. This SHOULD be in
        // the form of a URL.
        // Valid for oauth2/implicit and oauth2/accessCode.
        AuthorizationUrl string `protobuf:"bytes,6,opt,name=authorization_url,json=authorizationUrl,proto3" json:"authorization_url,omitempty"`
        // The token URL to be used for this flow. This SHOULD be in the
        // form of a URL.
        // Valid for oauth2/password, oauth2/application and oauth2/accessCode.
        TokenUrl string `protobuf:"bytes,7,opt,name=token_url,json=tokenUrl,proto3" json:"token_url,omitempty"`
        // The available scopes for the OAuth2 security scheme.
        // Valid for oauth2.
        Scopes *Scopes `protobuf:"bytes,8,opt,name=scopes,proto3" json:"scopes,omitempty"`
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions    map[string]*structpb.Value `protobuf:"bytes,9,rep,name=extensions,proto3" json:"extensions,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SecurityScheme) Reset() <span class="cov0" title="0">{
        *x = SecurityScheme{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[15]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SecurityScheme) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SecurityScheme) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SecurityScheme) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[15]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *SecurityScheme) GetType() SecurityScheme_Type <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return SecurityScheme_TYPE_INVALID</span>
}

func (x *SecurityScheme) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SecurityScheme) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SecurityScheme) GetIn() SecurityScheme_In <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return SecurityScheme_IN_INVALID</span>
}

func (x *SecurityScheme) GetFlow() SecurityScheme_Flow <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Flow
        }</span>
        <span class="cov0" title="0">return SecurityScheme_FLOW_INVALID</span>
}

func (x *SecurityScheme) GetAuthorizationUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AuthorizationUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SecurityScheme) GetTokenUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TokenUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SecurityScheme) GetScopes() *Scopes <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Scopes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SecurityScheme) GetExtensions() map[string]*structpb.Value <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Extensions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SecurityScheme) SetType(v SecurityScheme_Type) <span class="cov0" title="0">{
        x.Type = v
}</span>

func (x *SecurityScheme) SetDescription(v string) <span class="cov0" title="0">{
        x.Description = v
}</span>

func (x *SecurityScheme) SetName(v string) <span class="cov0" title="0">{
        x.Name = v
}</span>

func (x *SecurityScheme) SetIn(v SecurityScheme_In) <span class="cov0" title="0">{
        x.In = v
}</span>

func (x *SecurityScheme) SetFlow(v SecurityScheme_Flow) <span class="cov0" title="0">{
        x.Flow = v
}</span>

func (x *SecurityScheme) SetAuthorizationUrl(v string) <span class="cov0" title="0">{
        x.AuthorizationUrl = v
}</span>

func (x *SecurityScheme) SetTokenUrl(v string) <span class="cov0" title="0">{
        x.TokenUrl = v
}</span>

func (x *SecurityScheme) SetScopes(v *Scopes) <span class="cov0" title="0">{
        x.Scopes = v
}</span>

func (x *SecurityScheme) SetExtensions(v map[string]*structpb.Value) <span class="cov0" title="0">{
        x.Extensions = v
}</span>

func (x *SecurityScheme) HasScopes() bool <span class="cov0" title="0">{
        if x == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return x.Scopes != nil</span>
}

func (x *SecurityScheme) ClearScopes() <span class="cov0" title="0">{
        x.Scopes = nil
}</span>

type SecurityScheme_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        // The type of the security scheme. Valid values are "basic",
        // "apiKey" or "oauth2".
        Type SecurityScheme_Type
        // A short description for security scheme.
        Description string
        // The name of the header or query parameter to be used.
        // Valid for apiKey.
        Name string
        // The location of the API key. Valid values are "query" or
        // "header".
        // Valid for apiKey.
        In SecurityScheme_In
        // The flow used by the OAuth2 security scheme. Valid values are
        // "implicit", "password", "application" or "accessCode".
        // Valid for oauth2.
        Flow SecurityScheme_Flow
        // The authorization URL to be used for this flow. This SHOULD be in
        // the form of a URL.
        // Valid for oauth2/implicit and oauth2/accessCode.
        AuthorizationUrl string
        // The token URL to be used for this flow. This SHOULD be in the
        // form of a URL.
        // Valid for oauth2/password, oauth2/application and oauth2/accessCode.
        TokenUrl string
        // The available scopes for the OAuth2 security scheme.
        // Valid for oauth2.
        Scopes *Scopes
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions map[string]*structpb.Value
}

func (b0 SecurityScheme_builder) Build() *SecurityScheme <span class="cov0" title="0">{
        m0 := &amp;SecurityScheme{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.Type = b.Type
        x.Description = b.Description
        x.Name = b.Name
        x.In = b.In
        x.Flow = b.Flow
        x.AuthorizationUrl = b.AuthorizationUrl
        x.TokenUrl = b.TokenUrl
        x.Scopes = b.Scopes
        x.Extensions = b.Extensions
        return m0
}</span>

// `SecurityRequirement` is a representation of OpenAPI v2 specification's
// Security Requirement object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#securityRequirementObject
//
// Lists the required security schemes to execute this operation. The object can
// have multiple security schemes declared in it which are all required (that
// is, there is a logical AND between the schemes).
//
// The name used for each property MUST correspond to a security scheme
// declared in the Security Definitions.
type SecurityRequirement struct {
        state protoimpl.MessageState `protogen:"hybrid.v1"`
        // Each name must correspond to a security scheme which is declared in
        // the Security Definitions. If the security scheme is of type "oauth2",
        // then the value is a list of scope names required for the execution.
        // For other security scheme types, the array MUST be empty.
        SecurityRequirement map[string]*SecurityRequirement_SecurityRequirementValue `protobuf:"bytes,1,rep,name=security_requirement,json=securityRequirement,proto3" json:"security_requirement,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields       protoimpl.UnknownFields
        sizeCache           protoimpl.SizeCache
}

func (x *SecurityRequirement) Reset() <span class="cov0" title="0">{
        *x = SecurityRequirement{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[16]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SecurityRequirement) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SecurityRequirement) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SecurityRequirement) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[16]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *SecurityRequirement) GetSecurityRequirement() map[string]*SecurityRequirement_SecurityRequirementValue <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SecurityRequirement
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SecurityRequirement) SetSecurityRequirement(v map[string]*SecurityRequirement_SecurityRequirementValue) <span class="cov0" title="0">{
        x.SecurityRequirement = v
}</span>

type SecurityRequirement_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        // Each name must correspond to a security scheme which is declared in
        // the Security Definitions. If the security scheme is of type "oauth2",
        // then the value is a list of scope names required for the execution.
        // For other security scheme types, the array MUST be empty.
        SecurityRequirement map[string]*SecurityRequirement_SecurityRequirementValue
}

func (b0 SecurityRequirement_builder) Build() *SecurityRequirement <span class="cov0" title="0">{
        m0 := &amp;SecurityRequirement{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.SecurityRequirement = b.SecurityRequirement
        return m0
}</span>

// `Scopes` is a representation of OpenAPI v2 specification's Scopes object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#scopesObject
//
// Lists the available scopes for an OAuth2 security scheme.
type Scopes struct {
        state protoimpl.MessageState `protogen:"hybrid.v1"`
        // Maps between a name of a scope to a short description of it (as the value
        // of the property).
        Scope         map[string]string `protobuf:"bytes,1,rep,name=scope,proto3" json:"scope,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Scopes) Reset() <span class="cov0" title="0">{
        *x = Scopes{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[17]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Scopes) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Scopes) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Scopes) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[17]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *Scopes) GetScope() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Scope
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Scopes) SetScope(v map[string]string) <span class="cov0" title="0">{
        x.Scope = v
}</span>

type Scopes_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        // Maps between a name of a scope to a short description of it (as the value
        // of the property).
        Scope map[string]string
}

func (b0 Scopes_builder) Build() *Scopes <span class="cov0" title="0">{
        m0 := &amp;Scopes{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.Scope = b.Scope
        return m0
}</span>

// 'FieldConfiguration' provides additional field level properties used when generating the OpenAPI v2 file.
// These properties are not defined by OpenAPIv2, but they are used to control the generation.
type JSONSchema_FieldConfiguration struct {
        state protoimpl.MessageState `protogen:"hybrid.v1"`
        // Alternative parameter name when used as path parameter. If set, this will
        // be used as the complete parameter name when this field is used as a path
        // parameter. Use this to avoid having auto generated path parameter names
        // for overlapping paths.
        PathParamName string `protobuf:"bytes,47,opt,name=path_param_name,json=pathParamName,proto3" json:"path_param_name,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *JSONSchema_FieldConfiguration) Reset() <span class="cov0" title="0">{
        *x = JSONSchema_FieldConfiguration{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[27]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *JSONSchema_FieldConfiguration) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*JSONSchema_FieldConfiguration) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *JSONSchema_FieldConfiguration) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[27]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *JSONSchema_FieldConfiguration) GetPathParamName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PathParamName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *JSONSchema_FieldConfiguration) SetPathParamName(v string) <span class="cov0" title="0">{
        x.PathParamName = v
}</span>

type JSONSchema_FieldConfiguration_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        // Alternative parameter name when used as path parameter. If set, this will
        // be used as the complete parameter name when this field is used as a path
        // parameter. Use this to avoid having auto generated path parameter names
        // for overlapping paths.
        PathParamName string
}

func (b0 JSONSchema_FieldConfiguration_builder) Build() *JSONSchema_FieldConfiguration <span class="cov0" title="0">{
        m0 := &amp;JSONSchema_FieldConfiguration{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.PathParamName = b.PathParamName
        return m0
}</span>

// If the security scheme is of type "oauth2", then the value is a list of
// scope names required for the execution. For other security scheme types,
// the array MUST be empty.
type SecurityRequirement_SecurityRequirementValue struct {
        state         protoimpl.MessageState `protogen:"hybrid.v1"`
        Scope         []string               `protobuf:"bytes,1,rep,name=scope,proto3" json:"scope,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SecurityRequirement_SecurityRequirementValue) Reset() <span class="cov0" title="0">{
        *x = SecurityRequirement_SecurityRequirementValue{}
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[32]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SecurityRequirement_SecurityRequirementValue) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SecurityRequirement_SecurityRequirementValue) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SecurityRequirement_SecurityRequirementValue) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[32]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

func (x *SecurityRequirement_SecurityRequirementValue) GetScope() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Scope
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SecurityRequirement_SecurityRequirementValue) SetScope(v []string) <span class="cov0" title="0">{
        x.Scope = v
}</span>

type SecurityRequirement_SecurityRequirementValue_builder struct {
        _ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

        Scope []string
}

func (b0 SecurityRequirement_SecurityRequirementValue_builder) Build() *SecurityRequirement_SecurityRequirementValue <span class="cov0" title="0">{
        m0 := &amp;SecurityRequirement_SecurityRequirementValue{}
        b, x := &amp;b0, m0
        _, _ = b, x
        x.Scope = b.Scope
        return m0
}</span>

var File_protoc_gen_openapiv2_options_openapiv2_proto protoreflect.FileDescriptor

var file_protoc_gen_openapiv2_options_openapiv2_proto_rawDesc = []byte{
        0x0a, 0x2c, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x2d, 0x67, 0x65, 0x6e, 0x2d, 0x6f, 0x70, 0x65,
        0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2f, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2f, 0x6f,
        0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x29,
        0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76,
        0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x1a, 0x1c, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
        0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x73, 0x74, 0x72, 0x75, 0x63,
        0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xb3, 0x08, 0x0a, 0x07, 0x53, 0x77, 0x61, 0x67,
        0x67, 0x65, 0x72, 0x12, 0x18, 0x0a, 0x07, 0x73, 0x77, 0x61, 0x67, 0x67, 0x65, 0x72, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x73, 0x77, 0x61, 0x67, 0x67, 0x65, 0x72, 0x12, 0x43, 0x0a,
        0x04, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x67, 0x72,
        0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e,
        0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x04, 0x69, 0x6e,
        0x66, 0x6f, 0x12, 0x12, 0x0a, 0x04, 0x68, 0x6f, 0x73, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x04, 0x68, 0x6f, 0x73, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x62, 0x61, 0x73, 0x65, 0x5f, 0x70,
        0x61, 0x74, 0x68, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x62, 0x61, 0x73, 0x65, 0x50,
        0x61, 0x74, 0x68, 0x12, 0x4b, 0x0a, 0x07, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x73, 0x18, 0x05,
        0x20, 0x03, 0x28, 0x0e, 0x32, 0x31, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65,
        0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f,
        0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73,
        0x2e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x52, 0x07, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x73,
        0x12, 0x1a, 0x0a, 0x08, 0x63, 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x65, 0x73, 0x18, 0x06, 0x20, 0x03,
        0x28, 0x09, 0x52, 0x08, 0x63, 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x65, 0x73, 0x12, 0x1a, 0x0a, 0x08,
        0x70, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x65, 0x73, 0x18, 0x07, 0x20, 0x03, 0x28, 0x09, 0x52, 0x08,
        0x70, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x65, 0x73, 0x12, 0x5f, 0x0a, 0x09, 0x72, 0x65, 0x73, 0x70,
        0x6f, 0x6e, 0x73, 0x65, 0x73, 0x18, 0x0a, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x41, 0x2e, 0x67, 0x72,
        0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e,
        0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x77, 0x61, 0x67, 0x67, 0x65, 0x72, 0x2e,
        0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x09,
        0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73, 0x12, 0x71, 0x0a, 0x14, 0x73, 0x65, 0x63,
        0x75, 0x72, 0x69, 0x74, 0x79, 0x5f, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e,
        0x73, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3e, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67,
        0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65,
        0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x44, 0x65, 0x66, 0x69,
        0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x13, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74,
        0x79, 0x44, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x5a, 0x0a, 0x08,
        0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x18, 0x0c, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x3e,
        0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69,
        0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72,
        0x69, 0x74, 0x79, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x52, 0x08,
        0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x12, 0x42, 0x0a, 0x04, 0x74, 0x61, 0x67, 0x73,
        0x18, 0x0d, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2e, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61,
        0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e,
        0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x73, 0x2e, 0x54, 0x61, 0x67, 0x52, 0x04, 0x74, 0x61, 0x67, 0x73, 0x12, 0x65, 0x0a, 0x0d,
        0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x5f, 0x64, 0x6f, 0x63, 0x73, 0x18, 0x0e, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x40, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77,
        0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70,
        0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e,
        0x45, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x44, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74,
        0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0c, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x44,
        0x6f, 0x63, 0x73, 0x12, 0x62, 0x0a, 0x0a, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e,
        0x73, 0x18, 0x0f, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x42, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67,
        0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65,
        0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x77, 0x61, 0x67, 0x67, 0x65, 0x72, 0x2e, 0x45, 0x78, 0x74, 0x65,
        0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0a, 0x65, 0x78, 0x74,
        0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x1a, 0x71, 0x0a, 0x0e, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x49, 0x0a, 0x05, 0x76,
        0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x33, 0x2e, 0x67, 0x72, 0x70,
        0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63,
        0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f,
        0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x52,
        0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x1a, 0x55, 0x0a, 0x0f, 0x45, 0x78,
        0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a,
        0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12,
        0x2c, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16,
        0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
        0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38,
        0x01, 0x4a, 0x04, 0x08, 0x08, 0x10, 0x09, 0x4a, 0x04, 0x08, 0x09, 0x10, 0x0a, 0x22, 0xd6, 0x07,
        0x0a, 0x09, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x12, 0x0a, 0x04, 0x74,
        0x61, 0x67, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x04, 0x74, 0x61, 0x67, 0x73, 0x12,
        0x18, 0x0a, 0x07, 0x73, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x07, 0x73, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73,
        0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b,
        0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x65, 0x0a, 0x0d, 0x65,
        0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x5f, 0x64, 0x6f, 0x63, 0x73, 0x18, 0x04, 0x20, 0x01,
        0x28, 0x0b, 0x32, 0x40, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61,
        0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65,
        0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x45,
        0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x44, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0c, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x44, 0x6f,
        0x63, 0x73, 0x12, 0x21, 0x0a, 0x0c, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f,
        0x69, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74,
        0x69, 0x6f, 0x6e, 0x49, 0x64, 0x12, 0x1a, 0x0a, 0x08, 0x63, 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x65,
        0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x09, 0x52, 0x08, 0x63, 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x65,
        0x73, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x65, 0x73, 0x18, 0x07, 0x20,
        0x03, 0x28, 0x09, 0x52, 0x08, 0x70, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x65, 0x73, 0x12, 0x61, 0x0a,
        0x09, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73, 0x18, 0x09, 0x20, 0x03, 0x28, 0x0b,
        0x32, 0x43, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61,
        0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x4f, 0x70, 0x65,
        0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73,
        0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x09, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73,
        0x12, 0x4b, 0x0a, 0x07, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x73, 0x18, 0x0a, 0x20, 0x03, 0x28,
        0x0e, 0x32, 0x31, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e,
        0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x63,
        0x68, 0x65, 0x6d, 0x65, 0x52, 0x07, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x73, 0x12, 0x1e, 0x0a,
        0x0a, 0x64, 0x65, 0x70, 0x72, 0x65, 0x63, 0x61, 0x74, 0x65, 0x64, 0x18, 0x0b, 0x20, 0x01, 0x28,
        0x08, 0x52, 0x0a, 0x64, 0x65, 0x70, 0x72, 0x65, 0x63, 0x61, 0x74, 0x65, 0x64, 0x12, 0x5a, 0x0a,
        0x08, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x18, 0x0c, 0x20, 0x03, 0x28, 0x0b, 0x32,
        0x3e, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70,
        0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x65, 0x63, 0x75,
        0x72, 0x69, 0x74, 0x79, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x52,
        0x08, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x12, 0x64, 0x0a, 0x0a, 0x65, 0x78, 0x74,
        0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x0d, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x44, 0x2e,
        0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76,
        0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74,
        0x69, 0x6f, 0x6e, 0x2e, 0x45, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e,
        0x74, 0x72, 0x79, 0x52, 0x0a, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x12,
        0x55, 0x0a, 0x0a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x18, 0x0e, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x35, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77,
        0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70,
        0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e,
        0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x0a, 0x70, 0x61, 0x72, 0x61,
        0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x1a, 0x71, 0x0a, 0x0e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
        0x73, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x49, 0x0a, 0x05, 0x76, 0x61,
        0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x33, 0x2e, 0x67, 0x72, 0x70, 0x63,
        0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f,
        0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70,
        0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x52, 0x05,
        0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x1a, 0x55, 0x0a, 0x0f, 0x45, 0x78, 0x74,
        0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03,
        0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x2c,
        0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e,
        0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e,
        0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01,
        0x4a, 0x04, 0x08, 0x08, 0x10, 0x09, 0x22, 0x62, 0x0a, 0x0a, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65,
        0x74, 0x65, 0x72, 0x73, 0x12, 0x54, 0x0a, 0x07, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x73, 0x18,
        0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x3a, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74,
        0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f,
        0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e,
        0x73, 0x2e, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65,
        0x72, 0x52, 0x07, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x73, 0x22, 0xa3, 0x02, 0x0a, 0x0f, 0x48,
        0x65, 0x61, 0x64, 0x65, 0x72, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x12, 0x12,
        0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61,
        0x6d, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
        0x74, 0x69, 0x6f, 0x6e, 0x12, 0x53, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x03, 0x20, 0x01,
        0x28, 0x0e, 0x32, 0x3f, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61,
        0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65,
        0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x48,
        0x65, 0x61, 0x64, 0x65, 0x72, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x2e, 0x54,
        0x79, 0x70, 0x65, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x66, 0x6f, 0x72,
        0x6d, 0x61, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x66, 0x6f, 0x72, 0x6d, 0x61,
        0x74, 0x12, 0x1a, 0x0a, 0x08, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x18, 0x05, 0x20,
        0x01, 0x28, 0x08, 0x52, 0x08, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x45, 0x0a,
        0x04, 0x54, 0x79, 0x70, 0x65, 0x12, 0x0b, 0x0a, 0x07, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e,
        0x10, 0x00, 0x12, 0x0a, 0x0a, 0x06, 0x53, 0x54, 0x52, 0x49, 0x4e, 0x47, 0x10, 0x01, 0x12, 0x0a,
        0x0a, 0x06, 0x4e, 0x55, 0x4d, 0x42, 0x45, 0x52, 0x10, 0x02, 0x12, 0x0b, 0x0a, 0x07, 0x49, 0x4e,
        0x54, 0x45, 0x47, 0x45, 0x52, 0x10, 0x03, 0x12, 0x0b, 0x0a, 0x07, 0x42, 0x4f, 0x4f, 0x4c, 0x45,
        0x41, 0x4e, 0x10, 0x04, 0x4a, 0x04, 0x08, 0x06, 0x10, 0x07, 0x4a, 0x04, 0x08, 0x07, 0x10, 0x08,
        0x22, 0xd8, 0x01, 0x0a, 0x06, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x12, 0x20, 0x0a, 0x0b, 0x64,
        0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x12, 0x0a,
        0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x74, 0x79, 0x70,
        0x65, 0x12, 0x16, 0x0a, 0x06, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x06, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x18, 0x0a, 0x07, 0x64, 0x65, 0x66,
        0x61, 0x75, 0x6c, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x64, 0x65, 0x66, 0x61,
        0x75, 0x6c, 0x74, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x18, 0x0d,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x4a, 0x04, 0x08,
        0x04, 0x10, 0x05, 0x4a, 0x04, 0x08, 0x05, 0x10, 0x06, 0x4a, 0x04, 0x08, 0x07, 0x10, 0x08, 0x4a,
        0x04, 0x08, 0x08, 0x10, 0x09, 0x4a, 0x04, 0x08, 0x09, 0x10, 0x0a, 0x4a, 0x04, 0x08, 0x0a, 0x10,
        0x0b, 0x4a, 0x04, 0x08, 0x0b, 0x10, 0x0c, 0x4a, 0x04, 0x08, 0x0c, 0x10, 0x0d, 0x4a, 0x04, 0x08,
        0x0e, 0x10, 0x0f, 0x4a, 0x04, 0x08, 0x0f, 0x10, 0x10, 0x4a, 0x04, 0x08, 0x10, 0x10, 0x11, 0x4a,
        0x04, 0x08, 0x11, 0x10, 0x12, 0x4a, 0x04, 0x08, 0x12, 0x10, 0x13, 0x22, 0x9a, 0x05, 0x0a, 0x08,
        0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63,
        0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64,
        0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x49, 0x0a, 0x06, 0x73, 0x63,
        0x68, 0x65, 0x6d, 0x61, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x31, 0x2e, 0x67, 0x72, 0x70,
        0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63,
        0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f,
        0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x52, 0x06, 0x73,
        0x63, 0x68, 0x65, 0x6d, 0x61, 0x12, 0x5a, 0x0a, 0x07, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x73,
        0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x40, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61,
        0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e,
        0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x73, 0x2e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x48, 0x65, 0x61, 0x64,
        0x65, 0x72, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x07, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72,
        0x73, 0x12, 0x5d, 0x0a, 0x08, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x73, 0x18, 0x04, 0x20,
        0x03, 0x28, 0x0b, 0x32, 0x41, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77,
        0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70,
        0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e,
        0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x45, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65,
        0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x08, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x73,
        0x12, 0x63, 0x0a, 0x0a, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x05,
        0x20, 0x03, 0x28, 0x0b, 0x32, 0x43, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65,
        0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f,
        0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73,
        0x2e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x45, 0x78, 0x74, 0x65, 0x6e, 0x73,
        0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0a, 0x65, 0x78, 0x74, 0x65, 0x6e,
        0x73, 0x69, 0x6f, 0x6e, 0x73, 0x1a, 0x6d, 0x0a, 0x0c, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x73,
        0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x47, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x31, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61,
        0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e,
        0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x73, 0x2e, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
        0x3a, 0x02, 0x38, 0x01, 0x1a, 0x3b, 0x0a, 0x0d, 0x45, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x73,
        0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38,
        0x01, 0x1a, 0x55, 0x0a, 0x0f, 0x45, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45,
        0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x2c, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x05, 0x76,
        0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0xd6, 0x03, 0x0a, 0x04, 0x49, 0x6e, 0x66,
        0x6f, 0x12, 0x14, 0x0a, 0x05, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x05, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72,
        0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65,
        0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x28, 0x0a, 0x10, 0x74, 0x65, 0x72,
        0x6d, 0x73, 0x5f, 0x6f, 0x66, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x18, 0x03, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x0e, 0x74, 0x65, 0x72, 0x6d, 0x73, 0x4f, 0x66, 0x53, 0x65, 0x72, 0x76,
        0x69, 0x63, 0x65, 0x12, 0x4c, 0x0a, 0x07, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x63, 0x74, 0x18, 0x04,
        0x20, 0x01, 0x28, 0x0b, 0x32, 0x32, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65,
        0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f,
        0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73,
        0x2e, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x63, 0x74, 0x52, 0x07, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x63,
        0x74, 0x12, 0x4c, 0x0a, 0x07, 0x6c, 0x69, 0x63, 0x65, 0x6e, 0x73, 0x65, 0x18, 0x05, 0x20, 0x01,
        0x28, 0x0b, 0x32, 0x32, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61,
        0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65,
        0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x4c,
        0x69, 0x63, 0x65, 0x6e, 0x73, 0x65, 0x52, 0x07, 0x6c, 0x69, 0x63, 0x65, 0x6e, 0x73, 0x65, 0x12,
        0x18, 0x0a, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x5f, 0x0a, 0x0a, 0x65, 0x78, 0x74,
        0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x07, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x3f, 0x2e,
        0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76,
        0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x45,
        0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0a,
        0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x1a, 0x55, 0x0a, 0x0f, 0x45, 0x78,
        0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a,
        0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12,
        0x2c, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16,
        0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
        0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38,
        0x01, 0x22, 0x45, 0x0a, 0x07, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x63, 0x74, 0x12, 0x12, 0x0a, 0x04,
        0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65,
        0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x75,
        0x72, 0x6c, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x03, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x22, 0x2f, 0x0a, 0x07, 0x4c, 0x69, 0x63, 0x65,
        0x6e, 0x73, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x6c, 0x18, 0x02,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x75, 0x72, 0x6c, 0x22, 0x4b, 0x0a, 0x15, 0x45, 0x78, 0x74,
        0x65, 0x72, 0x6e, 0x61, 0x6c, 0x44, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x61, 0x74, 0x69,
        0x6f, 0x6e, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
        0x74, 0x69, 0x6f, 0x6e, 0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x03, 0x75, 0x72, 0x6c, 0x22, 0xaa, 0x02, 0x0a, 0x06, 0x53, 0x63, 0x68, 0x65, 0x6d,
        0x61, 0x12, 0x56, 0x0a, 0x0b, 0x6a, 0x73, 0x6f, 0x6e, 0x5f, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x35, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61,
        0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e,
        0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x73, 0x2e, 0x4a, 0x53, 0x4f, 0x4e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x52, 0x0a, 0x6a,
        0x73, 0x6f, 0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x12, 0x24, 0x0a, 0x0d, 0x64, 0x69, 0x73,
        0x63, 0x72, 0x69, 0x6d, 0x69, 0x6e, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x0d, 0x64, 0x69, 0x73, 0x63, 0x72, 0x69, 0x6d, 0x69, 0x6e, 0x61, 0x74, 0x6f, 0x72, 0x12,
        0x1b, 0x0a, 0x09, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x6f, 0x6e, 0x6c, 0x79, 0x18, 0x03, 0x20, 0x01,
        0x28, 0x08, 0x52, 0x08, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0x12, 0x65, 0x0a, 0x0d,
        0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x5f, 0x64, 0x6f, 0x63, 0x73, 0x18, 0x05, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x40, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77,
        0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70,
        0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e,
        0x45, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x44, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74,
        0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0c, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x44,
        0x6f, 0x63, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x18, 0x06,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x4a, 0x04, 0x08,
        0x04, 0x10, 0x05, 0x22, 0xe8, 0x03, 0x0a, 0x0a, 0x45, 0x6e, 0x75, 0x6d, 0x53, 0x63, 0x68, 0x65,
        0x6d, 0x61, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
        0x74, 0x69, 0x6f, 0x6e, 0x12, 0x18, 0x0a, 0x07, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x12, 0x14,
        0x0a, 0x05, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x74,
        0x69, 0x74, 0x6c, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64,
        0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64,
        0x12, 0x1b, 0x0a, 0x09, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x6f, 0x6e, 0x6c, 0x79, 0x18, 0x05, 0x20,
        0x01, 0x28, 0x08, 0x52, 0x08, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0x12, 0x65, 0x0a,
        0x0d, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x5f, 0x64, 0x6f, 0x63, 0x73, 0x18, 0x06,
        0x20, 0x01, 0x28, 0x0b, 0x32, 0x40, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65,
        0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f,
        0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73,
        0x2e, 0x45, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x44, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e,
        0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0c, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c,
        0x44, 0x6f, 0x63, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x18,
        0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x12, 0x10,
        0x0a, 0x03, 0x72, 0x65, 0x66, 0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x72, 0x65, 0x66,
        0x12, 0x65, 0x0a, 0x0a, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x09,
        0x20, 0x03, 0x28, 0x0b, 0x32, 0x45, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65,
        0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f,
        0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73,
        0x2e, 0x45, 0x6e, 0x75, 0x6d, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x45, 0x78, 0x74, 0x65,
        0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0a, 0x65, 0x78, 0x74,
        0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x1a, 0x55, 0x0a, 0x0f, 0x45, 0x78, 0x74, 0x65, 0x6e,
        0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65,
        0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x2c, 0x0a, 0x05,
        0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x67, 0x6f,
        0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x56, 0x61,
        0x6c, 0x75, 0x65, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0xd7,
        0x0a, 0x0a, 0x0a, 0x4a, 0x53, 0x4f, 0x4e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x12, 0x10, 0x0a,
        0x03, 0x72, 0x65, 0x66, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x72, 0x65, 0x66, 0x12,
        0x14, 0x0a, 0x05, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05,
        0x74, 0x69, 0x74, 0x6c, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
        0x74, 0x69, 0x6f, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63,
        0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x18, 0x0a, 0x07, 0x64, 0x65, 0x66, 0x61, 0x75,
        0x6c, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c,
        0x74, 0x12, 0x1b, 0x0a, 0x09, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x6f, 0x6e, 0x6c, 0x79, 0x18, 0x08,
        0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0x12, 0x18,
        0x0a, 0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x12, 0x1f, 0x0a, 0x0b, 0x6d, 0x75, 0x6c, 0x74,
        0x69, 0x70, 0x6c, 0x65, 0x5f, 0x6f, 0x66, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x01, 0x52, 0x0a, 0x6d,
        0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x65, 0x4f, 0x66, 0x12, 0x18, 0x0a, 0x07, 0x6d, 0x61, 0x78,
        0x69, 0x6d, 0x75, 0x6d, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x01, 0x52, 0x07, 0x6d, 0x61, 0x78, 0x69,
        0x6d, 0x75, 0x6d, 0x12, 0x2b, 0x0a, 0x11, 0x65, 0x78, 0x63, 0x6c, 0x75, 0x73, 0x69, 0x76, 0x65,
        0x5f, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x08, 0x52, 0x10,
        0x65, 0x78, 0x63, 0x6c, 0x75, 0x73, 0x69, 0x76, 0x65, 0x4d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d,
        0x12, 0x18, 0x0a, 0x07, 0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x75, 0x6d, 0x18, 0x0d, 0x20, 0x01, 0x28,
        0x01, 0x52, 0x07, 0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x75, 0x6d, 0x12, 0x2b, 0x0a, 0x11, 0x65, 0x78,
        0x63, 0x6c, 0x75, 0x73, 0x69, 0x76, 0x65, 0x5f, 0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x75, 0x6d, 0x18,
        0x0e, 0x20, 0x01, 0x28, 0x08, 0x52, 0x10, 0x65, 0x78, 0x63, 0x6c, 0x75, 0x73, 0x69, 0x76, 0x65,
        0x4d, 0x69, 0x6e, 0x69, 0x6d, 0x75, 0x6d, 0x12, 0x1d, 0x0a, 0x0a, 0x6d, 0x61, 0x78, 0x5f, 0x6c,
        0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x04, 0x52, 0x09, 0x6d, 0x61, 0x78,
        0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x12, 0x1d, 0x0a, 0x0a, 0x6d, 0x69, 0x6e, 0x5f, 0x6c, 0x65,
        0x6e, 0x67, 0x74, 0x68, 0x18, 0x10, 0x20, 0x01, 0x28, 0x04, 0x52, 0x09, 0x6d, 0x69, 0x6e, 0x4c,
        0x65, 0x6e, 0x67, 0x74, 0x68, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e,
        0x18, 0x11, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x12,
        0x1b, 0x0a, 0x09, 0x6d, 0x61, 0x78, 0x5f, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x18, 0x14, 0x20, 0x01,
        0x28, 0x04, 0x52, 0x08, 0x6d, 0x61, 0x78, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x12, 0x1b, 0x0a, 0x09,
        0x6d, 0x69, 0x6e, 0x5f, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x18, 0x15, 0x20, 0x01, 0x28, 0x04, 0x52,
        0x08, 0x6d, 0x69, 0x6e, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x12, 0x21, 0x0a, 0x0c, 0x75, 0x6e, 0x69,
        0x71, 0x75, 0x65, 0x5f, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x18, 0x16, 0x20, 0x01, 0x28, 0x08, 0x52,
        0x0b, 0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x12, 0x25, 0x0a, 0x0e,
        0x6d, 0x61, 0x78, 0x5f, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x18, 0x18,
        0x20, 0x01, 0x28, 0x04, 0x52, 0x0d, 0x6d, 0x61, 0x78, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74,
        0x69, 0x65, 0x73, 0x12, 0x25, 0x0a, 0x0e, 0x6d, 0x69, 0x6e, 0x5f, 0x70, 0x72, 0x6f, 0x70, 0x65,
        0x72, 0x74, 0x69, 0x65, 0x73, 0x18, 0x19, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0d, 0x6d, 0x69, 0x6e,
        0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x12, 0x1a, 0x0a, 0x08, 0x72, 0x65,
        0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x18, 0x1a, 0x20, 0x03, 0x28, 0x09, 0x52, 0x08, 0x72, 0x65,
        0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x61, 0x72, 0x72, 0x61, 0x79, 0x18,
        0x22, 0x20, 0x03, 0x28, 0x09, 0x52, 0x05, 0x61, 0x72, 0x72, 0x61, 0x79, 0x12, 0x5f, 0x0a, 0x04,
        0x74, 0x79, 0x70, 0x65, 0x18, 0x23, 0x20, 0x03, 0x28, 0x0e, 0x32, 0x4b, 0x2e, 0x67, 0x72, 0x70,
        0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63,
        0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f,
        0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x4a, 0x53, 0x4f, 0x4e, 0x53, 0x63, 0x68, 0x65, 0x6d,
        0x61, 0x2e, 0x4a, 0x53, 0x4f, 0x4e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x53, 0x69, 0x6d, 0x70,
        0x6c, 0x65, 0x54, 0x79, 0x70, 0x65, 0x73, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x12, 0x16, 0x0a,
        0x06, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x18, 0x24, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x66,
        0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x65, 0x6e, 0x75, 0x6d, 0x18, 0x2e, 0x20,
        0x03, 0x28, 0x09, 0x52, 0x04, 0x65, 0x6e, 0x75, 0x6d, 0x12, 0x7a, 0x0a, 0x13, 0x66, 0x69, 0x65,
        0x6c, 0x64, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
        0x18, 0xe9, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x48, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67,
        0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65,
        0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x2e, 0x4a, 0x53, 0x4f, 0x4e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x46,
        0x69, 0x65, 0x6c, 0x64, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f,
        0x6e, 0x52, 0x12, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72,
        0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x65, 0x0a, 0x0a, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69,
        0x6f, 0x6e, 0x73, 0x18, 0x30, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x45, 0x2e, 0x67, 0x72, 0x70, 0x63,
        0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f,
        0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70,
        0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x4a, 0x53, 0x4f, 0x4e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61,
        0x2e, 0x45, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79,
        0x52, 0x0a, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x1a, 0x3c, 0x0a, 0x12,
        0x46, 0x69, 0x65, 0x6c, 0x64, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x61, 0x74, 0x69,
        0x6f, 0x6e, 0x12, 0x26, 0x0a, 0x0f, 0x70, 0x61, 0x74, 0x68, 0x5f, 0x70, 0x61, 0x72, 0x61, 0x6d,
        0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x2f, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x70, 0x61, 0x74,
        0x68, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x4e, 0x61, 0x6d, 0x65, 0x1a, 0x55, 0x0a, 0x0f, 0x45, 0x78,
        0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a,
        0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12,
        0x2c, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16,
        0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
        0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38,
        0x01, 0x22, 0x77, 0x0a, 0x15, 0x4a, 0x53, 0x4f, 0x4e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x53,
        0x69, 0x6d, 0x70, 0x6c, 0x65, 0x54, 0x79, 0x70, 0x65, 0x73, 0x12, 0x0b, 0x0a, 0x07, 0x55, 0x4e,
        0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10, 0x00, 0x12, 0x09, 0x0a, 0x05, 0x41, 0x52, 0x52, 0x41, 0x59,
        0x10, 0x01, 0x12, 0x0b, 0x0a, 0x07, 0x42, 0x4f, 0x4f, 0x4c, 0x45, 0x41, 0x4e, 0x10, 0x02, 0x12,
        0x0b, 0x0a, 0x07, 0x49, 0x4e, 0x54, 0x45, 0x47, 0x45, 0x52, 0x10, 0x03, 0x12, 0x08, 0x0a, 0x04,
        0x4e, 0x55, 0x4c, 0x4c, 0x10, 0x04, 0x12, 0x0a, 0x0a, 0x06, 0x4e, 0x55, 0x4d, 0x42, 0x45, 0x52,
        0x10, 0x05, 0x12, 0x0a, 0x0a, 0x06, 0x4f, 0x42, 0x4a, 0x45, 0x43, 0x54, 0x10, 0x06, 0x12, 0x0a,
        0x0a, 0x06, 0x53, 0x54, 0x52, 0x49, 0x4e, 0x47, 0x10, 0x07, 0x4a, 0x04, 0x08, 0x01, 0x10, 0x02,
        0x4a, 0x04, 0x08, 0x02, 0x10, 0x03, 0x4a, 0x04, 0x08, 0x04, 0x10, 0x05, 0x4a, 0x04, 0x08, 0x12,
        0x10, 0x13, 0x4a, 0x04, 0x08, 0x13, 0x10, 0x14, 0x4a, 0x04, 0x08, 0x17, 0x10, 0x18, 0x4a, 0x04,
        0x08, 0x1b, 0x10, 0x1c, 0x4a, 0x04, 0x08, 0x1c, 0x10, 0x1d, 0x4a, 0x04, 0x08, 0x1d, 0x10, 0x1e,
        0x4a, 0x04, 0x08, 0x1e, 0x10, 0x22, 0x4a, 0x04, 0x08, 0x25, 0x10, 0x2a, 0x4a, 0x04, 0x08, 0x2a,
        0x10, 0x2b, 0x4a, 0x04, 0x08, 0x2b, 0x10, 0x2e, 0x22, 0xd9, 0x02, 0x0a, 0x03, 0x54, 0x61, 0x67,
        0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04,
        0x6e, 0x61, 0x6d, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
        0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72,
        0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x65, 0x0a, 0x0d, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e,
        0x61, 0x6c, 0x5f, 0x64, 0x6f, 0x63, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x40, 0x2e,
        0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76,
        0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x45, 0x78, 0x74, 0x65, 0x72, 0x6e,
        0x61, 0x6c, 0x44, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52,
        0x0c, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x44, 0x6f, 0x63, 0x73, 0x12, 0x5e, 0x0a,
        0x0a, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28,
        0x0b, 0x32, 0x3e, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e,
        0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x54, 0x61,
        0x67, 0x2e, 0x45, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72,
        0x79, 0x52, 0x0a, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x1a, 0x55, 0x0a,
        0x0f, 0x45, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79,
        0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b,
        0x65, 0x79, 0x12, 0x2c, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x62, 0x75, 0x66, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
        0x3a, 0x02, 0x38, 0x01, 0x22, 0xf7, 0x01, 0x0a, 0x13, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74,
        0x79, 0x44, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x68, 0x0a, 0x08,
        0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x4c,
        0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69,
        0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72,
        0x69, 0x74, 0x79, 0x44, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53,
        0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x08, 0x73, 0x65,
        0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x1a, 0x76, 0x0a, 0x0d, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69,
        0x74, 0x79, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x4f, 0x0a, 0x05, 0x76, 0x61, 0x6c,
        0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x39, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e,
        0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67,
        0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74,
        0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x53, 0x63, 0x68,
        0x65, 0x6d, 0x65, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0xff,
        0x06, 0x0a, 0x0e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x53, 0x63, 0x68, 0x65, 0x6d,
        0x65, 0x12, 0x52, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32,
        0x3e, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70,
        0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x65, 0x63, 0x75,
        0x72, 0x69, 0x74, 0x79, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x2e, 0x54, 0x79, 0x70, 0x65, 0x52,
        0x04, 0x74, 0x79, 0x70, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
        0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63,
        0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18,
        0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x4c, 0x0a, 0x02, 0x69,
        0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x3c, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67,
        0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65,
        0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x53, 0x63, 0x68, 0x65,
        0x6d, 0x65, 0x2e, 0x49, 0x6e, 0x52, 0x02, 0x69, 0x6e, 0x12, 0x52, 0x0a, 0x04, 0x66, 0x6c, 0x6f,
        0x77, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x3e, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67,
        0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65,
        0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x53, 0x63, 0x68, 0x65,
        0x6d, 0x65, 0x2e, 0x46, 0x6c, 0x6f, 0x77, 0x52, 0x04, 0x66, 0x6c, 0x6f, 0x77, 0x12, 0x2b, 0x0a,
        0x11, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x75,
        0x72, 0x6c, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x10, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72,
        0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x55, 0x72, 0x6c, 0x12, 0x1b, 0x0a, 0x09, 0x74, 0x6f,
        0x6b, 0x65, 0x6e, 0x5f, 0x75, 0x72, 0x6c, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x74,
        0x6f, 0x6b, 0x65, 0x6e, 0x55, 0x72, 0x6c, 0x12, 0x49, 0x0a, 0x06, 0x73, 0x63, 0x6f, 0x70, 0x65,
        0x73, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x31, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67,
        0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65,
        0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x63, 0x6f, 0x70, 0x65, 0x73, 0x52, 0x06, 0x73, 0x63, 0x6f, 0x70,
        0x65, 0x73, 0x12, 0x69, 0x0a, 0x0a, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73,
        0x18, 0x09, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x49, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61,
        0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e,
        0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x73, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x53, 0x63, 0x68, 0x65, 0x6d,
        0x65, 0x2e, 0x45, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72,
        0x79, 0x52, 0x0a, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x1a, 0x55, 0x0a,
        0x0f, 0x45, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79,
        0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b,
        0x65, 0x79, 0x12, 0x2c, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x62, 0x75, 0x66, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
        0x3a, 0x02, 0x38, 0x01, 0x22, 0x4b, 0x0a, 0x04, 0x54, 0x79, 0x70, 0x65, 0x12, 0x10, 0x0a, 0x0c,
        0x54, 0x59, 0x50, 0x45, 0x5f, 0x49, 0x4e, 0x56, 0x41, 0x4c, 0x49, 0x44, 0x10, 0x00, 0x12, 0x0e,
        0x0a, 0x0a, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x42, 0x41, 0x53, 0x49, 0x43, 0x10, 0x01, 0x12, 0x10,
        0x0a, 0x0c, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x41, 0x50, 0x49, 0x5f, 0x4b, 0x45, 0x59, 0x10, 0x02,
        0x12, 0x0f, 0x0a, 0x0b, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4f, 0x41, 0x55, 0x54, 0x48, 0x32, 0x10,
        0x03, 0x22, 0x31, 0x0a, 0x02, 0x49, 0x6e, 0x12, 0x0e, 0x0a, 0x0a, 0x49, 0x4e, 0x5f, 0x49, 0x4e,
        0x56, 0x41, 0x4c, 0x49, 0x44, 0x10, 0x00, 0x12, 0x0c, 0x0a, 0x08, 0x49, 0x4e, 0x5f, 0x51, 0x55,
        0x45, 0x52, 0x59, 0x10, 0x01, 0x12, 0x0d, 0x0a, 0x09, 0x49, 0x4e, 0x5f, 0x48, 0x45, 0x41, 0x44,
        0x45, 0x52, 0x10, 0x02, 0x22, 0x6a, 0x0a, 0x04, 0x46, 0x6c, 0x6f, 0x77, 0x12, 0x10, 0x0a, 0x0c,
        0x46, 0x4c, 0x4f, 0x57, 0x5f, 0x49, 0x4e, 0x56, 0x41, 0x4c, 0x49, 0x44, 0x10, 0x00, 0x12, 0x11,
        0x0a, 0x0d, 0x46, 0x4c, 0x4f, 0x57, 0x5f, 0x49, 0x4d, 0x50, 0x4c, 0x49, 0x43, 0x49, 0x54, 0x10,
        0x01, 0x12, 0x11, 0x0a, 0x0d, 0x46, 0x4c, 0x4f, 0x57, 0x5f, 0x50, 0x41, 0x53, 0x53, 0x57, 0x4f,
        0x52, 0x44, 0x10, 0x02, 0x12, 0x14, 0x0a, 0x10, 0x46, 0x4c, 0x4f, 0x57, 0x5f, 0x41, 0x50, 0x50,
        0x4c, 0x49, 0x43, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x10, 0x03, 0x12, 0x14, 0x0a, 0x10, 0x46, 0x4c,
        0x4f, 0x57, 0x5f, 0x41, 0x43, 0x43, 0x45, 0x53, 0x53, 0x5f, 0x43, 0x4f, 0x44, 0x45, 0x10, 0x04,
        0x22, 0xf6, 0x02, 0x0a, 0x13, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x52, 0x65, 0x71,
        0x75, 0x69, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x12, 0x8a, 0x01, 0x0a, 0x14, 0x73, 0x65, 0x63,
        0x75, 0x72, 0x69, 0x74, 0x79, 0x5f, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x6d, 0x65, 0x6e,
        0x74, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x57, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67,
        0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65,
        0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x52, 0x65, 0x71, 0x75,
        0x69, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79,
        0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x45, 0x6e, 0x74, 0x72, 0x79,
        0x52, 0x13, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72,
        0x65, 0x6d, 0x65, 0x6e, 0x74, 0x1a, 0x30, 0x0a, 0x18, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74,
        0x79, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x56, 0x61, 0x6c, 0x75,
        0x65, 0x12, 0x14, 0x0a, 0x05, 0x73, 0x63, 0x6f, 0x70, 0x65, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09,
        0x52, 0x05, 0x73, 0x63, 0x6f, 0x70, 0x65, 0x1a, 0x9f, 0x01, 0x0a, 0x18, 0x53, 0x65, 0x63, 0x75,
        0x72, 0x69, 0x74, 0x79, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x45,
        0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x6d, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x57, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74,
        0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f,
        0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e,
        0x73, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72,
        0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x52, 0x65,
        0x71, 0x75, 0x69, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x05,
        0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0x96, 0x01, 0x0a, 0x06, 0x53, 0x63,
        0x6f, 0x70, 0x65, 0x73, 0x12, 0x52, 0x0a, 0x05, 0x73, 0x63, 0x6f, 0x70, 0x65, 0x18, 0x01, 0x20,
        0x03, 0x28, 0x0b, 0x32, 0x3c, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77,
        0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70,
        0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e,
        0x53, 0x63, 0x6f, 0x70, 0x65, 0x73, 0x2e, 0x53, 0x63, 0x6f, 0x70, 0x65, 0x45, 0x6e, 0x74, 0x72,
        0x79, 0x52, 0x05, 0x73, 0x63, 0x6f, 0x70, 0x65, 0x1a, 0x38, 0x0a, 0x0a, 0x53, 0x63, 0x6f, 0x70,
        0x65, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75,
        0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02,
        0x38, 0x01, 0x2a, 0x3b, 0x0a, 0x06, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x12, 0x0b, 0x0a, 0x07,
        0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10, 0x00, 0x12, 0x08, 0x0a, 0x04, 0x48, 0x54, 0x54,
        0x50, 0x10, 0x01, 0x12, 0x09, 0x0a, 0x05, 0x48, 0x54, 0x54, 0x50, 0x53, 0x10, 0x02, 0x12, 0x06,
        0x0a, 0x02, 0x57, 0x53, 0x10, 0x03, 0x12, 0x07, 0x0a, 0x03, 0x57, 0x53, 0x53, 0x10, 0x04, 0x42,
        0x48, 0x5a, 0x46, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x67, 0x72,
        0x70, 0x63, 0x2d, 0x65, 0x63, 0x6f, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x2f, 0x67, 0x72, 0x70,
        0x63, 0x2d, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2f, 0x76, 0x32, 0x2f, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x63, 0x2d, 0x67, 0x65, 0x6e, 0x2d, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76,
        0x32, 0x2f, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x33,
}

var file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes = make([]protoimpl.EnumInfo, 6)
var file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes = make([]protoimpl.MessageInfo, 35)
var file_protoc_gen_openapiv2_options_openapiv2_proto_goTypes = []any{
        (Scheme)(0),                           // 0: grpc.gateway.protoc_gen_openapiv2.options.Scheme
        (HeaderParameter_Type)(0),             // 1: grpc.gateway.protoc_gen_openapiv2.options.HeaderParameter.Type
        (JSONSchema_JSONSchemaSimpleTypes)(0), // 2: grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.JSONSchemaSimpleTypes
        (SecurityScheme_Type)(0),              // 3: grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.Type
        (SecurityScheme_In)(0),                // 4: grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.In
        (SecurityScheme_Flow)(0),              // 5: grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.Flow
        (*Swagger)(nil),                       // 6: grpc.gateway.protoc_gen_openapiv2.options.Swagger
        (*Operation)(nil),                     // 7: grpc.gateway.protoc_gen_openapiv2.options.Operation
        (*Parameters)(nil),                    // 8: grpc.gateway.protoc_gen_openapiv2.options.Parameters
        (*HeaderParameter)(nil),               // 9: grpc.gateway.protoc_gen_openapiv2.options.HeaderParameter
        (*Header)(nil),                        // 10: grpc.gateway.protoc_gen_openapiv2.options.Header
        (*Response)(nil),                      // 11: grpc.gateway.protoc_gen_openapiv2.options.Response
        (*Info)(nil),                          // 12: grpc.gateway.protoc_gen_openapiv2.options.Info
        (*Contact)(nil),                       // 13: grpc.gateway.protoc_gen_openapiv2.options.Contact
        (*License)(nil),                       // 14: grpc.gateway.protoc_gen_openapiv2.options.License
        (*ExternalDocumentation)(nil),         // 15: grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation
        (*Schema)(nil),                        // 16: grpc.gateway.protoc_gen_openapiv2.options.Schema
        (*EnumSchema)(nil),                    // 17: grpc.gateway.protoc_gen_openapiv2.options.EnumSchema
        (*JSONSchema)(nil),                    // 18: grpc.gateway.protoc_gen_openapiv2.options.JSONSchema
        (*Tag)(nil),                           // 19: grpc.gateway.protoc_gen_openapiv2.options.Tag
        (*SecurityDefinitions)(nil),           // 20: grpc.gateway.protoc_gen_openapiv2.options.SecurityDefinitions
        (*SecurityScheme)(nil),                // 21: grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme
        (*SecurityRequirement)(nil),           // 22: grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement
        (*Scopes)(nil),                        // 23: grpc.gateway.protoc_gen_openapiv2.options.Scopes
        nil,                                   // 24: grpc.gateway.protoc_gen_openapiv2.options.Swagger.ResponsesEntry
        nil,                                   // 25: grpc.gateway.protoc_gen_openapiv2.options.Swagger.ExtensionsEntry
        nil,                                   // 26: grpc.gateway.protoc_gen_openapiv2.options.Operation.ResponsesEntry
        nil,                                   // 27: grpc.gateway.protoc_gen_openapiv2.options.Operation.ExtensionsEntry
        nil,                                   // 28: grpc.gateway.protoc_gen_openapiv2.options.Response.HeadersEntry
        nil,                                   // 29: grpc.gateway.protoc_gen_openapiv2.options.Response.ExamplesEntry
        nil,                                   // 30: grpc.gateway.protoc_gen_openapiv2.options.Response.ExtensionsEntry
        nil,                                   // 31: grpc.gateway.protoc_gen_openapiv2.options.Info.ExtensionsEntry
        nil,                                   // 32: grpc.gateway.protoc_gen_openapiv2.options.EnumSchema.ExtensionsEntry
        (*JSONSchema_FieldConfiguration)(nil), // 33: grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.FieldConfiguration
        nil,                                   // 34: grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.ExtensionsEntry
        nil,                                   // 35: grpc.gateway.protoc_gen_openapiv2.options.Tag.ExtensionsEntry
        nil,                                   // 36: grpc.gateway.protoc_gen_openapiv2.options.SecurityDefinitions.SecurityEntry
        nil,                                   // 37: grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.ExtensionsEntry
        (*SecurityRequirement_SecurityRequirementValue)(nil), // 38: grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementValue
        nil,                    // 39: grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementEntry
        nil,                    // 40: grpc.gateway.protoc_gen_openapiv2.options.Scopes.ScopeEntry
        (*structpb.Value)(nil), // 41: google.protobuf.Value
}
var file_protoc_gen_openapiv2_options_openapiv2_proto_depIdxs = []int32{
        12, // 0: grpc.gateway.protoc_gen_openapiv2.options.Swagger.info:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Info
        0,  // 1: grpc.gateway.protoc_gen_openapiv2.options.Swagger.schemes:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Scheme
        24, // 2: grpc.gateway.protoc_gen_openapiv2.options.Swagger.responses:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Swagger.ResponsesEntry
        20, // 3: grpc.gateway.protoc_gen_openapiv2.options.Swagger.security_definitions:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.SecurityDefinitions
        22, // 4: grpc.gateway.protoc_gen_openapiv2.options.Swagger.security:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement
        19, // 5: grpc.gateway.protoc_gen_openapiv2.options.Swagger.tags:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Tag
        15, // 6: grpc.gateway.protoc_gen_openapiv2.options.Swagger.external_docs:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation
        25, // 7: grpc.gateway.protoc_gen_openapiv2.options.Swagger.extensions:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Swagger.ExtensionsEntry
        15, // 8: grpc.gateway.protoc_gen_openapiv2.options.Operation.external_docs:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation
        26, // 9: grpc.gateway.protoc_gen_openapiv2.options.Operation.responses:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Operation.ResponsesEntry
        0,  // 10: grpc.gateway.protoc_gen_openapiv2.options.Operation.schemes:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Scheme
        22, // 11: grpc.gateway.protoc_gen_openapiv2.options.Operation.security:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement
        27, // 12: grpc.gateway.protoc_gen_openapiv2.options.Operation.extensions:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Operation.ExtensionsEntry
        8,  // 13: grpc.gateway.protoc_gen_openapiv2.options.Operation.parameters:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Parameters
        9,  // 14: grpc.gateway.protoc_gen_openapiv2.options.Parameters.headers:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.HeaderParameter
        1,  // 15: grpc.gateway.protoc_gen_openapiv2.options.HeaderParameter.type:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.HeaderParameter.Type
        16, // 16: grpc.gateway.protoc_gen_openapiv2.options.Response.schema:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Schema
        28, // 17: grpc.gateway.protoc_gen_openapiv2.options.Response.headers:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Response.HeadersEntry
        29, // 18: grpc.gateway.protoc_gen_openapiv2.options.Response.examples:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Response.ExamplesEntry
        30, // 19: grpc.gateway.protoc_gen_openapiv2.options.Response.extensions:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Response.ExtensionsEntry
        13, // 20: grpc.gateway.protoc_gen_openapiv2.options.Info.contact:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Contact
        14, // 21: grpc.gateway.protoc_gen_openapiv2.options.Info.license:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.License
        31, // 22: grpc.gateway.protoc_gen_openapiv2.options.Info.extensions:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Info.ExtensionsEntry
        18, // 23: grpc.gateway.protoc_gen_openapiv2.options.Schema.json_schema:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.JSONSchema
        15, // 24: grpc.gateway.protoc_gen_openapiv2.options.Schema.external_docs:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation
        15, // 25: grpc.gateway.protoc_gen_openapiv2.options.EnumSchema.external_docs:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation
        32, // 26: grpc.gateway.protoc_gen_openapiv2.options.EnumSchema.extensions:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.EnumSchema.ExtensionsEntry
        2,  // 27: grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.type:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.JSONSchemaSimpleTypes
        33, // 28: grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.field_configuration:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.FieldConfiguration
        34, // 29: grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.extensions:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.ExtensionsEntry
        15, // 30: grpc.gateway.protoc_gen_openapiv2.options.Tag.external_docs:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation
        35, // 31: grpc.gateway.protoc_gen_openapiv2.options.Tag.extensions:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Tag.ExtensionsEntry
        36, // 32: grpc.gateway.protoc_gen_openapiv2.options.SecurityDefinitions.security:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.SecurityDefinitions.SecurityEntry
        3,  // 33: grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.type:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.Type
        4,  // 34: grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.in:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.In
        5,  // 35: grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.flow:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.Flow
        23, // 36: grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.scopes:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Scopes
        37, // 37: grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.extensions:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.ExtensionsEntry
        39, // 38: grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.security_requirement:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementEntry
        40, // 39: grpc.gateway.protoc_gen_openapiv2.options.Scopes.scope:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Scopes.ScopeEntry
        11, // 40: grpc.gateway.protoc_gen_openapiv2.options.Swagger.ResponsesEntry.value:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Response
        41, // 41: grpc.gateway.protoc_gen_openapiv2.options.Swagger.ExtensionsEntry.value:type_name -&gt; google.protobuf.Value
        11, // 42: grpc.gateway.protoc_gen_openapiv2.options.Operation.ResponsesEntry.value:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Response
        41, // 43: grpc.gateway.protoc_gen_openapiv2.options.Operation.ExtensionsEntry.value:type_name -&gt; google.protobuf.Value
        10, // 44: grpc.gateway.protoc_gen_openapiv2.options.Response.HeadersEntry.value:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Header
        41, // 45: grpc.gateway.protoc_gen_openapiv2.options.Response.ExtensionsEntry.value:type_name -&gt; google.protobuf.Value
        41, // 46: grpc.gateway.protoc_gen_openapiv2.options.Info.ExtensionsEntry.value:type_name -&gt; google.protobuf.Value
        41, // 47: grpc.gateway.protoc_gen_openapiv2.options.EnumSchema.ExtensionsEntry.value:type_name -&gt; google.protobuf.Value
        41, // 48: grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.ExtensionsEntry.value:type_name -&gt; google.protobuf.Value
        41, // 49: grpc.gateway.protoc_gen_openapiv2.options.Tag.ExtensionsEntry.value:type_name -&gt; google.protobuf.Value
        21, // 50: grpc.gateway.protoc_gen_openapiv2.options.SecurityDefinitions.SecurityEntry.value:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme
        41, // 51: grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.ExtensionsEntry.value:type_name -&gt; google.protobuf.Value
        38, // 52: grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementEntry.value:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementValue
        53, // [53:53] is the sub-list for method output_type
        53, // [53:53] is the sub-list for method input_type
        53, // [53:53] is the sub-list for extension type_name
        53, // [53:53] is the sub-list for extension extendee
        0,  // [0:53] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_protoc_gen_openapiv2_options_openapiv2_proto_init() }</span>
func file_protoc_gen_openapiv2_options_openapiv2_proto_init() <span class="cov0" title="0">{
        if File_protoc_gen_openapiv2_options_openapiv2_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_protoc_gen_openapiv2_options_openapiv2_proto_rawDesc,
                        NumEnums:      6,
                        NumMessages:   35,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_protoc_gen_openapiv2_options_openapiv2_proto_goTypes,
                DependencyIndexes: file_protoc_gen_openapiv2_options_openapiv2_proto_depIdxs,
                EnumInfos:         file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes,
                MessageInfos:      file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes,
        }.Build()
        File_protoc_gen_openapiv2_options_openapiv2_proto = out.File
        file_protoc_gen_openapiv2_options_openapiv2_proto_rawDesc = nil
        file_protoc_gen_openapiv2_options_openapiv2_proto_goTypes = nil
        file_protoc_gen_openapiv2_options_openapiv2_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.30.0
//         protoc        v3.21.12
// source: validate/validate.proto

package validate

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        descriptorpb "google.golang.org/protobuf/types/descriptorpb"
        durationpb "google.golang.org/protobuf/types/known/durationpb"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// WellKnownRegex contain some well-known patterns.
type KnownRegex int32

const (
        KnownRegex_UNKNOWN KnownRegex = 0
        // HTTP header name as defined by RFC 7230.
        KnownRegex_HTTP_HEADER_NAME KnownRegex = 1
        // HTTP header value as defined by RFC 7230.
        KnownRegex_HTTP_HEADER_VALUE KnownRegex = 2
)

// Enum value maps for KnownRegex.
var (
        KnownRegex_name = map[int32]string{
                0: "UNKNOWN",
                1: "HTTP_HEADER_NAME",
                2: "HTTP_HEADER_VALUE",
        }
        KnownRegex_value = map[string]int32{
                "UNKNOWN":           0,
                "HTTP_HEADER_NAME":  1,
                "HTTP_HEADER_VALUE": 2,
        }
)

func (x KnownRegex) Enum() *KnownRegex <span class="cov0" title="0">{
        p := new(KnownRegex)
        *p = x
        return p
}</span>

func (x KnownRegex) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (KnownRegex) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_validate_validate_proto_enumTypes[0].Descriptor()
}</span>

func (KnownRegex) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_validate_validate_proto_enumTypes[0]
}</span>

func (x KnownRegex) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Do not use.
func (x *KnownRegex) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*x = KnownRegex(num)
        return nil</span>
}

// Deprecated: Use KnownRegex.Descriptor instead.
func (KnownRegex) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{0}
}</span>

// FieldRules encapsulates the rules for each type of field. Depending on the
// field, the correct set should be used to ensure proper validations.
type FieldRules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Message *MessageRules `protobuf:"bytes,17,opt,name=message" json:"message,omitempty"`
        // Types that are assignable to Type:
        //
        //        *FieldRules_Float
        //        *FieldRules_Double
        //        *FieldRules_Int32
        //        *FieldRules_Int64
        //        *FieldRules_Uint32
        //        *FieldRules_Uint64
        //        *FieldRules_Sint32
        //        *FieldRules_Sint64
        //        *FieldRules_Fixed32
        //        *FieldRules_Fixed64
        //        *FieldRules_Sfixed32
        //        *FieldRules_Sfixed64
        //        *FieldRules_Bool
        //        *FieldRules_String_
        //        *FieldRules_Bytes
        //        *FieldRules_Enum
        //        *FieldRules_Repeated
        //        *FieldRules_Map
        //        *FieldRules_Any
        //        *FieldRules_Duration
        //        *FieldRules_Timestamp
        Type isFieldRules_Type `protobuf_oneof:"type"`
}

func (x *FieldRules) Reset() <span class="cov0" title="0">{
        *x = FieldRules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *FieldRules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FieldRules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FieldRules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use FieldRules.ProtoReflect.Descriptor instead.
func (*FieldRules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{0}
}</span>

func (x *FieldRules) GetMessage() *MessageRules <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *FieldRules) GetType() isFieldRules_Type <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Type
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetFloat() *FloatRules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Float); ok </span><span class="cov0" title="0">{
                return x.Float
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetDouble() *DoubleRules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Double); ok </span><span class="cov0" title="0">{
                return x.Double
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetInt32() *Int32Rules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Int32); ok </span><span class="cov0" title="0">{
                return x.Int32
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetInt64() *Int64Rules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Int64); ok </span><span class="cov0" title="0">{
                return x.Int64
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetUint32() *UInt32Rules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Uint32); ok </span><span class="cov0" title="0">{
                return x.Uint32
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetUint64() *UInt64Rules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Uint64); ok </span><span class="cov0" title="0">{
                return x.Uint64
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetSint32() *SInt32Rules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Sint32); ok </span><span class="cov0" title="0">{
                return x.Sint32
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetSint64() *SInt64Rules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Sint64); ok </span><span class="cov0" title="0">{
                return x.Sint64
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetFixed32() *Fixed32Rules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Fixed32); ok </span><span class="cov0" title="0">{
                return x.Fixed32
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetFixed64() *Fixed64Rules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Fixed64); ok </span><span class="cov0" title="0">{
                return x.Fixed64
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetSfixed32() *SFixed32Rules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Sfixed32); ok </span><span class="cov0" title="0">{
                return x.Sfixed32
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetSfixed64() *SFixed64Rules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Sfixed64); ok </span><span class="cov0" title="0">{
                return x.Sfixed64
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetBool() *BoolRules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Bool); ok </span><span class="cov0" title="0">{
                return x.Bool
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetString_() *StringRules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_String_); ok </span><span class="cov0" title="0">{
                return x.String_
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetBytes() *BytesRules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Bytes); ok </span><span class="cov0" title="0">{
                return x.Bytes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetEnum() *EnumRules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Enum); ok </span><span class="cov0" title="0">{
                return x.Enum
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetRepeated() *RepeatedRules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Repeated); ok </span><span class="cov0" title="0">{
                return x.Repeated
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetMap() *MapRules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Map); ok </span><span class="cov0" title="0">{
                return x.Map
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetAny() *AnyRules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Any); ok </span><span class="cov0" title="0">{
                return x.Any
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetDuration() *DurationRules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Duration); ok </span><span class="cov0" title="0">{
                return x.Duration
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FieldRules) GetTimestamp() *TimestampRules <span class="cov0" title="0">{
        if x, ok := x.GetType().(*FieldRules_Timestamp); ok </span><span class="cov0" title="0">{
                return x.Timestamp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type isFieldRules_Type interface {
        isFieldRules_Type()
}

type FieldRules_Float struct {
        // Scalar Field Types
        Float *FloatRules `protobuf:"bytes,1,opt,name=float,oneof"`
}

type FieldRules_Double struct {
        Double *DoubleRules `protobuf:"bytes,2,opt,name=double,oneof"`
}

type FieldRules_Int32 struct {
        Int32 *Int32Rules `protobuf:"bytes,3,opt,name=int32,oneof"`
}

type FieldRules_Int64 struct {
        Int64 *Int64Rules `protobuf:"bytes,4,opt,name=int64,oneof"`
}

type FieldRules_Uint32 struct {
        Uint32 *UInt32Rules `protobuf:"bytes,5,opt,name=uint32,oneof"`
}

type FieldRules_Uint64 struct {
        Uint64 *UInt64Rules `protobuf:"bytes,6,opt,name=uint64,oneof"`
}

type FieldRules_Sint32 struct {
        Sint32 *SInt32Rules `protobuf:"bytes,7,opt,name=sint32,oneof"`
}

type FieldRules_Sint64 struct {
        Sint64 *SInt64Rules `protobuf:"bytes,8,opt,name=sint64,oneof"`
}

type FieldRules_Fixed32 struct {
        Fixed32 *Fixed32Rules `protobuf:"bytes,9,opt,name=fixed32,oneof"`
}

type FieldRules_Fixed64 struct {
        Fixed64 *Fixed64Rules `protobuf:"bytes,10,opt,name=fixed64,oneof"`
}

type FieldRules_Sfixed32 struct {
        Sfixed32 *SFixed32Rules `protobuf:"bytes,11,opt,name=sfixed32,oneof"`
}

type FieldRules_Sfixed64 struct {
        Sfixed64 *SFixed64Rules `protobuf:"bytes,12,opt,name=sfixed64,oneof"`
}

type FieldRules_Bool struct {
        Bool *BoolRules `protobuf:"bytes,13,opt,name=bool,oneof"`
}

type FieldRules_String_ struct {
        String_ *StringRules `protobuf:"bytes,14,opt,name=string,oneof"`
}

type FieldRules_Bytes struct {
        Bytes *BytesRules `protobuf:"bytes,15,opt,name=bytes,oneof"`
}

type FieldRules_Enum struct {
        // Complex Field Types
        Enum *EnumRules `protobuf:"bytes,16,opt,name=enum,oneof"`
}

type FieldRules_Repeated struct {
        Repeated *RepeatedRules `protobuf:"bytes,18,opt,name=repeated,oneof"`
}

type FieldRules_Map struct {
        Map *MapRules `protobuf:"bytes,19,opt,name=map,oneof"`
}

type FieldRules_Any struct {
        // Well-Known Field Types
        Any *AnyRules `protobuf:"bytes,20,opt,name=any,oneof"`
}

type FieldRules_Duration struct {
        Duration *DurationRules `protobuf:"bytes,21,opt,name=duration,oneof"`
}

type FieldRules_Timestamp struct {
        Timestamp *TimestampRules `protobuf:"bytes,22,opt,name=timestamp,oneof"`
}

func (*FieldRules_Float) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Double) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Int32) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Int64) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Uint32) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Uint64) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Sint32) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Sint64) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Fixed32) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Fixed64) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Sfixed32) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Sfixed64) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Bool) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_String_) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Bytes) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Enum) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Repeated) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Map) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Any) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Duration) isFieldRules_Type() {<span class="cov0" title="0">}</span>

func (*FieldRules_Timestamp) isFieldRules_Type() {<span class="cov0" title="0">}</span>

// FloatRules describes the constraints applied to `float` values
type FloatRules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Const specifies that this field must be exactly the specified value
        Const *float32 `protobuf:"fixed32,1,opt,name=const" json:"const,omitempty"`
        // Lt specifies that this field must be less than the specified value,
        // exclusive
        Lt *float32 `protobuf:"fixed32,2,opt,name=lt" json:"lt,omitempty"`
        // Lte specifies that this field must be less than or equal to the
        // specified value, inclusive
        Lte *float32 `protobuf:"fixed32,3,opt,name=lte" json:"lte,omitempty"`
        // Gt specifies that this field must be greater than the specified value,
        // exclusive. If the value of Gt is larger than a specified Lt or Lte, the
        // range is reversed.
        Gt *float32 `protobuf:"fixed32,4,opt,name=gt" json:"gt,omitempty"`
        // Gte specifies that this field must be greater than or equal to the
        // specified value, inclusive. If the value of Gte is larger than a
        // specified Lt or Lte, the range is reversed.
        Gte *float32 `protobuf:"fixed32,5,opt,name=gte" json:"gte,omitempty"`
        // In specifies that this field must be equal to one of the specified
        // values
        In []float32 `protobuf:"fixed32,6,rep,name=in" json:"in,omitempty"`
        // NotIn specifies that this field cannot be equal to one of the specified
        // values
        NotIn []float32 `protobuf:"fixed32,7,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
        // IgnoreEmpty specifies that the validation rules of this field should be
        // evaluated only if the field is not empty
        IgnoreEmpty *bool `protobuf:"varint,8,opt,name=ignore_empty,json=ignoreEmpty" json:"ignore_empty,omitempty"`
}

func (x *FloatRules) Reset() <span class="cov0" title="0">{
        *x = FloatRules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *FloatRules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FloatRules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FloatRules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use FloatRules.ProtoReflect.Descriptor instead.
func (*FloatRules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{1}
}</span>

func (x *FloatRules) GetConst() float32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Const != nil </span><span class="cov0" title="0">{
                return *x.Const
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *FloatRules) GetLt() float32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lt != nil </span><span class="cov0" title="0">{
                return *x.Lt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *FloatRules) GetLte() float32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lte != nil </span><span class="cov0" title="0">{
                return *x.Lte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *FloatRules) GetGt() float32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gt != nil </span><span class="cov0" title="0">{
                return *x.Gt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *FloatRules) GetGte() float32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gte != nil </span><span class="cov0" title="0">{
                return *x.Gte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *FloatRules) GetIn() []float32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FloatRules) GetNotIn() []float32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotIn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FloatRules) GetIgnoreEmpty() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.IgnoreEmpty != nil </span><span class="cov0" title="0">{
                return *x.IgnoreEmpty
        }</span>
        <span class="cov0" title="0">return false</span>
}

// DoubleRules describes the constraints applied to `double` values
type DoubleRules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Const specifies that this field must be exactly the specified value
        Const *float64 `protobuf:"fixed64,1,opt,name=const" json:"const,omitempty"`
        // Lt specifies that this field must be less than the specified value,
        // exclusive
        Lt *float64 `protobuf:"fixed64,2,opt,name=lt" json:"lt,omitempty"`
        // Lte specifies that this field must be less than or equal to the
        // specified value, inclusive
        Lte *float64 `protobuf:"fixed64,3,opt,name=lte" json:"lte,omitempty"`
        // Gt specifies that this field must be greater than the specified value,
        // exclusive. If the value of Gt is larger than a specified Lt or Lte, the
        // range is reversed.
        Gt *float64 `protobuf:"fixed64,4,opt,name=gt" json:"gt,omitempty"`
        // Gte specifies that this field must be greater than or equal to the
        // specified value, inclusive. If the value of Gte is larger than a
        // specified Lt or Lte, the range is reversed.
        Gte *float64 `protobuf:"fixed64,5,opt,name=gte" json:"gte,omitempty"`
        // In specifies that this field must be equal to one of the specified
        // values
        In []float64 `protobuf:"fixed64,6,rep,name=in" json:"in,omitempty"`
        // NotIn specifies that this field cannot be equal to one of the specified
        // values
        NotIn []float64 `protobuf:"fixed64,7,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
        // IgnoreEmpty specifies that the validation rules of this field should be
        // evaluated only if the field is not empty
        IgnoreEmpty *bool `protobuf:"varint,8,opt,name=ignore_empty,json=ignoreEmpty" json:"ignore_empty,omitempty"`
}

func (x *DoubleRules) Reset() <span class="cov0" title="0">{
        *x = DoubleRules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DoubleRules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DoubleRules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DoubleRules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DoubleRules.ProtoReflect.Descriptor instead.
func (*DoubleRules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{2}
}</span>

func (x *DoubleRules) GetConst() float64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Const != nil </span><span class="cov0" title="0">{
                return *x.Const
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *DoubleRules) GetLt() float64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lt != nil </span><span class="cov0" title="0">{
                return *x.Lt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *DoubleRules) GetLte() float64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lte != nil </span><span class="cov0" title="0">{
                return *x.Lte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *DoubleRules) GetGt() float64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gt != nil </span><span class="cov0" title="0">{
                return *x.Gt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *DoubleRules) GetGte() float64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gte != nil </span><span class="cov0" title="0">{
                return *x.Gte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *DoubleRules) GetIn() []float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DoubleRules) GetNotIn() []float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotIn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DoubleRules) GetIgnoreEmpty() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.IgnoreEmpty != nil </span><span class="cov0" title="0">{
                return *x.IgnoreEmpty
        }</span>
        <span class="cov0" title="0">return false</span>
}

// Int32Rules describes the constraints applied to `int32` values
type Int32Rules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Const specifies that this field must be exactly the specified value
        Const *int32 `protobuf:"varint,1,opt,name=const" json:"const,omitempty"`
        // Lt specifies that this field must be less than the specified value,
        // exclusive
        Lt *int32 `protobuf:"varint,2,opt,name=lt" json:"lt,omitempty"`
        // Lte specifies that this field must be less than or equal to the
        // specified value, inclusive
        Lte *int32 `protobuf:"varint,3,opt,name=lte" json:"lte,omitempty"`
        // Gt specifies that this field must be greater than the specified value,
        // exclusive. If the value of Gt is larger than a specified Lt or Lte, the
        // range is reversed.
        Gt *int32 `protobuf:"varint,4,opt,name=gt" json:"gt,omitempty"`
        // Gte specifies that this field must be greater than or equal to the
        // specified value, inclusive. If the value of Gte is larger than a
        // specified Lt or Lte, the range is reversed.
        Gte *int32 `protobuf:"varint,5,opt,name=gte" json:"gte,omitempty"`
        // In specifies that this field must be equal to one of the specified
        // values
        In []int32 `protobuf:"varint,6,rep,name=in" json:"in,omitempty"`
        // NotIn specifies that this field cannot be equal to one of the specified
        // values
        NotIn []int32 `protobuf:"varint,7,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
        // IgnoreEmpty specifies that the validation rules of this field should be
        // evaluated only if the field is not empty
        IgnoreEmpty *bool `protobuf:"varint,8,opt,name=ignore_empty,json=ignoreEmpty" json:"ignore_empty,omitempty"`
}

func (x *Int32Rules) Reset() <span class="cov0" title="0">{
        *x = Int32Rules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Int32Rules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Int32Rules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Int32Rules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Int32Rules.ProtoReflect.Descriptor instead.
func (*Int32Rules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{3}
}</span>

func (x *Int32Rules) GetConst() int32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Const != nil </span><span class="cov0" title="0">{
                return *x.Const
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Int32Rules) GetLt() int32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lt != nil </span><span class="cov0" title="0">{
                return *x.Lt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Int32Rules) GetLte() int32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lte != nil </span><span class="cov0" title="0">{
                return *x.Lte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Int32Rules) GetGt() int32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gt != nil </span><span class="cov0" title="0">{
                return *x.Gt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Int32Rules) GetGte() int32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gte != nil </span><span class="cov0" title="0">{
                return *x.Gte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Int32Rules) GetIn() []int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Int32Rules) GetNotIn() []int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotIn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Int32Rules) GetIgnoreEmpty() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.IgnoreEmpty != nil </span><span class="cov0" title="0">{
                return *x.IgnoreEmpty
        }</span>
        <span class="cov0" title="0">return false</span>
}

// Int64Rules describes the constraints applied to `int64` values
type Int64Rules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Const specifies that this field must be exactly the specified value
        Const *int64 `protobuf:"varint,1,opt,name=const" json:"const,omitempty"`
        // Lt specifies that this field must be less than the specified value,
        // exclusive
        Lt *int64 `protobuf:"varint,2,opt,name=lt" json:"lt,omitempty"`
        // Lte specifies that this field must be less than or equal to the
        // specified value, inclusive
        Lte *int64 `protobuf:"varint,3,opt,name=lte" json:"lte,omitempty"`
        // Gt specifies that this field must be greater than the specified value,
        // exclusive. If the value of Gt is larger than a specified Lt or Lte, the
        // range is reversed.
        Gt *int64 `protobuf:"varint,4,opt,name=gt" json:"gt,omitempty"`
        // Gte specifies that this field must be greater than or equal to the
        // specified value, inclusive. If the value of Gte is larger than a
        // specified Lt or Lte, the range is reversed.
        Gte *int64 `protobuf:"varint,5,opt,name=gte" json:"gte,omitempty"`
        // In specifies that this field must be equal to one of the specified
        // values
        In []int64 `protobuf:"varint,6,rep,name=in" json:"in,omitempty"`
        // NotIn specifies that this field cannot be equal to one of the specified
        // values
        NotIn []int64 `protobuf:"varint,7,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
        // IgnoreEmpty specifies that the validation rules of this field should be
        // evaluated only if the field is not empty
        IgnoreEmpty *bool `protobuf:"varint,8,opt,name=ignore_empty,json=ignoreEmpty" json:"ignore_empty,omitempty"`
}

func (x *Int64Rules) Reset() <span class="cov0" title="0">{
        *x = Int64Rules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Int64Rules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Int64Rules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Int64Rules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Int64Rules.ProtoReflect.Descriptor instead.
func (*Int64Rules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{4}
}</span>

func (x *Int64Rules) GetConst() int64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Const != nil </span><span class="cov0" title="0">{
                return *x.Const
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Int64Rules) GetLt() int64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lt != nil </span><span class="cov0" title="0">{
                return *x.Lt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Int64Rules) GetLte() int64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lte != nil </span><span class="cov0" title="0">{
                return *x.Lte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Int64Rules) GetGt() int64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gt != nil </span><span class="cov0" title="0">{
                return *x.Gt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Int64Rules) GetGte() int64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gte != nil </span><span class="cov0" title="0">{
                return *x.Gte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Int64Rules) GetIn() []int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Int64Rules) GetNotIn() []int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotIn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Int64Rules) GetIgnoreEmpty() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.IgnoreEmpty != nil </span><span class="cov0" title="0">{
                return *x.IgnoreEmpty
        }</span>
        <span class="cov0" title="0">return false</span>
}

// UInt32Rules describes the constraints applied to `uint32` values
type UInt32Rules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Const specifies that this field must be exactly the specified value
        Const *uint32 `protobuf:"varint,1,opt,name=const" json:"const,omitempty"`
        // Lt specifies that this field must be less than the specified value,
        // exclusive
        Lt *uint32 `protobuf:"varint,2,opt,name=lt" json:"lt,omitempty"`
        // Lte specifies that this field must be less than or equal to the
        // specified value, inclusive
        Lte *uint32 `protobuf:"varint,3,opt,name=lte" json:"lte,omitempty"`
        // Gt specifies that this field must be greater than the specified value,
        // exclusive. If the value of Gt is larger than a specified Lt or Lte, the
        // range is reversed.
        Gt *uint32 `protobuf:"varint,4,opt,name=gt" json:"gt,omitempty"`
        // Gte specifies that this field must be greater than or equal to the
        // specified value, inclusive. If the value of Gte is larger than a
        // specified Lt or Lte, the range is reversed.
        Gte *uint32 `protobuf:"varint,5,opt,name=gte" json:"gte,omitempty"`
        // In specifies that this field must be equal to one of the specified
        // values
        In []uint32 `protobuf:"varint,6,rep,name=in" json:"in,omitempty"`
        // NotIn specifies that this field cannot be equal to one of the specified
        // values
        NotIn []uint32 `protobuf:"varint,7,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
        // IgnoreEmpty specifies that the validation rules of this field should be
        // evaluated only if the field is not empty
        IgnoreEmpty *bool `protobuf:"varint,8,opt,name=ignore_empty,json=ignoreEmpty" json:"ignore_empty,omitempty"`
}

func (x *UInt32Rules) Reset() <span class="cov0" title="0">{
        *x = UInt32Rules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[5]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UInt32Rules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UInt32Rules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UInt32Rules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[5]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UInt32Rules.ProtoReflect.Descriptor instead.
func (*UInt32Rules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{5}
}</span>

func (x *UInt32Rules) GetConst() uint32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Const != nil </span><span class="cov0" title="0">{
                return *x.Const
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UInt32Rules) GetLt() uint32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lt != nil </span><span class="cov0" title="0">{
                return *x.Lt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UInt32Rules) GetLte() uint32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lte != nil </span><span class="cov0" title="0">{
                return *x.Lte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UInt32Rules) GetGt() uint32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gt != nil </span><span class="cov0" title="0">{
                return *x.Gt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UInt32Rules) GetGte() uint32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gte != nil </span><span class="cov0" title="0">{
                return *x.Gte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UInt32Rules) GetIn() []uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *UInt32Rules) GetNotIn() []uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotIn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *UInt32Rules) GetIgnoreEmpty() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.IgnoreEmpty != nil </span><span class="cov0" title="0">{
                return *x.IgnoreEmpty
        }</span>
        <span class="cov0" title="0">return false</span>
}

// UInt64Rules describes the constraints applied to `uint64` values
type UInt64Rules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Const specifies that this field must be exactly the specified value
        Const *uint64 `protobuf:"varint,1,opt,name=const" json:"const,omitempty"`
        // Lt specifies that this field must be less than the specified value,
        // exclusive
        Lt *uint64 `protobuf:"varint,2,opt,name=lt" json:"lt,omitempty"`
        // Lte specifies that this field must be less than or equal to the
        // specified value, inclusive
        Lte *uint64 `protobuf:"varint,3,opt,name=lte" json:"lte,omitempty"`
        // Gt specifies that this field must be greater than the specified value,
        // exclusive. If the value of Gt is larger than a specified Lt or Lte, the
        // range is reversed.
        Gt *uint64 `protobuf:"varint,4,opt,name=gt" json:"gt,omitempty"`
        // Gte specifies that this field must be greater than or equal to the
        // specified value, inclusive. If the value of Gte is larger than a
        // specified Lt or Lte, the range is reversed.
        Gte *uint64 `protobuf:"varint,5,opt,name=gte" json:"gte,omitempty"`
        // In specifies that this field must be equal to one of the specified
        // values
        In []uint64 `protobuf:"varint,6,rep,name=in" json:"in,omitempty"`
        // NotIn specifies that this field cannot be equal to one of the specified
        // values
        NotIn []uint64 `protobuf:"varint,7,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
        // IgnoreEmpty specifies that the validation rules of this field should be
        // evaluated only if the field is not empty
        IgnoreEmpty *bool `protobuf:"varint,8,opt,name=ignore_empty,json=ignoreEmpty" json:"ignore_empty,omitempty"`
}

func (x *UInt64Rules) Reset() <span class="cov0" title="0">{
        *x = UInt64Rules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[6]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UInt64Rules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UInt64Rules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UInt64Rules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[6]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UInt64Rules.ProtoReflect.Descriptor instead.
func (*UInt64Rules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{6}
}</span>

func (x *UInt64Rules) GetConst() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Const != nil </span><span class="cov0" title="0">{
                return *x.Const
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UInt64Rules) GetLt() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lt != nil </span><span class="cov0" title="0">{
                return *x.Lt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UInt64Rules) GetLte() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lte != nil </span><span class="cov0" title="0">{
                return *x.Lte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UInt64Rules) GetGt() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gt != nil </span><span class="cov0" title="0">{
                return *x.Gt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UInt64Rules) GetGte() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gte != nil </span><span class="cov0" title="0">{
                return *x.Gte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UInt64Rules) GetIn() []uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *UInt64Rules) GetNotIn() []uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotIn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *UInt64Rules) GetIgnoreEmpty() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.IgnoreEmpty != nil </span><span class="cov0" title="0">{
                return *x.IgnoreEmpty
        }</span>
        <span class="cov0" title="0">return false</span>
}

// SInt32Rules describes the constraints applied to `sint32` values
type SInt32Rules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Const specifies that this field must be exactly the specified value
        Const *int32 `protobuf:"zigzag32,1,opt,name=const" json:"const,omitempty"`
        // Lt specifies that this field must be less than the specified value,
        // exclusive
        Lt *int32 `protobuf:"zigzag32,2,opt,name=lt" json:"lt,omitempty"`
        // Lte specifies that this field must be less than or equal to the
        // specified value, inclusive
        Lte *int32 `protobuf:"zigzag32,3,opt,name=lte" json:"lte,omitempty"`
        // Gt specifies that this field must be greater than the specified value,
        // exclusive. If the value of Gt is larger than a specified Lt or Lte, the
        // range is reversed.
        Gt *int32 `protobuf:"zigzag32,4,opt,name=gt" json:"gt,omitempty"`
        // Gte specifies that this field must be greater than or equal to the
        // specified value, inclusive. If the value of Gte is larger than a
        // specified Lt or Lte, the range is reversed.
        Gte *int32 `protobuf:"zigzag32,5,opt,name=gte" json:"gte,omitempty"`
        // In specifies that this field must be equal to one of the specified
        // values
        In []int32 `protobuf:"zigzag32,6,rep,name=in" json:"in,omitempty"`
        // NotIn specifies that this field cannot be equal to one of the specified
        // values
        NotIn []int32 `protobuf:"zigzag32,7,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
        // IgnoreEmpty specifies that the validation rules of this field should be
        // evaluated only if the field is not empty
        IgnoreEmpty *bool `protobuf:"varint,8,opt,name=ignore_empty,json=ignoreEmpty" json:"ignore_empty,omitempty"`
}

func (x *SInt32Rules) Reset() <span class="cov0" title="0">{
        *x = SInt32Rules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[7]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *SInt32Rules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SInt32Rules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SInt32Rules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[7]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SInt32Rules.ProtoReflect.Descriptor instead.
func (*SInt32Rules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{7}
}</span>

func (x *SInt32Rules) GetConst() int32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Const != nil </span><span class="cov0" title="0">{
                return *x.Const
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SInt32Rules) GetLt() int32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lt != nil </span><span class="cov0" title="0">{
                return *x.Lt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SInt32Rules) GetLte() int32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lte != nil </span><span class="cov0" title="0">{
                return *x.Lte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SInt32Rules) GetGt() int32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gt != nil </span><span class="cov0" title="0">{
                return *x.Gt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SInt32Rules) GetGte() int32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gte != nil </span><span class="cov0" title="0">{
                return *x.Gte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SInt32Rules) GetIn() []int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SInt32Rules) GetNotIn() []int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotIn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SInt32Rules) GetIgnoreEmpty() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.IgnoreEmpty != nil </span><span class="cov0" title="0">{
                return *x.IgnoreEmpty
        }</span>
        <span class="cov0" title="0">return false</span>
}

// SInt64Rules describes the constraints applied to `sint64` values
type SInt64Rules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Const specifies that this field must be exactly the specified value
        Const *int64 `protobuf:"zigzag64,1,opt,name=const" json:"const,omitempty"`
        // Lt specifies that this field must be less than the specified value,
        // exclusive
        Lt *int64 `protobuf:"zigzag64,2,opt,name=lt" json:"lt,omitempty"`
        // Lte specifies that this field must be less than or equal to the
        // specified value, inclusive
        Lte *int64 `protobuf:"zigzag64,3,opt,name=lte" json:"lte,omitempty"`
        // Gt specifies that this field must be greater than the specified value,
        // exclusive. If the value of Gt is larger than a specified Lt or Lte, the
        // range is reversed.
        Gt *int64 `protobuf:"zigzag64,4,opt,name=gt" json:"gt,omitempty"`
        // Gte specifies that this field must be greater than or equal to the
        // specified value, inclusive. If the value of Gte is larger than a
        // specified Lt or Lte, the range is reversed.
        Gte *int64 `protobuf:"zigzag64,5,opt,name=gte" json:"gte,omitempty"`
        // In specifies that this field must be equal to one of the specified
        // values
        In []int64 `protobuf:"zigzag64,6,rep,name=in" json:"in,omitempty"`
        // NotIn specifies that this field cannot be equal to one of the specified
        // values
        NotIn []int64 `protobuf:"zigzag64,7,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
        // IgnoreEmpty specifies that the validation rules of this field should be
        // evaluated only if the field is not empty
        IgnoreEmpty *bool `protobuf:"varint,8,opt,name=ignore_empty,json=ignoreEmpty" json:"ignore_empty,omitempty"`
}

func (x *SInt64Rules) Reset() <span class="cov0" title="0">{
        *x = SInt64Rules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[8]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *SInt64Rules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SInt64Rules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SInt64Rules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[8]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SInt64Rules.ProtoReflect.Descriptor instead.
func (*SInt64Rules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{8}
}</span>

func (x *SInt64Rules) GetConst() int64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Const != nil </span><span class="cov0" title="0">{
                return *x.Const
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SInt64Rules) GetLt() int64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lt != nil </span><span class="cov0" title="0">{
                return *x.Lt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SInt64Rules) GetLte() int64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lte != nil </span><span class="cov0" title="0">{
                return *x.Lte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SInt64Rules) GetGt() int64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gt != nil </span><span class="cov0" title="0">{
                return *x.Gt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SInt64Rules) GetGte() int64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gte != nil </span><span class="cov0" title="0">{
                return *x.Gte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SInt64Rules) GetIn() []int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SInt64Rules) GetNotIn() []int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotIn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SInt64Rules) GetIgnoreEmpty() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.IgnoreEmpty != nil </span><span class="cov0" title="0">{
                return *x.IgnoreEmpty
        }</span>
        <span class="cov0" title="0">return false</span>
}

// Fixed32Rules describes the constraints applied to `fixed32` values
type Fixed32Rules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Const specifies that this field must be exactly the specified value
        Const *uint32 `protobuf:"fixed32,1,opt,name=const" json:"const,omitempty"`
        // Lt specifies that this field must be less than the specified value,
        // exclusive
        Lt *uint32 `protobuf:"fixed32,2,opt,name=lt" json:"lt,omitempty"`
        // Lte specifies that this field must be less than or equal to the
        // specified value, inclusive
        Lte *uint32 `protobuf:"fixed32,3,opt,name=lte" json:"lte,omitempty"`
        // Gt specifies that this field must be greater than the specified value,
        // exclusive. If the value of Gt is larger than a specified Lt or Lte, the
        // range is reversed.
        Gt *uint32 `protobuf:"fixed32,4,opt,name=gt" json:"gt,omitempty"`
        // Gte specifies that this field must be greater than or equal to the
        // specified value, inclusive. If the value of Gte is larger than a
        // specified Lt or Lte, the range is reversed.
        Gte *uint32 `protobuf:"fixed32,5,opt,name=gte" json:"gte,omitempty"`
        // In specifies that this field must be equal to one of the specified
        // values
        In []uint32 `protobuf:"fixed32,6,rep,name=in" json:"in,omitempty"`
        // NotIn specifies that this field cannot be equal to one of the specified
        // values
        NotIn []uint32 `protobuf:"fixed32,7,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
        // IgnoreEmpty specifies that the validation rules of this field should be
        // evaluated only if the field is not empty
        IgnoreEmpty *bool `protobuf:"varint,8,opt,name=ignore_empty,json=ignoreEmpty" json:"ignore_empty,omitempty"`
}

func (x *Fixed32Rules) Reset() <span class="cov0" title="0">{
        *x = Fixed32Rules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[9]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Fixed32Rules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Fixed32Rules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Fixed32Rules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[9]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Fixed32Rules.ProtoReflect.Descriptor instead.
func (*Fixed32Rules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{9}
}</span>

func (x *Fixed32Rules) GetConst() uint32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Const != nil </span><span class="cov0" title="0">{
                return *x.Const
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Fixed32Rules) GetLt() uint32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lt != nil </span><span class="cov0" title="0">{
                return *x.Lt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Fixed32Rules) GetLte() uint32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lte != nil </span><span class="cov0" title="0">{
                return *x.Lte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Fixed32Rules) GetGt() uint32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gt != nil </span><span class="cov0" title="0">{
                return *x.Gt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Fixed32Rules) GetGte() uint32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gte != nil </span><span class="cov0" title="0">{
                return *x.Gte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Fixed32Rules) GetIn() []uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Fixed32Rules) GetNotIn() []uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotIn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Fixed32Rules) GetIgnoreEmpty() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.IgnoreEmpty != nil </span><span class="cov0" title="0">{
                return *x.IgnoreEmpty
        }</span>
        <span class="cov0" title="0">return false</span>
}

// Fixed64Rules describes the constraints applied to `fixed64` values
type Fixed64Rules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Const specifies that this field must be exactly the specified value
        Const *uint64 `protobuf:"fixed64,1,opt,name=const" json:"const,omitempty"`
        // Lt specifies that this field must be less than the specified value,
        // exclusive
        Lt *uint64 `protobuf:"fixed64,2,opt,name=lt" json:"lt,omitempty"`
        // Lte specifies that this field must be less than or equal to the
        // specified value, inclusive
        Lte *uint64 `protobuf:"fixed64,3,opt,name=lte" json:"lte,omitempty"`
        // Gt specifies that this field must be greater than the specified value,
        // exclusive. If the value of Gt is larger than a specified Lt or Lte, the
        // range is reversed.
        Gt *uint64 `protobuf:"fixed64,4,opt,name=gt" json:"gt,omitempty"`
        // Gte specifies that this field must be greater than or equal to the
        // specified value, inclusive. If the value of Gte is larger than a
        // specified Lt or Lte, the range is reversed.
        Gte *uint64 `protobuf:"fixed64,5,opt,name=gte" json:"gte,omitempty"`
        // In specifies that this field must be equal to one of the specified
        // values
        In []uint64 `protobuf:"fixed64,6,rep,name=in" json:"in,omitempty"`
        // NotIn specifies that this field cannot be equal to one of the specified
        // values
        NotIn []uint64 `protobuf:"fixed64,7,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
        // IgnoreEmpty specifies that the validation rules of this field should be
        // evaluated only if the field is not empty
        IgnoreEmpty *bool `protobuf:"varint,8,opt,name=ignore_empty,json=ignoreEmpty" json:"ignore_empty,omitempty"`
}

func (x *Fixed64Rules) Reset() <span class="cov0" title="0">{
        *x = Fixed64Rules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[10]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Fixed64Rules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Fixed64Rules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Fixed64Rules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[10]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Fixed64Rules.ProtoReflect.Descriptor instead.
func (*Fixed64Rules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{10}
}</span>

func (x *Fixed64Rules) GetConst() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Const != nil </span><span class="cov0" title="0">{
                return *x.Const
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Fixed64Rules) GetLt() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lt != nil </span><span class="cov0" title="0">{
                return *x.Lt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Fixed64Rules) GetLte() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lte != nil </span><span class="cov0" title="0">{
                return *x.Lte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Fixed64Rules) GetGt() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gt != nil </span><span class="cov0" title="0">{
                return *x.Gt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Fixed64Rules) GetGte() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gte != nil </span><span class="cov0" title="0">{
                return *x.Gte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Fixed64Rules) GetIn() []uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Fixed64Rules) GetNotIn() []uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotIn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Fixed64Rules) GetIgnoreEmpty() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.IgnoreEmpty != nil </span><span class="cov0" title="0">{
                return *x.IgnoreEmpty
        }</span>
        <span class="cov0" title="0">return false</span>
}

// SFixed32Rules describes the constraints applied to `sfixed32` values
type SFixed32Rules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Const specifies that this field must be exactly the specified value
        Const *int32 `protobuf:"fixed32,1,opt,name=const" json:"const,omitempty"`
        // Lt specifies that this field must be less than the specified value,
        // exclusive
        Lt *int32 `protobuf:"fixed32,2,opt,name=lt" json:"lt,omitempty"`
        // Lte specifies that this field must be less than or equal to the
        // specified value, inclusive
        Lte *int32 `protobuf:"fixed32,3,opt,name=lte" json:"lte,omitempty"`
        // Gt specifies that this field must be greater than the specified value,
        // exclusive. If the value of Gt is larger than a specified Lt or Lte, the
        // range is reversed.
        Gt *int32 `protobuf:"fixed32,4,opt,name=gt" json:"gt,omitempty"`
        // Gte specifies that this field must be greater than or equal to the
        // specified value, inclusive. If the value of Gte is larger than a
        // specified Lt or Lte, the range is reversed.
        Gte *int32 `protobuf:"fixed32,5,opt,name=gte" json:"gte,omitempty"`
        // In specifies that this field must be equal to one of the specified
        // values
        In []int32 `protobuf:"fixed32,6,rep,name=in" json:"in,omitempty"`
        // NotIn specifies that this field cannot be equal to one of the specified
        // values
        NotIn []int32 `protobuf:"fixed32,7,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
        // IgnoreEmpty specifies that the validation rules of this field should be
        // evaluated only if the field is not empty
        IgnoreEmpty *bool `protobuf:"varint,8,opt,name=ignore_empty,json=ignoreEmpty" json:"ignore_empty,omitempty"`
}

func (x *SFixed32Rules) Reset() <span class="cov0" title="0">{
        *x = SFixed32Rules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[11]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *SFixed32Rules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SFixed32Rules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SFixed32Rules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[11]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SFixed32Rules.ProtoReflect.Descriptor instead.
func (*SFixed32Rules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{11}
}</span>

func (x *SFixed32Rules) GetConst() int32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Const != nil </span><span class="cov0" title="0">{
                return *x.Const
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SFixed32Rules) GetLt() int32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lt != nil </span><span class="cov0" title="0">{
                return *x.Lt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SFixed32Rules) GetLte() int32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lte != nil </span><span class="cov0" title="0">{
                return *x.Lte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SFixed32Rules) GetGt() int32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gt != nil </span><span class="cov0" title="0">{
                return *x.Gt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SFixed32Rules) GetGte() int32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gte != nil </span><span class="cov0" title="0">{
                return *x.Gte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SFixed32Rules) GetIn() []int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SFixed32Rules) GetNotIn() []int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotIn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SFixed32Rules) GetIgnoreEmpty() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.IgnoreEmpty != nil </span><span class="cov0" title="0">{
                return *x.IgnoreEmpty
        }</span>
        <span class="cov0" title="0">return false</span>
}

// SFixed64Rules describes the constraints applied to `sfixed64` values
type SFixed64Rules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Const specifies that this field must be exactly the specified value
        Const *int64 `protobuf:"fixed64,1,opt,name=const" json:"const,omitempty"`
        // Lt specifies that this field must be less than the specified value,
        // exclusive
        Lt *int64 `protobuf:"fixed64,2,opt,name=lt" json:"lt,omitempty"`
        // Lte specifies that this field must be less than or equal to the
        // specified value, inclusive
        Lte *int64 `protobuf:"fixed64,3,opt,name=lte" json:"lte,omitempty"`
        // Gt specifies that this field must be greater than the specified value,
        // exclusive. If the value of Gt is larger than a specified Lt or Lte, the
        // range is reversed.
        Gt *int64 `protobuf:"fixed64,4,opt,name=gt" json:"gt,omitempty"`
        // Gte specifies that this field must be greater than or equal to the
        // specified value, inclusive. If the value of Gte is larger than a
        // specified Lt or Lte, the range is reversed.
        Gte *int64 `protobuf:"fixed64,5,opt,name=gte" json:"gte,omitempty"`
        // In specifies that this field must be equal to one of the specified
        // values
        In []int64 `protobuf:"fixed64,6,rep,name=in" json:"in,omitempty"`
        // NotIn specifies that this field cannot be equal to one of the specified
        // values
        NotIn []int64 `protobuf:"fixed64,7,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
        // IgnoreEmpty specifies that the validation rules of this field should be
        // evaluated only if the field is not empty
        IgnoreEmpty *bool `protobuf:"varint,8,opt,name=ignore_empty,json=ignoreEmpty" json:"ignore_empty,omitempty"`
}

func (x *SFixed64Rules) Reset() <span class="cov0" title="0">{
        *x = SFixed64Rules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[12]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *SFixed64Rules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SFixed64Rules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SFixed64Rules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[12]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SFixed64Rules.ProtoReflect.Descriptor instead.
func (*SFixed64Rules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{12}
}</span>

func (x *SFixed64Rules) GetConst() int64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Const != nil </span><span class="cov0" title="0">{
                return *x.Const
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SFixed64Rules) GetLt() int64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lt != nil </span><span class="cov0" title="0">{
                return *x.Lt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SFixed64Rules) GetLte() int64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Lte != nil </span><span class="cov0" title="0">{
                return *x.Lte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SFixed64Rules) GetGt() int64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gt != nil </span><span class="cov0" title="0">{
                return *x.Gt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SFixed64Rules) GetGte() int64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Gte != nil </span><span class="cov0" title="0">{
                return *x.Gte
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SFixed64Rules) GetIn() []int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SFixed64Rules) GetNotIn() []int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotIn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SFixed64Rules) GetIgnoreEmpty() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.IgnoreEmpty != nil </span><span class="cov0" title="0">{
                return *x.IgnoreEmpty
        }</span>
        <span class="cov0" title="0">return false</span>
}

// BoolRules describes the constraints applied to `bool` values
type BoolRules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Const specifies that this field must be exactly the specified value
        Const *bool `protobuf:"varint,1,opt,name=const" json:"const,omitempty"`
}

func (x *BoolRules) Reset() <span class="cov0" title="0">{
        *x = BoolRules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[13]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *BoolRules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*BoolRules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *BoolRules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[13]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use BoolRules.ProtoReflect.Descriptor instead.
func (*BoolRules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{13}
}</span>

func (x *BoolRules) GetConst() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Const != nil </span><span class="cov0" title="0">{
                return *x.Const
        }</span>
        <span class="cov0" title="0">return false</span>
}

// StringRules describe the constraints applied to `string` values
type StringRules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Const specifies that this field must be exactly the specified value
        Const *string `protobuf:"bytes,1,opt,name=const" json:"const,omitempty"`
        // Len specifies that this field must be the specified number of
        // characters (Unicode code points). Note that the number of
        // characters may differ from the number of bytes in the string.
        Len *uint64 `protobuf:"varint,19,opt,name=len" json:"len,omitempty"`
        // MinLen specifies that this field must be the specified number of
        // characters (Unicode code points) at a minimum. Note that the number of
        // characters may differ from the number of bytes in the string.
        MinLen *uint64 `protobuf:"varint,2,opt,name=min_len,json=minLen" json:"min_len,omitempty"`
        // MaxLen specifies that this field must be the specified number of
        // characters (Unicode code points) at a maximum. Note that the number of
        // characters may differ from the number of bytes in the string.
        MaxLen *uint64 `protobuf:"varint,3,opt,name=max_len,json=maxLen" json:"max_len,omitempty"`
        // LenBytes specifies that this field must be the specified number of bytes
        LenBytes *uint64 `protobuf:"varint,20,opt,name=len_bytes,json=lenBytes" json:"len_bytes,omitempty"`
        // MinBytes specifies that this field must be the specified number of bytes
        // at a minimum
        MinBytes *uint64 `protobuf:"varint,4,opt,name=min_bytes,json=minBytes" json:"min_bytes,omitempty"`
        // MaxBytes specifies that this field must be the specified number of bytes
        // at a maximum
        MaxBytes *uint64 `protobuf:"varint,5,opt,name=max_bytes,json=maxBytes" json:"max_bytes,omitempty"`
        // Pattern specifies that this field must match against the specified
        // regular expression (RE2 syntax). The included expression should elide
        // any delimiters.
        Pattern *string `protobuf:"bytes,6,opt,name=pattern" json:"pattern,omitempty"`
        // Prefix specifies that this field must have the specified substring at
        // the beginning of the string.
        Prefix *string `protobuf:"bytes,7,opt,name=prefix" json:"prefix,omitempty"`
        // Suffix specifies that this field must have the specified substring at
        // the end of the string.
        Suffix *string `protobuf:"bytes,8,opt,name=suffix" json:"suffix,omitempty"`
        // Contains specifies that this field must have the specified substring
        // anywhere in the string.
        Contains *string `protobuf:"bytes,9,opt,name=contains" json:"contains,omitempty"`
        // NotContains specifies that this field cannot have the specified substring
        // anywhere in the string.
        NotContains *string `protobuf:"bytes,23,opt,name=not_contains,json=notContains" json:"not_contains,omitempty"`
        // In specifies that this field must be equal to one of the specified
        // values
        In []string `protobuf:"bytes,10,rep,name=in" json:"in,omitempty"`
        // NotIn specifies that this field cannot be equal to one of the specified
        // values
        NotIn []string `protobuf:"bytes,11,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
        // WellKnown rules provide advanced constraints against common string
        // patterns
        //
        // Types that are assignable to WellKnown:
        //
        //        *StringRules_Email
        //        *StringRules_Hostname
        //        *StringRules_Ip
        //        *StringRules_Ipv4
        //        *StringRules_Ipv6
        //        *StringRules_Uri
        //        *StringRules_UriRef
        //        *StringRules_Address
        //        *StringRules_Uuid
        //        *StringRules_WellKnownRegex
        WellKnown isStringRules_WellKnown `protobuf_oneof:"well_known"`
        // This applies to regexes HTTP_HEADER_NAME and HTTP_HEADER_VALUE to enable
        // strict header validation.
        // By default, this is true, and HTTP header validations are RFC-compliant.
        // Setting to false will enable a looser validations that only disallows
        // \r\n\0 characters, which can be used to bypass header matching rules.
        Strict *bool `protobuf:"varint,25,opt,name=strict,def=1" json:"strict,omitempty"`
        // IgnoreEmpty specifies that the validation rules of this field should be
        // evaluated only if the field is not empty
        IgnoreEmpty *bool `protobuf:"varint,26,opt,name=ignore_empty,json=ignoreEmpty" json:"ignore_empty,omitempty"`
}

// Default values for StringRules fields.
const (
        Default_StringRules_Strict = bool(true)
)

func (x *StringRules) Reset() <span class="cov0" title="0">{
        *x = StringRules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[14]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *StringRules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StringRules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StringRules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[14]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StringRules.ProtoReflect.Descriptor instead.
func (*StringRules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{14}
}</span>

func (x *StringRules) GetConst() string <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Const != nil </span><span class="cov0" title="0">{
                return *x.Const
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *StringRules) GetLen() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Len != nil </span><span class="cov0" title="0">{
                return *x.Len
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *StringRules) GetMinLen() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.MinLen != nil </span><span class="cov0" title="0">{
                return *x.MinLen
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *StringRules) GetMaxLen() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.MaxLen != nil </span><span class="cov0" title="0">{
                return *x.MaxLen
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *StringRules) GetLenBytes() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.LenBytes != nil </span><span class="cov0" title="0">{
                return *x.LenBytes
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *StringRules) GetMinBytes() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.MinBytes != nil </span><span class="cov0" title="0">{
                return *x.MinBytes
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *StringRules) GetMaxBytes() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.MaxBytes != nil </span><span class="cov0" title="0">{
                return *x.MaxBytes
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *StringRules) GetPattern() string <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Pattern != nil </span><span class="cov0" title="0">{
                return *x.Pattern
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *StringRules) GetPrefix() string <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Prefix != nil </span><span class="cov0" title="0">{
                return *x.Prefix
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *StringRules) GetSuffix() string <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Suffix != nil </span><span class="cov0" title="0">{
                return *x.Suffix
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *StringRules) GetContains() string <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Contains != nil </span><span class="cov0" title="0">{
                return *x.Contains
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *StringRules) GetNotContains() string <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.NotContains != nil </span><span class="cov0" title="0">{
                return *x.NotContains
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *StringRules) GetIn() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *StringRules) GetNotIn() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotIn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *StringRules) GetWellKnown() isStringRules_WellKnown <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.WellKnown
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *StringRules) GetEmail() bool <span class="cov0" title="0">{
        if x, ok := x.GetWellKnown().(*StringRules_Email); ok </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *StringRules) GetHostname() bool <span class="cov0" title="0">{
        if x, ok := x.GetWellKnown().(*StringRules_Hostname); ok </span><span class="cov0" title="0">{
                return x.Hostname
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *StringRules) GetIp() bool <span class="cov0" title="0">{
        if x, ok := x.GetWellKnown().(*StringRules_Ip); ok </span><span class="cov0" title="0">{
                return x.Ip
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *StringRules) GetIpv4() bool <span class="cov0" title="0">{
        if x, ok := x.GetWellKnown().(*StringRules_Ipv4); ok </span><span class="cov0" title="0">{
                return x.Ipv4
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *StringRules) GetIpv6() bool <span class="cov0" title="0">{
        if x, ok := x.GetWellKnown().(*StringRules_Ipv6); ok </span><span class="cov0" title="0">{
                return x.Ipv6
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *StringRules) GetUri() bool <span class="cov0" title="0">{
        if x, ok := x.GetWellKnown().(*StringRules_Uri); ok </span><span class="cov0" title="0">{
                return x.Uri
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *StringRules) GetUriRef() bool <span class="cov0" title="0">{
        if x, ok := x.GetWellKnown().(*StringRules_UriRef); ok </span><span class="cov0" title="0">{
                return x.UriRef
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *StringRules) GetAddress() bool <span class="cov0" title="0">{
        if x, ok := x.GetWellKnown().(*StringRules_Address); ok </span><span class="cov0" title="0">{
                return x.Address
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *StringRules) GetUuid() bool <span class="cov0" title="0">{
        if x, ok := x.GetWellKnown().(*StringRules_Uuid); ok </span><span class="cov0" title="0">{
                return x.Uuid
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *StringRules) GetWellKnownRegex() KnownRegex <span class="cov0" title="0">{
        if x, ok := x.GetWellKnown().(*StringRules_WellKnownRegex); ok </span><span class="cov0" title="0">{
                return x.WellKnownRegex
        }</span>
        <span class="cov0" title="0">return KnownRegex_UNKNOWN</span>
}

func (x *StringRules) GetStrict() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Strict != nil </span><span class="cov0" title="0">{
                return *x.Strict
        }</span>
        <span class="cov0" title="0">return Default_StringRules_Strict</span>
}

func (x *StringRules) GetIgnoreEmpty() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.IgnoreEmpty != nil </span><span class="cov0" title="0">{
                return *x.IgnoreEmpty
        }</span>
        <span class="cov0" title="0">return false</span>
}

type isStringRules_WellKnown interface {
        isStringRules_WellKnown()
}

type StringRules_Email struct {
        // Email specifies that the field must be a valid email address as
        // defined by RFC 5322
        Email bool `protobuf:"varint,12,opt,name=email,oneof"`
}

type StringRules_Hostname struct {
        // Hostname specifies that the field must be a valid hostname as
        // defined by RFC 1034. This constraint does not support
        // internationalized domain names (IDNs).
        Hostname bool `protobuf:"varint,13,opt,name=hostname,oneof"`
}

type StringRules_Ip struct {
        // Ip specifies that the field must be a valid IP (v4 or v6) address.
        // Valid IPv6 addresses should not include surrounding square brackets.
        Ip bool `protobuf:"varint,14,opt,name=ip,oneof"`
}

type StringRules_Ipv4 struct {
        // Ipv4 specifies that the field must be a valid IPv4 address.
        Ipv4 bool `protobuf:"varint,15,opt,name=ipv4,oneof"`
}

type StringRules_Ipv6 struct {
        // Ipv6 specifies that the field must be a valid IPv6 address. Valid
        // IPv6 addresses should not include surrounding square brackets.
        Ipv6 bool `protobuf:"varint,16,opt,name=ipv6,oneof"`
}

type StringRules_Uri struct {
        // Uri specifies that the field must be a valid, absolute URI as defined
        // by RFC 3986
        Uri bool `protobuf:"varint,17,opt,name=uri,oneof"`
}

type StringRules_UriRef struct {
        // UriRef specifies that the field must be a valid URI as defined by RFC
        // 3986 and may be relative or absolute.
        UriRef bool `protobuf:"varint,18,opt,name=uri_ref,json=uriRef,oneof"`
}

type StringRules_Address struct {
        // Address specifies that the field must be either a valid hostname as
        // defined by RFC 1034 (which does not support internationalized domain
        // names or IDNs), or it can be a valid IP (v4 or v6).
        Address bool `protobuf:"varint,21,opt,name=address,oneof"`
}

type StringRules_Uuid struct {
        // Uuid specifies that the field must be a valid UUID as defined by
        // RFC 4122
        Uuid bool `protobuf:"varint,22,opt,name=uuid,oneof"`
}

type StringRules_WellKnownRegex struct {
        // WellKnownRegex specifies a common well known pattern defined as a regex.
        WellKnownRegex KnownRegex `protobuf:"varint,24,opt,name=well_known_regex,json=wellKnownRegex,enum=validate.KnownRegex,oneof"`
}

func (*StringRules_Email) isStringRules_WellKnown() {<span class="cov0" title="0">}</span>

func (*StringRules_Hostname) isStringRules_WellKnown() {<span class="cov0" title="0">}</span>

func (*StringRules_Ip) isStringRules_WellKnown() {<span class="cov0" title="0">}</span>

func (*StringRules_Ipv4) isStringRules_WellKnown() {<span class="cov0" title="0">}</span>

func (*StringRules_Ipv6) isStringRules_WellKnown() {<span class="cov0" title="0">}</span>

func (*StringRules_Uri) isStringRules_WellKnown() {<span class="cov0" title="0">}</span>

func (*StringRules_UriRef) isStringRules_WellKnown() {<span class="cov0" title="0">}</span>

func (*StringRules_Address) isStringRules_WellKnown() {<span class="cov0" title="0">}</span>

func (*StringRules_Uuid) isStringRules_WellKnown() {<span class="cov0" title="0">}</span>

func (*StringRules_WellKnownRegex) isStringRules_WellKnown() {<span class="cov0" title="0">}</span>

// BytesRules describe the constraints applied to `bytes` values
type BytesRules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Const specifies that this field must be exactly the specified value
        Const []byte `protobuf:"bytes,1,opt,name=const" json:"const,omitempty"`
        // Len specifies that this field must be the specified number of bytes
        Len *uint64 `protobuf:"varint,13,opt,name=len" json:"len,omitempty"`
        // MinLen specifies that this field must be the specified number of bytes
        // at a minimum
        MinLen *uint64 `protobuf:"varint,2,opt,name=min_len,json=minLen" json:"min_len,omitempty"`
        // MaxLen specifies that this field must be the specified number of bytes
        // at a maximum
        MaxLen *uint64 `protobuf:"varint,3,opt,name=max_len,json=maxLen" json:"max_len,omitempty"`
        // Pattern specifies that this field must match against the specified
        // regular expression (RE2 syntax). The included expression should elide
        // any delimiters.
        Pattern *string `protobuf:"bytes,4,opt,name=pattern" json:"pattern,omitempty"`
        // Prefix specifies that this field must have the specified bytes at the
        // beginning of the string.
        Prefix []byte `protobuf:"bytes,5,opt,name=prefix" json:"prefix,omitempty"`
        // Suffix specifies that this field must have the specified bytes at the
        // end of the string.
        Suffix []byte `protobuf:"bytes,6,opt,name=suffix" json:"suffix,omitempty"`
        // Contains specifies that this field must have the specified bytes
        // anywhere in the string.
        Contains []byte `protobuf:"bytes,7,opt,name=contains" json:"contains,omitempty"`
        // In specifies that this field must be equal to one of the specified
        // values
        In [][]byte `protobuf:"bytes,8,rep,name=in" json:"in,omitempty"`
        // NotIn specifies that this field cannot be equal to one of the specified
        // values
        NotIn [][]byte `protobuf:"bytes,9,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
        // WellKnown rules provide advanced constraints against common byte
        // patterns
        //
        // Types that are assignable to WellKnown:
        //
        //        *BytesRules_Ip
        //        *BytesRules_Ipv4
        //        *BytesRules_Ipv6
        WellKnown isBytesRules_WellKnown `protobuf_oneof:"well_known"`
        // IgnoreEmpty specifies that the validation rules of this field should be
        // evaluated only if the field is not empty
        IgnoreEmpty *bool `protobuf:"varint,14,opt,name=ignore_empty,json=ignoreEmpty" json:"ignore_empty,omitempty"`
}

func (x *BytesRules) Reset() <span class="cov0" title="0">{
        *x = BytesRules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[15]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *BytesRules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*BytesRules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *BytesRules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[15]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use BytesRules.ProtoReflect.Descriptor instead.
func (*BytesRules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{15}
}</span>

func (x *BytesRules) GetConst() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Const
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *BytesRules) GetLen() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Len != nil </span><span class="cov0" title="0">{
                return *x.Len
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *BytesRules) GetMinLen() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.MinLen != nil </span><span class="cov0" title="0">{
                return *x.MinLen
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *BytesRules) GetMaxLen() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.MaxLen != nil </span><span class="cov0" title="0">{
                return *x.MaxLen
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *BytesRules) GetPattern() string <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Pattern != nil </span><span class="cov0" title="0">{
                return *x.Pattern
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *BytesRules) GetPrefix() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Prefix
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *BytesRules) GetSuffix() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Suffix
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *BytesRules) GetContains() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Contains
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *BytesRules) GetIn() [][]byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *BytesRules) GetNotIn() [][]byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotIn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *BytesRules) GetWellKnown() isBytesRules_WellKnown <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.WellKnown
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *BytesRules) GetIp() bool <span class="cov0" title="0">{
        if x, ok := x.GetWellKnown().(*BytesRules_Ip); ok </span><span class="cov0" title="0">{
                return x.Ip
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *BytesRules) GetIpv4() bool <span class="cov0" title="0">{
        if x, ok := x.GetWellKnown().(*BytesRules_Ipv4); ok </span><span class="cov0" title="0">{
                return x.Ipv4
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *BytesRules) GetIpv6() bool <span class="cov0" title="0">{
        if x, ok := x.GetWellKnown().(*BytesRules_Ipv6); ok </span><span class="cov0" title="0">{
                return x.Ipv6
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *BytesRules) GetIgnoreEmpty() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.IgnoreEmpty != nil </span><span class="cov0" title="0">{
                return *x.IgnoreEmpty
        }</span>
        <span class="cov0" title="0">return false</span>
}

type isBytesRules_WellKnown interface {
        isBytesRules_WellKnown()
}

type BytesRules_Ip struct {
        // Ip specifies that the field must be a valid IP (v4 or v6) address in
        // byte format
        Ip bool `protobuf:"varint,10,opt,name=ip,oneof"`
}

type BytesRules_Ipv4 struct {
        // Ipv4 specifies that the field must be a valid IPv4 address in byte
        // format
        Ipv4 bool `protobuf:"varint,11,opt,name=ipv4,oneof"`
}

type BytesRules_Ipv6 struct {
        // Ipv6 specifies that the field must be a valid IPv6 address in byte
        // format
        Ipv6 bool `protobuf:"varint,12,opt,name=ipv6,oneof"`
}

func (*BytesRules_Ip) isBytesRules_WellKnown() {<span class="cov0" title="0">}</span>

func (*BytesRules_Ipv4) isBytesRules_WellKnown() {<span class="cov0" title="0">}</span>

func (*BytesRules_Ipv6) isBytesRules_WellKnown() {<span class="cov0" title="0">}</span>

// EnumRules describe the constraints applied to enum values
type EnumRules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Const specifies that this field must be exactly the specified value
        Const *int32 `protobuf:"varint,1,opt,name=const" json:"const,omitempty"`
        // DefinedOnly specifies that this field must be only one of the defined
        // values for this enum, failing on any undefined value.
        DefinedOnly *bool `protobuf:"varint,2,opt,name=defined_only,json=definedOnly" json:"defined_only,omitempty"`
        // In specifies that this field must be equal to one of the specified
        // values
        In []int32 `protobuf:"varint,3,rep,name=in" json:"in,omitempty"`
        // NotIn specifies that this field cannot be equal to one of the specified
        // values
        NotIn []int32 `protobuf:"varint,4,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
}

func (x *EnumRules) Reset() <span class="cov0" title="0">{
        *x = EnumRules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[16]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *EnumRules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*EnumRules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *EnumRules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[16]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use EnumRules.ProtoReflect.Descriptor instead.
func (*EnumRules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{16}
}</span>

func (x *EnumRules) GetConst() int32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Const != nil </span><span class="cov0" title="0">{
                return *x.Const
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *EnumRules) GetDefinedOnly() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.DefinedOnly != nil </span><span class="cov0" title="0">{
                return *x.DefinedOnly
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *EnumRules) GetIn() []int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *EnumRules) GetNotIn() []int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotIn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// MessageRules describe the constraints applied to embedded message values.
// For message-type fields, validation is performed recursively.
type MessageRules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Skip specifies that the validation rules of this field should not be
        // evaluated
        Skip *bool `protobuf:"varint,1,opt,name=skip" json:"skip,omitempty"`
        // Required specifies that this field must be set
        Required *bool `protobuf:"varint,2,opt,name=required" json:"required,omitempty"`
}

func (x *MessageRules) Reset() <span class="cov0" title="0">{
        *x = MessageRules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[17]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *MessageRules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*MessageRules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *MessageRules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[17]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use MessageRules.ProtoReflect.Descriptor instead.
func (*MessageRules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{17}
}</span>

func (x *MessageRules) GetSkip() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Skip != nil </span><span class="cov0" title="0">{
                return *x.Skip
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *MessageRules) GetRequired() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Required != nil </span><span class="cov0" title="0">{
                return *x.Required
        }</span>
        <span class="cov0" title="0">return false</span>
}

// RepeatedRules describe the constraints applied to `repeated` values
type RepeatedRules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // MinItems specifies that this field must have the specified number of
        // items at a minimum
        MinItems *uint64 `protobuf:"varint,1,opt,name=min_items,json=minItems" json:"min_items,omitempty"`
        // MaxItems specifies that this field must have the specified number of
        // items at a maximum
        MaxItems *uint64 `protobuf:"varint,2,opt,name=max_items,json=maxItems" json:"max_items,omitempty"`
        // Unique specifies that all elements in this field must be unique. This
        // constraint is only applicable to scalar and enum types (messages are not
        // supported).
        Unique *bool `protobuf:"varint,3,opt,name=unique" json:"unique,omitempty"`
        // Items specifies the constraints to be applied to each item in the field.
        // Repeated message fields will still execute validation against each item
        // unless skip is specified here.
        Items *FieldRules `protobuf:"bytes,4,opt,name=items" json:"items,omitempty"`
        // IgnoreEmpty specifies that the validation rules of this field should be
        // evaluated only if the field is not empty
        IgnoreEmpty *bool `protobuf:"varint,5,opt,name=ignore_empty,json=ignoreEmpty" json:"ignore_empty,omitempty"`
}

func (x *RepeatedRules) Reset() <span class="cov0" title="0">{
        *x = RepeatedRules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[18]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *RepeatedRules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RepeatedRules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RepeatedRules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[18]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RepeatedRules.ProtoReflect.Descriptor instead.
func (*RepeatedRules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{18}
}</span>

func (x *RepeatedRules) GetMinItems() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.MinItems != nil </span><span class="cov0" title="0">{
                return *x.MinItems
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *RepeatedRules) GetMaxItems() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.MaxItems != nil </span><span class="cov0" title="0">{
                return *x.MaxItems
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *RepeatedRules) GetUnique() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Unique != nil </span><span class="cov0" title="0">{
                return *x.Unique
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *RepeatedRules) GetItems() *FieldRules <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RepeatedRules) GetIgnoreEmpty() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.IgnoreEmpty != nil </span><span class="cov0" title="0">{
                return *x.IgnoreEmpty
        }</span>
        <span class="cov0" title="0">return false</span>
}

// MapRules describe the constraints applied to `map` values
type MapRules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // MinPairs specifies that this field must have the specified number of
        // KVs at a minimum
        MinPairs *uint64 `protobuf:"varint,1,opt,name=min_pairs,json=minPairs" json:"min_pairs,omitempty"`
        // MaxPairs specifies that this field must have the specified number of
        // KVs at a maximum
        MaxPairs *uint64 `protobuf:"varint,2,opt,name=max_pairs,json=maxPairs" json:"max_pairs,omitempty"`
        // NoSparse specifies values in this field cannot be unset. This only
        // applies to map's with message value types.
        NoSparse *bool `protobuf:"varint,3,opt,name=no_sparse,json=noSparse" json:"no_sparse,omitempty"`
        // Keys specifies the constraints to be applied to each key in the field.
        Keys *FieldRules `protobuf:"bytes,4,opt,name=keys" json:"keys,omitempty"`
        // Values specifies the constraints to be applied to the value of each key
        // in the field. Message values will still have their validations evaluated
        // unless skip is specified here.
        Values *FieldRules `protobuf:"bytes,5,opt,name=values" json:"values,omitempty"`
        // IgnoreEmpty specifies that the validation rules of this field should be
        // evaluated only if the field is not empty
        IgnoreEmpty *bool `protobuf:"varint,6,opt,name=ignore_empty,json=ignoreEmpty" json:"ignore_empty,omitempty"`
}

func (x *MapRules) Reset() <span class="cov0" title="0">{
        *x = MapRules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[19]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *MapRules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*MapRules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *MapRules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[19]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use MapRules.ProtoReflect.Descriptor instead.
func (*MapRules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{19}
}</span>

func (x *MapRules) GetMinPairs() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.MinPairs != nil </span><span class="cov0" title="0">{
                return *x.MinPairs
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *MapRules) GetMaxPairs() uint64 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.MaxPairs != nil </span><span class="cov0" title="0">{
                return *x.MaxPairs
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *MapRules) GetNoSparse() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.NoSparse != nil </span><span class="cov0" title="0">{
                return *x.NoSparse
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *MapRules) GetKeys() *FieldRules <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Keys
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *MapRules) GetValues() *FieldRules <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Values
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *MapRules) GetIgnoreEmpty() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.IgnoreEmpty != nil </span><span class="cov0" title="0">{
                return *x.IgnoreEmpty
        }</span>
        <span class="cov0" title="0">return false</span>
}

// AnyRules describe constraints applied exclusively to the
// `google.protobuf.Any` well-known type
type AnyRules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Required specifies that this field must be set
        Required *bool `protobuf:"varint,1,opt,name=required" json:"required,omitempty"`
        // In specifies that this field's `type_url` must be equal to one of the
        // specified values.
        In []string `protobuf:"bytes,2,rep,name=in" json:"in,omitempty"`
        // NotIn specifies that this field's `type_url` must not be equal to any of
        // the specified values.
        NotIn []string `protobuf:"bytes,3,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
}

func (x *AnyRules) Reset() <span class="cov0" title="0">{
        *x = AnyRules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[20]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *AnyRules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AnyRules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AnyRules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[20]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AnyRules.ProtoReflect.Descriptor instead.
func (*AnyRules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{20}
}</span>

func (x *AnyRules) GetRequired() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Required != nil </span><span class="cov0" title="0">{
                return *x.Required
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *AnyRules) GetIn() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *AnyRules) GetNotIn() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotIn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DurationRules describe the constraints applied exclusively to the
// `google.protobuf.Duration` well-known type
type DurationRules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Required specifies that this field must be set
        Required *bool `protobuf:"varint,1,opt,name=required" json:"required,omitempty"`
        // Const specifies that this field must be exactly the specified value
        Const *durationpb.Duration `protobuf:"bytes,2,opt,name=const" json:"const,omitempty"`
        // Lt specifies that this field must be less than the specified value,
        // exclusive
        Lt *durationpb.Duration `protobuf:"bytes,3,opt,name=lt" json:"lt,omitempty"`
        // Lt specifies that this field must be less than the specified value,
        // inclusive
        Lte *durationpb.Duration `protobuf:"bytes,4,opt,name=lte" json:"lte,omitempty"`
        // Gt specifies that this field must be greater than the specified value,
        // exclusive
        Gt *durationpb.Duration `protobuf:"bytes,5,opt,name=gt" json:"gt,omitempty"`
        // Gte specifies that this field must be greater than the specified value,
        // inclusive
        Gte *durationpb.Duration `protobuf:"bytes,6,opt,name=gte" json:"gte,omitempty"`
        // In specifies that this field must be equal to one of the specified
        // values
        In []*durationpb.Duration `protobuf:"bytes,7,rep,name=in" json:"in,omitempty"`
        // NotIn specifies that this field cannot be equal to one of the specified
        // values
        NotIn []*durationpb.Duration `protobuf:"bytes,8,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
}

func (x *DurationRules) Reset() <span class="cov0" title="0">{
        *x = DurationRules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[21]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DurationRules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DurationRules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DurationRules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[21]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DurationRules.ProtoReflect.Descriptor instead.
func (*DurationRules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{21}
}</span>

func (x *DurationRules) GetRequired() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Required != nil </span><span class="cov0" title="0">{
                return *x.Required
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *DurationRules) GetConst() *durationpb.Duration <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Const
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DurationRules) GetLt() *durationpb.Duration <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Lt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DurationRules) GetLte() *durationpb.Duration <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Lte
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DurationRules) GetGt() *durationpb.Duration <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Gt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DurationRules) GetGte() *durationpb.Duration <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Gte
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DurationRules) GetIn() []*durationpb.Duration <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DurationRules) GetNotIn() []*durationpb.Duration <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotIn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// TimestampRules describe the constraints applied exclusively to the
// `google.protobuf.Timestamp` well-known type
type TimestampRules struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Required specifies that this field must be set
        Required *bool `protobuf:"varint,1,opt,name=required" json:"required,omitempty"`
        // Const specifies that this field must be exactly the specified value
        Const *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=const" json:"const,omitempty"`
        // Lt specifies that this field must be less than the specified value,
        // exclusive
        Lt *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=lt" json:"lt,omitempty"`
        // Lte specifies that this field must be less than the specified value,
        // inclusive
        Lte *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=lte" json:"lte,omitempty"`
        // Gt specifies that this field must be greater than the specified value,
        // exclusive
        Gt *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=gt" json:"gt,omitempty"`
        // Gte specifies that this field must be greater than the specified value,
        // inclusive
        Gte *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=gte" json:"gte,omitempty"`
        // LtNow specifies that this must be less than the current time. LtNow
        // can only be used with the Within rule.
        LtNow *bool `protobuf:"varint,7,opt,name=lt_now,json=ltNow" json:"lt_now,omitempty"`
        // GtNow specifies that this must be greater than the current time. GtNow
        // can only be used with the Within rule.
        GtNow *bool `protobuf:"varint,8,opt,name=gt_now,json=gtNow" json:"gt_now,omitempty"`
        // Within specifies that this field must be within this duration of the
        // current time. This constraint can be used alone or with the LtNow and
        // GtNow rules.
        Within *durationpb.Duration `protobuf:"bytes,9,opt,name=within" json:"within,omitempty"`
}

func (x *TimestampRules) Reset() <span class="cov0" title="0">{
        *x = TimestampRules{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_validate_validate_proto_msgTypes[22]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *TimestampRules) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TimestampRules) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TimestampRules) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_validate_validate_proto_msgTypes[22]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TimestampRules.ProtoReflect.Descriptor instead.
func (*TimestampRules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_validate_validate_proto_rawDescGZIP(), []int{22}
}</span>

func (x *TimestampRules) GetRequired() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Required != nil </span><span class="cov0" title="0">{
                return *x.Required
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *TimestampRules) GetConst() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Const
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TimestampRules) GetLt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Lt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TimestampRules) GetLte() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Lte
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TimestampRules) GetGt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Gt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TimestampRules) GetGte() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Gte
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TimestampRules) GetLtNow() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.LtNow != nil </span><span class="cov0" title="0">{
                return *x.LtNow
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *TimestampRules) GetGtNow() bool <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.GtNow != nil </span><span class="cov0" title="0">{
                return *x.GtNow
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *TimestampRules) GetWithin() *durationpb.Duration <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Within
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var file_validate_validate_proto_extTypes = []protoimpl.ExtensionInfo{
        {
                ExtendedType:  (*descriptorpb.MessageOptions)(nil),
                ExtensionType: (*bool)(nil),
                Field:         1071,
                Name:          "validate.disabled",
                Tag:           "varint,1071,opt,name=disabled",
                Filename:      "validate/validate.proto",
        },
        {
                ExtendedType:  (*descriptorpb.MessageOptions)(nil),
                ExtensionType: (*bool)(nil),
                Field:         1072,
                Name:          "validate.ignored",
                Tag:           "varint,1072,opt,name=ignored",
                Filename:      "validate/validate.proto",
        },
        {
                ExtendedType:  (*descriptorpb.OneofOptions)(nil),
                ExtensionType: (*bool)(nil),
                Field:         1071,
                Name:          "validate.required",
                Tag:           "varint,1071,opt,name=required",
                Filename:      "validate/validate.proto",
        },
        {
                ExtendedType:  (*descriptorpb.FieldOptions)(nil),
                ExtensionType: (*FieldRules)(nil),
                Field:         1071,
                Name:          "validate.rules",
                Tag:           "bytes,1071,opt,name=rules",
                Filename:      "validate/validate.proto",
        },
}

// Extension fields to descriptorpb.MessageOptions.
var (
        // Disabled nullifies any validation rules for this message, including any
        // message fields associated with it that do support validation.
        //
        // optional bool disabled = 1071;
        E_Disabled = &amp;file_validate_validate_proto_extTypes[0]
        // Ignore skips generation of validation methods for this message.
        //
        // optional bool ignored = 1072;
        E_Ignored = &amp;file_validate_validate_proto_extTypes[1]
)

// Extension fields to descriptorpb.OneofOptions.
var (
        // Required ensures that exactly one the field options in a oneof is set;
        // validation fails if no fields in the oneof are set.
        //
        // optional bool required = 1071;
        E_Required = &amp;file_validate_validate_proto_extTypes[2]
)

// Extension fields to descriptorpb.FieldOptions.
var (
        // Rules specify the validations to be performed on this field. By default,
        // no validation is performed against a field.
        //
        // optional validate.FieldRules rules = 1071;
        E_Rules = &amp;file_validate_validate_proto_extTypes[3]
)

var File_validate_validate_proto protoreflect.FileDescriptor

var file_validate_validate_proto_rawDesc = []byte{
        0x0a, 0x17, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x2f, 0x76, 0x61, 0x6c, 0x69, 0x64,
        0x61, 0x74, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x08, 0x76, 0x61, 0x6c, 0x69, 0x64,
        0x61, 0x74, 0x65, 0x1a, 0x20, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x62, 0x75, 0x66, 0x2f, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x6f, 0x72, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xc8, 0x08, 0x0a, 0x0a, 0x46, 0x69, 0x65, 0x6c, 0x64,
        0x52, 0x75, 0x6c, 0x65, 0x73, 0x12, 0x30, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65,
        0x18, 0x11, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74,
        0x65, 0x2e, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x52, 0x07,
        0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x2c, 0x0a, 0x05, 0x66, 0x6c, 0x6f, 0x61, 0x74,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74,
        0x65, 0x2e, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x48, 0x00, 0x52, 0x05,
        0x66, 0x6c, 0x6f, 0x61, 0x74, 0x12, 0x2f, 0x0a, 0x06, 0x64, 0x6f, 0x75, 0x62, 0x6c, 0x65, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65,
        0x2e, 0x44, 0x6f, 0x75, 0x62, 0x6c, 0x65, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x48, 0x00, 0x52, 0x06,
        0x64, 0x6f, 0x75, 0x62, 0x6c, 0x65, 0x12, 0x2c, 0x0a, 0x05, 0x69, 0x6e, 0x74, 0x33, 0x32, 0x18,
        0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65,
        0x2e, 0x49, 0x6e, 0x74, 0x33, 0x32, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x48, 0x00, 0x52, 0x05, 0x69,
        0x6e, 0x74, 0x33, 0x32, 0x12, 0x2c, 0x0a, 0x05, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x18, 0x04, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x49,
        0x6e, 0x74, 0x36, 0x34, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x48, 0x00, 0x52, 0x05, 0x69, 0x6e, 0x74,
        0x36, 0x34, 0x12, 0x2f, 0x0a, 0x06, 0x75, 0x69, 0x6e, 0x74, 0x33, 0x32, 0x18, 0x05, 0x20, 0x01,
        0x28, 0x0b, 0x32, 0x15, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x55, 0x49,
        0x6e, 0x74, 0x33, 0x32, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x48, 0x00, 0x52, 0x06, 0x75, 0x69, 0x6e,
        0x74, 0x33, 0x32, 0x12, 0x2f, 0x0a, 0x06, 0x75, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x18, 0x06, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x55,
        0x49, 0x6e, 0x74, 0x36, 0x34, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x48, 0x00, 0x52, 0x06, 0x75, 0x69,
        0x6e, 0x74, 0x36, 0x34, 0x12, 0x2f, 0x0a, 0x06, 0x73, 0x69, 0x6e, 0x74, 0x33, 0x32, 0x18, 0x07,
        0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x2e,
        0x53, 0x49, 0x6e, 0x74, 0x33, 0x32, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x48, 0x00, 0x52, 0x06, 0x73,
        0x69, 0x6e, 0x74, 0x33, 0x32, 0x12, 0x2f, 0x0a, 0x06, 0x73, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x18,
        0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65,
        0x2e, 0x53, 0x49, 0x6e, 0x74, 0x36, 0x34, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x48, 0x00, 0x52, 0x06,
        0x73, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x12, 0x32, 0x0a, 0x07, 0x66, 0x69, 0x78, 0x65, 0x64, 0x33,
        0x32, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61,
        0x74, 0x65, 0x2e, 0x46, 0x69, 0x78, 0x65, 0x64, 0x33, 0x32, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x48,
        0x00, 0x52, 0x07, 0x66, 0x69, 0x78, 0x65, 0x64, 0x33, 0x32, 0x12, 0x32, 0x0a, 0x07, 0x66, 0x69,
        0x78, 0x65, 0x64, 0x36, 0x34, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x76, 0x61,
        0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x46, 0x69, 0x78, 0x65, 0x64, 0x36, 0x34, 0x52, 0x75,
        0x6c, 0x65, 0x73, 0x48, 0x00, 0x52, 0x07, 0x66, 0x69, 0x78, 0x65, 0x64, 0x36, 0x34, 0x12, 0x35,
        0x0a, 0x08, 0x73, 0x66, 0x69, 0x78, 0x65, 0x64, 0x33, 0x32, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x17, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x53, 0x46, 0x69, 0x78,
        0x65, 0x64, 0x33, 0x32, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x48, 0x00, 0x52, 0x08, 0x73, 0x66, 0x69,
        0x78, 0x65, 0x64, 0x33, 0x32, 0x12, 0x35, 0x0a, 0x08, 0x73, 0x66, 0x69, 0x78, 0x65, 0x64, 0x36,
        0x34, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61,
        0x74, 0x65, 0x2e, 0x53, 0x46, 0x69, 0x78, 0x65, 0x64, 0x36, 0x34, 0x52, 0x75, 0x6c, 0x65, 0x73,
        0x48, 0x00, 0x52, 0x08, 0x73, 0x66, 0x69, 0x78, 0x65, 0x64, 0x36, 0x34, 0x12, 0x29, 0x0a, 0x04,
        0x62, 0x6f, 0x6f, 0x6c, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x76, 0x61, 0x6c,
        0x69, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x42, 0x6f, 0x6f, 0x6c, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x48,
        0x00, 0x52, 0x04, 0x62, 0x6f, 0x6f, 0x6c, 0x12, 0x2f, 0x0a, 0x06, 0x73, 0x74, 0x72, 0x69, 0x6e,
        0x67, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61,
        0x74, 0x65, 0x2e, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x48, 0x00,
        0x52, 0x06, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x12, 0x2c, 0x0a, 0x05, 0x62, 0x79, 0x74, 0x65,
        0x73, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61,
        0x74, 0x65, 0x2e, 0x42, 0x79, 0x74, 0x65, 0x73, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x48, 0x00, 0x52,
        0x05, 0x62, 0x79, 0x74, 0x65, 0x73, 0x12, 0x29, 0x0a, 0x04, 0x65, 0x6e, 0x75, 0x6d, 0x18, 0x10,
        0x20, 0x01, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x2e,
        0x45, 0x6e, 0x75, 0x6d, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x48, 0x00, 0x52, 0x04, 0x65, 0x6e, 0x75,
        0x6d, 0x12, 0x35, 0x0a, 0x08, 0x72, 0x65, 0x70, 0x65, 0x61, 0x74, 0x65, 0x64, 0x18, 0x12, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x52,
        0x65, 0x70, 0x65, 0x61, 0x74, 0x65, 0x64, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x48, 0x00, 0x52, 0x08,
        0x72, 0x65, 0x70, 0x65, 0x61, 0x74, 0x65, 0x64, 0x12, 0x26, 0x0a, 0x03, 0x6d, 0x61, 0x70, 0x18,
        0x13, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65,
        0x2e, 0x4d, 0x61, 0x70, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x48, 0x00, 0x52, 0x03, 0x6d, 0x61, 0x70,
        0x12, 0x26, 0x0a, 0x03, 0x61, 0x6e, 0x79, 0x18, 0x14, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e,
        0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x41, 0x6e, 0x79, 0x52, 0x75, 0x6c, 0x65,
        0x73, 0x48, 0x00, 0x52, 0x03, 0x61, 0x6e, 0x79, 0x12, 0x35, 0x0a, 0x08, 0x64, 0x75, 0x72, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x18, 0x15, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x76, 0x61, 0x6c,
        0x69, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x75,
        0x6c, 0x65, 0x73, 0x48, 0x00, 0x52, 0x08, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12,
        0x38, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x16, 0x20, 0x01,
        0x28, 0x0b, 0x32, 0x18, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x54, 0x69,
        0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x48, 0x00, 0x52, 0x09,
        0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x42, 0x06, 0x0a, 0x04, 0x74, 0x79, 0x70,
        0x65, 0x22, 0xb0, 0x01, 0x0a, 0x0a, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x52, 0x75, 0x6c, 0x65, 0x73,
        0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x02, 0x52,
        0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x6c, 0x74, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x02, 0x52, 0x02, 0x6c, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x6c, 0x74, 0x65, 0x18, 0x03, 0x20,
        0x01, 0x28, 0x02, 0x52, 0x03, 0x6c, 0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x67, 0x74, 0x18, 0x04,
        0x20, 0x01, 0x28, 0x02, 0x52, 0x02, 0x67, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x67, 0x74, 0x65, 0x18,
        0x05, 0x20, 0x01, 0x28, 0x02, 0x52, 0x03, 0x67, 0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x6e,
        0x18, 0x06, 0x20, 0x03, 0x28, 0x02, 0x52, 0x02, 0x69, 0x6e, 0x12, 0x15, 0x0a, 0x06, 0x6e, 0x6f,
        0x74, 0x5f, 0x69, 0x6e, 0x18, 0x07, 0x20, 0x03, 0x28, 0x02, 0x52, 0x05, 0x6e, 0x6f, 0x74, 0x49,
        0x6e, 0x12, 0x21, 0x0a, 0x0c, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x5f, 0x65, 0x6d, 0x70, 0x74,
        0x79, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x45,
        0x6d, 0x70, 0x74, 0x79, 0x22, 0xb1, 0x01, 0x0a, 0x0b, 0x44, 0x6f, 0x75, 0x62, 0x6c, 0x65, 0x52,
        0x75, 0x6c, 0x65, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x01, 0x52, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x6c, 0x74,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x01, 0x52, 0x02, 0x6c, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x6c, 0x74,
        0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x01, 0x52, 0x03, 0x6c, 0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02,
        0x67, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x01, 0x52, 0x02, 0x67, 0x74, 0x12, 0x10, 0x0a, 0x03,
        0x67, 0x74, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x01, 0x52, 0x03, 0x67, 0x74, 0x65, 0x12, 0x0e,
        0x0a, 0x02, 0x69, 0x6e, 0x18, 0x06, 0x20, 0x03, 0x28, 0x01, 0x52, 0x02, 0x69, 0x6e, 0x12, 0x15,
        0x0a, 0x06, 0x6e, 0x6f, 0x74, 0x5f, 0x69, 0x6e, 0x18, 0x07, 0x20, 0x03, 0x28, 0x01, 0x52, 0x05,
        0x6e, 0x6f, 0x74, 0x49, 0x6e, 0x12, 0x21, 0x0a, 0x0c, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x5f,
        0x65, 0x6d, 0x70, 0x74, 0x79, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x69, 0x67, 0x6e,
        0x6f, 0x72, 0x65, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0xb0, 0x01, 0x0a, 0x0a, 0x49, 0x6e, 0x74,
        0x33, 0x32, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x12, 0x0e, 0x0a,
        0x02, 0x6c, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x02, 0x6c, 0x74, 0x12, 0x10, 0x0a,
        0x03, 0x6c, 0x74, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x03, 0x6c, 0x74, 0x65, 0x12,
        0x0e, 0x0a, 0x02, 0x67, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x52, 0x02, 0x67, 0x74, 0x12,
        0x10, 0x0a, 0x03, 0x67, 0x74, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x05, 0x52, 0x03, 0x67, 0x74,
        0x65, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x6e, 0x18, 0x06, 0x20, 0x03, 0x28, 0x05, 0x52, 0x02, 0x69,
        0x6e, 0x12, 0x15, 0x0a, 0x06, 0x6e, 0x6f, 0x74, 0x5f, 0x69, 0x6e, 0x18, 0x07, 0x20, 0x03, 0x28,
        0x05, 0x52, 0x05, 0x6e, 0x6f, 0x74, 0x49, 0x6e, 0x12, 0x21, 0x0a, 0x0c, 0x69, 0x67, 0x6e, 0x6f,
        0x72, 0x65, 0x5f, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b,
        0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0xb0, 0x01, 0x0a, 0x0a,
        0x49, 0x6e, 0x74, 0x36, 0x34, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f,
        0x6e, 0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74,
        0x12, 0x0e, 0x0a, 0x02, 0x6c, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x02, 0x6c, 0x74,
        0x12, 0x10, 0x0a, 0x03, 0x6c, 0x74, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x03, 0x6c,
        0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x67, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x03, 0x52, 0x02,
        0x67, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x67, 0x74, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x03, 0x52,
        0x03, 0x67, 0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x6e, 0x18, 0x06, 0x20, 0x03, 0x28, 0x03,
        0x52, 0x02, 0x69, 0x6e, 0x12, 0x15, 0x0a, 0x06, 0x6e, 0x6f, 0x74, 0x5f, 0x69, 0x6e, 0x18, 0x07,
        0x20, 0x03, 0x28, 0x03, 0x52, 0x05, 0x6e, 0x6f, 0x74, 0x49, 0x6e, 0x12, 0x21, 0x0a, 0x0c, 0x69,
        0x67, 0x6e, 0x6f, 0x72, 0x65, 0x5f, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x18, 0x08, 0x20, 0x01, 0x28,
        0x08, 0x52, 0x0b, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0xb1,
        0x01, 0x0a, 0x0b, 0x55, 0x49, 0x6e, 0x74, 0x33, 0x32, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x12, 0x14,
        0x0a, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x05, 0x63,
        0x6f, 0x6e, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x6c, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d,
        0x52, 0x02, 0x6c, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x6c, 0x74, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28,
        0x0d, 0x52, 0x03, 0x6c, 0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x67, 0x74, 0x18, 0x04, 0x20, 0x01,
        0x28, 0x0d, 0x52, 0x02, 0x67, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x67, 0x74, 0x65, 0x18, 0x05, 0x20,
        0x01, 0x28, 0x0d, 0x52, 0x03, 0x67, 0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x6e, 0x18, 0x06,
        0x20, 0x03, 0x28, 0x0d, 0x52, 0x02, 0x69, 0x6e, 0x12, 0x15, 0x0a, 0x06, 0x6e, 0x6f, 0x74, 0x5f,
        0x69, 0x6e, 0x18, 0x07, 0x20, 0x03, 0x28, 0x0d, 0x52, 0x05, 0x6e, 0x6f, 0x74, 0x49, 0x6e, 0x12,
        0x21, 0x0a, 0x0c, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x5f, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x18,
        0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x45, 0x6d, 0x70,
        0x74, 0x79, 0x22, 0xb1, 0x01, 0x0a, 0x0b, 0x55, 0x49, 0x6e, 0x74, 0x36, 0x34, 0x52, 0x75, 0x6c,
        0x65, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x04, 0x52, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x6c, 0x74, 0x18, 0x02,
        0x20, 0x01, 0x28, 0x04, 0x52, 0x02, 0x6c, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x6c, 0x74, 0x65, 0x18,
        0x03, 0x20, 0x01, 0x28, 0x04, 0x52, 0x03, 0x6c, 0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x67, 0x74,
        0x18, 0x04, 0x20, 0x01, 0x28, 0x04, 0x52, 0x02, 0x67, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x67, 0x74,
        0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x04, 0x52, 0x03, 0x67, 0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02,
        0x69, 0x6e, 0x18, 0x06, 0x20, 0x03, 0x28, 0x04, 0x52, 0x02, 0x69, 0x6e, 0x12, 0x15, 0x0a, 0x06,
        0x6e, 0x6f, 0x74, 0x5f, 0x69, 0x6e, 0x18, 0x07, 0x20, 0x03, 0x28, 0x04, 0x52, 0x05, 0x6e, 0x6f,
        0x74, 0x49, 0x6e, 0x12, 0x21, 0x0a, 0x0c, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x5f, 0x65, 0x6d,
        0x70, 0x74, 0x79, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x69, 0x67, 0x6e, 0x6f, 0x72,
        0x65, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0xb1, 0x01, 0x0a, 0x0b, 0x53, 0x49, 0x6e, 0x74, 0x33,
        0x32, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x11, 0x52, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02,
        0x6c, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x11, 0x52, 0x02, 0x6c, 0x74, 0x12, 0x10, 0x0a, 0x03,
        0x6c, 0x74, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x11, 0x52, 0x03, 0x6c, 0x74, 0x65, 0x12, 0x0e,
        0x0a, 0x02, 0x67, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x11, 0x52, 0x02, 0x67, 0x74, 0x12, 0x10,
        0x0a, 0x03, 0x67, 0x74, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x11, 0x52, 0x03, 0x67, 0x74, 0x65,
        0x12, 0x0e, 0x0a, 0x02, 0x69, 0x6e, 0x18, 0x06, 0x20, 0x03, 0x28, 0x11, 0x52, 0x02, 0x69, 0x6e,
        0x12, 0x15, 0x0a, 0x06, 0x6e, 0x6f, 0x74, 0x5f, 0x69, 0x6e, 0x18, 0x07, 0x20, 0x03, 0x28, 0x11,
        0x52, 0x05, 0x6e, 0x6f, 0x74, 0x49, 0x6e, 0x12, 0x21, 0x0a, 0x0c, 0x69, 0x67, 0x6e, 0x6f, 0x72,
        0x65, 0x5f, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x69,
        0x67, 0x6e, 0x6f, 0x72, 0x65, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0xb1, 0x01, 0x0a, 0x0b, 0x53,
        0x49, 0x6e, 0x74, 0x36, 0x34, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f,
        0x6e, 0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x12, 0x52, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74,
        0x12, 0x0e, 0x0a, 0x02, 0x6c, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x12, 0x52, 0x02, 0x6c, 0x74,
        0x12, 0x10, 0x0a, 0x03, 0x6c, 0x74, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x12, 0x52, 0x03, 0x6c,
        0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x67, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x12, 0x52, 0x02,
        0x67, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x67, 0x74, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x12, 0x52,
        0x03, 0x67, 0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x6e, 0x18, 0x06, 0x20, 0x03, 0x28, 0x12,
        0x52, 0x02, 0x69, 0x6e, 0x12, 0x15, 0x0a, 0x06, 0x6e, 0x6f, 0x74, 0x5f, 0x69, 0x6e, 0x18, 0x07,
        0x20, 0x03, 0x28, 0x12, 0x52, 0x05, 0x6e, 0x6f, 0x74, 0x49, 0x6e, 0x12, 0x21, 0x0a, 0x0c, 0x69,
        0x67, 0x6e, 0x6f, 0x72, 0x65, 0x5f, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x18, 0x08, 0x20, 0x01, 0x28,
        0x08, 0x52, 0x0b, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0xb2,
        0x01, 0x0a, 0x0c, 0x46, 0x69, 0x78, 0x65, 0x64, 0x33, 0x32, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x12,
        0x14, 0x0a, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x07, 0x52, 0x05,
        0x63, 0x6f, 0x6e, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x6c, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28,
        0x07, 0x52, 0x02, 0x6c, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x6c, 0x74, 0x65, 0x18, 0x03, 0x20, 0x01,
        0x28, 0x07, 0x52, 0x03, 0x6c, 0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x67, 0x74, 0x18, 0x04, 0x20,
        0x01, 0x28, 0x07, 0x52, 0x02, 0x67, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x67, 0x74, 0x65, 0x18, 0x05,
        0x20, 0x01, 0x28, 0x07, 0x52, 0x03, 0x67, 0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x6e, 0x18,
        0x06, 0x20, 0x03, 0x28, 0x07, 0x52, 0x02, 0x69, 0x6e, 0x12, 0x15, 0x0a, 0x06, 0x6e, 0x6f, 0x74,
        0x5f, 0x69, 0x6e, 0x18, 0x07, 0x20, 0x03, 0x28, 0x07, 0x52, 0x05, 0x6e, 0x6f, 0x74, 0x49, 0x6e,
        0x12, 0x21, 0x0a, 0x0c, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x5f, 0x65, 0x6d, 0x70, 0x74, 0x79,
        0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x45, 0x6d,
        0x70, 0x74, 0x79, 0x22, 0xb2, 0x01, 0x0a, 0x0c, 0x46, 0x69, 0x78, 0x65, 0x64, 0x36, 0x34, 0x52,
        0x75, 0x6c, 0x65, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x06, 0x52, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x6c, 0x74,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x06, 0x52, 0x02, 0x6c, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x6c, 0x74,
        0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x06, 0x52, 0x03, 0x6c, 0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02,
        0x67, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x06, 0x52, 0x02, 0x67, 0x74, 0x12, 0x10, 0x0a, 0x03,
        0x67, 0x74, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x06, 0x52, 0x03, 0x67, 0x74, 0x65, 0x12, 0x0e,
        0x0a, 0x02, 0x69, 0x6e, 0x18, 0x06, 0x20, 0x03, 0x28, 0x06, 0x52, 0x02, 0x69, 0x6e, 0x12, 0x15,
        0x0a, 0x06, 0x6e, 0x6f, 0x74, 0x5f, 0x69, 0x6e, 0x18, 0x07, 0x20, 0x03, 0x28, 0x06, 0x52, 0x05,
        0x6e, 0x6f, 0x74, 0x49, 0x6e, 0x12, 0x21, 0x0a, 0x0c, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x5f,
        0x65, 0x6d, 0x70, 0x74, 0x79, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x69, 0x67, 0x6e,
        0x6f, 0x72, 0x65, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0xb3, 0x01, 0x0a, 0x0d, 0x53, 0x46, 0x69,
        0x78, 0x65, 0x64, 0x33, 0x32, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f,
        0x6e, 0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0f, 0x52, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74,
        0x12, 0x0e, 0x0a, 0x02, 0x6c, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0f, 0x52, 0x02, 0x6c, 0x74,
        0x12, 0x10, 0x0a, 0x03, 0x6c, 0x74, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0f, 0x52, 0x03, 0x6c,
        0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x67, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0f, 0x52, 0x02,
        0x67, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x67, 0x74, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0f, 0x52,
        0x03, 0x67, 0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x6e, 0x18, 0x06, 0x20, 0x03, 0x28, 0x0f,
        0x52, 0x02, 0x69, 0x6e, 0x12, 0x15, 0x0a, 0x06, 0x6e, 0x6f, 0x74, 0x5f, 0x69, 0x6e, 0x18, 0x07,
        0x20, 0x03, 0x28, 0x0f, 0x52, 0x05, 0x6e, 0x6f, 0x74, 0x49, 0x6e, 0x12, 0x21, 0x0a, 0x0c, 0x69,
        0x67, 0x6e, 0x6f, 0x72, 0x65, 0x5f, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x18, 0x08, 0x20, 0x01, 0x28,
        0x08, 0x52, 0x0b, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0xb3,
        0x01, 0x0a, 0x0d, 0x53, 0x46, 0x69, 0x78, 0x65, 0x64, 0x36, 0x34, 0x52, 0x75, 0x6c, 0x65, 0x73,
        0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x10, 0x52,
        0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x6c, 0x74, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x10, 0x52, 0x02, 0x6c, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x6c, 0x74, 0x65, 0x18, 0x03, 0x20,
        0x01, 0x28, 0x10, 0x52, 0x03, 0x6c, 0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x67, 0x74, 0x18, 0x04,
        0x20, 0x01, 0x28, 0x10, 0x52, 0x02, 0x67, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x67, 0x74, 0x65, 0x18,
        0x05, 0x20, 0x01, 0x28, 0x10, 0x52, 0x03, 0x67, 0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x6e,
        0x18, 0x06, 0x20, 0x03, 0x28, 0x10, 0x52, 0x02, 0x69, 0x6e, 0x12, 0x15, 0x0a, 0x06, 0x6e, 0x6f,
        0x74, 0x5f, 0x69, 0x6e, 0x18, 0x07, 0x20, 0x03, 0x28, 0x10, 0x52, 0x05, 0x6e, 0x6f, 0x74, 0x49,
        0x6e, 0x12, 0x21, 0x0a, 0x0c, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x5f, 0x65, 0x6d, 0x70, 0x74,
        0x79, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x45,
        0x6d, 0x70, 0x74, 0x79, 0x22, 0x21, 0x0a, 0x09, 0x42, 0x6f, 0x6f, 0x6c, 0x52, 0x75, 0x6c, 0x65,
        0x73, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08,
        0x52, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x22, 0xd4, 0x05, 0x0a, 0x0b, 0x53, 0x74, 0x72, 0x69,
        0x6e, 0x67, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x12, 0x10, 0x0a,
        0x03, 0x6c, 0x65, 0x6e, 0x18, 0x13, 0x20, 0x01, 0x28, 0x04, 0x52, 0x03, 0x6c, 0x65, 0x6e, 0x12,
        0x17, 0x0a, 0x07, 0x6d, 0x69, 0x6e, 0x5f, 0x6c, 0x65, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04,
        0x52, 0x06, 0x6d, 0x69, 0x6e, 0x4c, 0x65, 0x6e, 0x12, 0x17, 0x0a, 0x07, 0x6d, 0x61, 0x78, 0x5f,
        0x6c, 0x65, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x04, 0x52, 0x06, 0x6d, 0x61, 0x78, 0x4c, 0x65,
        0x6e, 0x12, 0x1b, 0x0a, 0x09, 0x6c, 0x65, 0x6e, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x14,
        0x20, 0x01, 0x28, 0x04, 0x52, 0x08, 0x6c, 0x65, 0x6e, 0x42, 0x79, 0x74, 0x65, 0x73, 0x12, 0x1b,
        0x0a, 0x09, 0x6d, 0x69, 0x6e, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28,
        0x04, 0x52, 0x08, 0x6d, 0x69, 0x6e, 0x42, 0x79, 0x74, 0x65, 0x73, 0x12, 0x1b, 0x0a, 0x09, 0x6d,
        0x61, 0x78, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x04, 0x52, 0x08,
        0x6d, 0x61, 0x78, 0x42, 0x79, 0x74, 0x65, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x61, 0x74, 0x74,
        0x65, 0x72, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x70, 0x61, 0x74, 0x74, 0x65,
        0x72, 0x6e, 0x12, 0x16, 0x0a, 0x06, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x18, 0x07, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x06, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x75,
        0x66, 0x66, 0x69, 0x78, 0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73, 0x75, 0x66, 0x66,
        0x69, 0x78, 0x12, 0x1a, 0x0a, 0x08, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x73, 0x18, 0x09,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x73, 0x12, 0x21,
        0x0a, 0x0c, 0x6e, 0x6f, 0x74, 0x5f, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x73, 0x18, 0x17,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x6e, 0x6f, 0x74, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e,
        0x73, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x6e, 0x18, 0x0a, 0x20, 0x03, 0x28, 0x09, 0x52, 0x02, 0x69,
        0x6e, 0x12, 0x15, 0x0a, 0x06, 0x6e, 0x6f, 0x74, 0x5f, 0x69, 0x6e, 0x18, 0x0b, 0x20, 0x03, 0x28,
        0x09, 0x52, 0x05, 0x6e, 0x6f, 0x74, 0x49, 0x6e, 0x12, 0x16, 0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69,
        0x6c, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x08, 0x48, 0x00, 0x52, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c,
        0x12, 0x1c, 0x0a, 0x08, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x0d, 0x20, 0x01,
        0x28, 0x08, 0x48, 0x00, 0x52, 0x08, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x10,
        0x0a, 0x02, 0x69, 0x70, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x08, 0x48, 0x00, 0x52, 0x02, 0x69, 0x70,
        0x12, 0x14, 0x0a, 0x04, 0x69, 0x70, 0x76, 0x34, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x08, 0x48, 0x00,
        0x52, 0x04, 0x69, 0x70, 0x76, 0x34, 0x12, 0x14, 0x0a, 0x04, 0x69, 0x70, 0x76, 0x36, 0x18, 0x10,
        0x20, 0x01, 0x28, 0x08, 0x48, 0x00, 0x52, 0x04, 0x69, 0x70, 0x76, 0x36, 0x12, 0x12, 0x0a, 0x03,
        0x75, 0x72, 0x69, 0x18, 0x11, 0x20, 0x01, 0x28, 0x08, 0x48, 0x00, 0x52, 0x03, 0x75, 0x72, 0x69,
        0x12, 0x19, 0x0a, 0x07, 0x75, 0x72, 0x69, 0x5f, 0x72, 0x65, 0x66, 0x18, 0x12, 0x20, 0x01, 0x28,
        0x08, 0x48, 0x00, 0x52, 0x06, 0x75, 0x72, 0x69, 0x52, 0x65, 0x66, 0x12, 0x1a, 0x0a, 0x07, 0x61,
        0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x15, 0x20, 0x01, 0x28, 0x08, 0x48, 0x00, 0x52, 0x07,
        0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x14, 0x0a, 0x04, 0x75, 0x75, 0x69, 0x64, 0x18,
        0x16, 0x20, 0x01, 0x28, 0x08, 0x48, 0x00, 0x52, 0x04, 0x75, 0x75, 0x69, 0x64, 0x12, 0x40, 0x0a,
        0x10, 0x77, 0x65, 0x6c, 0x6c, 0x5f, 0x6b, 0x6e, 0x6f, 0x77, 0x6e, 0x5f, 0x72, 0x65, 0x67, 0x65,
        0x78, 0x18, 0x18, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x14, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61,
        0x74, 0x65, 0x2e, 0x4b, 0x6e, 0x6f, 0x77, 0x6e, 0x52, 0x65, 0x67, 0x65, 0x78, 0x48, 0x00, 0x52,
        0x0e, 0x77, 0x65, 0x6c, 0x6c, 0x4b, 0x6e, 0x6f, 0x77, 0x6e, 0x52, 0x65, 0x67, 0x65, 0x78, 0x12,
        0x1c, 0x0a, 0x06, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x18, 0x19, 0x20, 0x01, 0x28, 0x08, 0x3a,
        0x04, 0x74, 0x72, 0x75, 0x65, 0x52, 0x06, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x12, 0x21, 0x0a,
        0x0c, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x5f, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x18, 0x1a, 0x20,
        0x01, 0x28, 0x08, 0x52, 0x0b, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x45, 0x6d, 0x70, 0x74, 0x79,
        0x42, 0x0c, 0x0a, 0x0a, 0x77, 0x65, 0x6c, 0x6c, 0x5f, 0x6b, 0x6e, 0x6f, 0x77, 0x6e, 0x22, 0xe2,
        0x02, 0x0a, 0x0a, 0x42, 0x79, 0x74, 0x65, 0x73, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x12, 0x14, 0x0a,
        0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x05, 0x63, 0x6f,
        0x6e, 0x73, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x6c, 0x65, 0x6e, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x04,
        0x52, 0x03, 0x6c, 0x65, 0x6e, 0x12, 0x17, 0x0a, 0x07, 0x6d, 0x69, 0x6e, 0x5f, 0x6c, 0x65, 0x6e,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x52, 0x06, 0x6d, 0x69, 0x6e, 0x4c, 0x65, 0x6e, 0x12, 0x17,
        0x0a, 0x07, 0x6d, 0x61, 0x78, 0x5f, 0x6c, 0x65, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x04, 0x52,
        0x06, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x61, 0x74, 0x74, 0x65,
        0x72, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72,
        0x6e, 0x12, 0x16, 0x0a, 0x06, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x18, 0x05, 0x20, 0x01, 0x28,
        0x0c, 0x52, 0x06, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x75, 0x66,
        0x66, 0x69, 0x78, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x06, 0x73, 0x75, 0x66, 0x66, 0x69,
        0x78, 0x12, 0x1a, 0x0a, 0x08, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x73, 0x18, 0x07, 0x20,
        0x01, 0x28, 0x0c, 0x52, 0x08, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x73, 0x12, 0x0e, 0x0a,
        0x02, 0x69, 0x6e, 0x18, 0x08, 0x20, 0x03, 0x28, 0x0c, 0x52, 0x02, 0x69, 0x6e, 0x12, 0x15, 0x0a,
        0x06, 0x6e, 0x6f, 0x74, 0x5f, 0x69, 0x6e, 0x18, 0x09, 0x20, 0x03, 0x28, 0x0c, 0x52, 0x05, 0x6e,
        0x6f, 0x74, 0x49, 0x6e, 0x12, 0x10, 0x0a, 0x02, 0x69, 0x70, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x08,
        0x48, 0x00, 0x52, 0x02, 0x69, 0x70, 0x12, 0x14, 0x0a, 0x04, 0x69, 0x70, 0x76, 0x34, 0x18, 0x0b,
        0x20, 0x01, 0x28, 0x08, 0x48, 0x00, 0x52, 0x04, 0x69, 0x70, 0x76, 0x34, 0x12, 0x14, 0x0a, 0x04,
        0x69, 0x70, 0x76, 0x36, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x08, 0x48, 0x00, 0x52, 0x04, 0x69, 0x70,
        0x76, 0x36, 0x12, 0x21, 0x0a, 0x0c, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x5f, 0x65, 0x6d, 0x70,
        0x74, 0x79, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65,
        0x45, 0x6d, 0x70, 0x74, 0x79, 0x42, 0x0c, 0x0a, 0x0a, 0x77, 0x65, 0x6c, 0x6c, 0x5f, 0x6b, 0x6e,
        0x6f, 0x77, 0x6e, 0x22, 0x6b, 0x0a, 0x09, 0x45, 0x6e, 0x75, 0x6d, 0x52, 0x75, 0x6c, 0x65, 0x73,
        0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52,
        0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x12, 0x21, 0x0a, 0x0c, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x65,
        0x64, 0x5f, 0x6f, 0x6e, 0x6c, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x64, 0x65,
        0x66, 0x69, 0x6e, 0x65, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x6e, 0x18,
        0x03, 0x20, 0x03, 0x28, 0x05, 0x52, 0x02, 0x69, 0x6e, 0x12, 0x15, 0x0a, 0x06, 0x6e, 0x6f, 0x74,
        0x5f, 0x69, 0x6e, 0x18, 0x04, 0x20, 0x03, 0x28, 0x05, 0x52, 0x05, 0x6e, 0x6f, 0x74, 0x49, 0x6e,
        0x22, 0x3e, 0x0a, 0x0c, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x52, 0x75, 0x6c, 0x65, 0x73,
        0x12, 0x12, 0x0a, 0x04, 0x73, 0x6b, 0x69, 0x70, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x04,
        0x73, 0x6b, 0x69, 0x70, 0x12, 0x1a, 0x0a, 0x08, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64,
        0x22, 0xb0, 0x01, 0x0a, 0x0d, 0x52, 0x65, 0x70, 0x65, 0x61, 0x74, 0x65, 0x64, 0x52, 0x75, 0x6c,
        0x65, 0x73, 0x12, 0x1b, 0x0a, 0x09, 0x6d, 0x69, 0x6e, 0x5f, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x08, 0x6d, 0x69, 0x6e, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x12,
        0x1b, 0x0a, 0x09, 0x6d, 0x61, 0x78, 0x5f, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x04, 0x52, 0x08, 0x6d, 0x61, 0x78, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x12, 0x16, 0x0a, 0x06,
        0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x75, 0x6e,
        0x69, 0x71, 0x75, 0x65, 0x12, 0x2a, 0x0a, 0x05, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x18, 0x04, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x46,
        0x69, 0x65, 0x6c, 0x64, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x52, 0x05, 0x69, 0x74, 0x65, 0x6d, 0x73,
        0x12, 0x21, 0x0a, 0x0c, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x5f, 0x65, 0x6d, 0x70, 0x74, 0x79,
        0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x45, 0x6d,
        0x70, 0x74, 0x79, 0x22, 0xdc, 0x01, 0x0a, 0x08, 0x4d, 0x61, 0x70, 0x52, 0x75, 0x6c, 0x65, 0x73,
        0x12, 0x1b, 0x0a, 0x09, 0x6d, 0x69, 0x6e, 0x5f, 0x70, 0x61, 0x69, 0x72, 0x73, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x04, 0x52, 0x08, 0x6d, 0x69, 0x6e, 0x50, 0x61, 0x69, 0x72, 0x73, 0x12, 0x1b, 0x0a,
        0x09, 0x6d, 0x61, 0x78, 0x5f, 0x70, 0x61, 0x69, 0x72, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04,
        0x52, 0x08, 0x6d, 0x61, 0x78, 0x50, 0x61, 0x69, 0x72, 0x73, 0x12, 0x1b, 0x0a, 0x09, 0x6e, 0x6f,
        0x5f, 0x73, 0x70, 0x61, 0x72, 0x73, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x6e,
        0x6f, 0x53, 0x70, 0x61, 0x72, 0x73, 0x65, 0x12, 0x28, 0x0a, 0x04, 0x6b, 0x65, 0x79, 0x73, 0x18,
        0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65,
        0x2e, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x52, 0x04, 0x6b, 0x65, 0x79,
        0x73, 0x12, 0x2c, 0x0a, 0x06, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x14, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x46, 0x69, 0x65,
        0x6c, 0x64, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x52, 0x06, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x12,
        0x21, 0x0a, 0x0c, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x5f, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x18,
        0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x45, 0x6d, 0x70,
        0x74, 0x79, 0x22, 0x4d, 0x0a, 0x08, 0x41, 0x6e, 0x79, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x12, 0x1a,
        0x0a, 0x08, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08,
        0x52, 0x08, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x6e,
        0x18, 0x02, 0x20, 0x03, 0x28, 0x09, 0x52, 0x02, 0x69, 0x6e, 0x12, 0x15, 0x0a, 0x06, 0x6e, 0x6f,
        0x74, 0x5f, 0x69, 0x6e, 0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x52, 0x05, 0x6e, 0x6f, 0x74, 0x49,
        0x6e, 0x22, 0xe9, 0x02, 0x0a, 0x0d, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x75,
        0x6c, 0x65, 0x73, 0x12, 0x1a, 0x0a, 0x08, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x12,
        0x2f, 0x0a, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19,
        0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
        0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74,
        0x12, 0x29, 0x0a, 0x02, 0x6c, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67,
        0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44,
        0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x02, 0x6c, 0x74, 0x12, 0x2b, 0x0a, 0x03, 0x6c,
        0x74, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
        0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74,
        0x69, 0x6f, 0x6e, 0x52, 0x03, 0x6c, 0x74, 0x65, 0x12, 0x29, 0x0a, 0x02, 0x67, 0x74, 0x18, 0x05,
        0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52,
        0x02, 0x67, 0x74, 0x12, 0x2b, 0x0a, 0x03, 0x67, 0x74, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62,
        0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x03, 0x67, 0x74, 0x65,
        0x12, 0x29, 0x0a, 0x02, 0x69, 0x6e, 0x18, 0x07, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67,
        0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44,
        0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x02, 0x69, 0x6e, 0x12, 0x30, 0x0a, 0x06, 0x6e,
        0x6f, 0x74, 0x5f, 0x69, 0x6e, 0x18, 0x08, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f,
        0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75,
        0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x05, 0x6e, 0x6f, 0x74, 0x49, 0x6e, 0x22, 0xf3, 0x02,
        0x0a, 0x0e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x75, 0x6c, 0x65, 0x73,
        0x12, 0x1a, 0x0a, 0x08, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x08, 0x52, 0x08, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x12, 0x30, 0x0a, 0x05,
        0x63, 0x6f, 0x6e, 0x73, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f,
        0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69,
        0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x05, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x12, 0x2a,
        0x0a, 0x02, 0x6c, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f,
        0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d,
        0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x02, 0x6c, 0x74, 0x12, 0x2c, 0x0a, 0x03, 0x6c, 0x74,
        0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74,
        0x61, 0x6d, 0x70, 0x52, 0x03, 0x6c, 0x74, 0x65, 0x12, 0x2a, 0x0a, 0x02, 0x67, 0x74, 0x18, 0x05,
        0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70,
        0x52, 0x02, 0x67, 0x74, 0x12, 0x2c, 0x0a, 0x03, 0x67, 0x74, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x03, 0x67,
        0x74, 0x65, 0x12, 0x15, 0x0a, 0x06, 0x6c, 0x74, 0x5f, 0x6e, 0x6f, 0x77, 0x18, 0x07, 0x20, 0x01,
        0x28, 0x08, 0x52, 0x05, 0x6c, 0x74, 0x4e, 0x6f, 0x77, 0x12, 0x15, 0x0a, 0x06, 0x67, 0x74, 0x5f,
        0x6e, 0x6f, 0x77, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x05, 0x67, 0x74, 0x4e, 0x6f, 0x77,
        0x12, 0x31, 0x0a, 0x06, 0x77, 0x69, 0x74, 0x68, 0x69, 0x6e, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62,
        0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x06, 0x77, 0x69, 0x74,
        0x68, 0x69, 0x6e, 0x2a, 0x46, 0x0a, 0x0a, 0x4b, 0x6e, 0x6f, 0x77, 0x6e, 0x52, 0x65, 0x67, 0x65,
        0x78, 0x12, 0x0b, 0x0a, 0x07, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10, 0x00, 0x12, 0x14,
        0x0a, 0x10, 0x48, 0x54, 0x54, 0x50, 0x5f, 0x48, 0x45, 0x41, 0x44, 0x45, 0x52, 0x5f, 0x4e, 0x41,
        0x4d, 0x45, 0x10, 0x01, 0x12, 0x15, 0x0a, 0x11, 0x48, 0x54, 0x54, 0x50, 0x5f, 0x48, 0x45, 0x41,
        0x44, 0x45, 0x52, 0x5f, 0x56, 0x41, 0x4c, 0x55, 0x45, 0x10, 0x02, 0x3a, 0x3c, 0x0a, 0x08, 0x64,
        0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x1f, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67,
        0x65, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0xaf, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52,
        0x08, 0x64, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x3a, 0x3a, 0x0a, 0x07, 0x69, 0x67, 0x6e,
        0x6f, 0x72, 0x65, 0x64, 0x12, 0x1f, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x4f, 0x70,
        0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0xb0, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x69, 0x67,
        0x6e, 0x6f, 0x72, 0x65, 0x64, 0x3a, 0x3a, 0x0a, 0x08, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65,
        0x64, 0x12, 0x1d, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x62, 0x75, 0x66, 0x2e, 0x4f, 0x6e, 0x65, 0x6f, 0x66, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73,
        0x18, 0xaf, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65,
        0x64, 0x3a, 0x4a, 0x0a, 0x05, 0x72, 0x75, 0x6c, 0x65, 0x73, 0x12, 0x1d, 0x2e, 0x67, 0x6f, 0x6f,
        0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x46, 0x69, 0x65,
        0x6c, 0x64, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0xaf, 0x08, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x14, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x46, 0x69, 0x65, 0x6c,
        0x64, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x52, 0x05, 0x72, 0x75, 0x6c, 0x65, 0x73, 0x42, 0x50, 0x0a,
        0x1a, 0x69, 0x6f, 0x2e, 0x65, 0x6e, 0x76, 0x6f, 0x79, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2e, 0x70,
        0x67, 0x76, 0x2e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x5a, 0x32, 0x67, 0x69, 0x74,
        0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x65, 0x6e, 0x76, 0x6f, 0x79, 0x70, 0x72, 0x6f,
        0x78, 0x79, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x2d, 0x67, 0x65, 0x6e, 0x2d, 0x76, 0x61,
        0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x2f, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65,
}

var (
        file_validate_validate_proto_rawDescOnce sync.Once
        file_validate_validate_proto_rawDescData = file_validate_validate_proto_rawDesc
)

func file_validate_validate_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_validate_validate_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_validate_validate_proto_rawDescData = protoimpl.X.CompressGZIP(file_validate_validate_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_validate_validate_proto_rawDescData</span>
}

var file_validate_validate_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_validate_validate_proto_msgTypes = make([]protoimpl.MessageInfo, 23)
var file_validate_validate_proto_goTypes = []interface{}{
        (KnownRegex)(0),                     // 0: validate.KnownRegex
        (*FieldRules)(nil),                  // 1: validate.FieldRules
        (*FloatRules)(nil),                  // 2: validate.FloatRules
        (*DoubleRules)(nil),                 // 3: validate.DoubleRules
        (*Int32Rules)(nil),                  // 4: validate.Int32Rules
        (*Int64Rules)(nil),                  // 5: validate.Int64Rules
        (*UInt32Rules)(nil),                 // 6: validate.UInt32Rules
        (*UInt64Rules)(nil),                 // 7: validate.UInt64Rules
        (*SInt32Rules)(nil),                 // 8: validate.SInt32Rules
        (*SInt64Rules)(nil),                 // 9: validate.SInt64Rules
        (*Fixed32Rules)(nil),                // 10: validate.Fixed32Rules
        (*Fixed64Rules)(nil),                // 11: validate.Fixed64Rules
        (*SFixed32Rules)(nil),               // 12: validate.SFixed32Rules
        (*SFixed64Rules)(nil),               // 13: validate.SFixed64Rules
        (*BoolRules)(nil),                   // 14: validate.BoolRules
        (*StringRules)(nil),                 // 15: validate.StringRules
        (*BytesRules)(nil),                  // 16: validate.BytesRules
        (*EnumRules)(nil),                   // 17: validate.EnumRules
        (*MessageRules)(nil),                // 18: validate.MessageRules
        (*RepeatedRules)(nil),               // 19: validate.RepeatedRules
        (*MapRules)(nil),                    // 20: validate.MapRules
        (*AnyRules)(nil),                    // 21: validate.AnyRules
        (*DurationRules)(nil),               // 22: validate.DurationRules
        (*TimestampRules)(nil),              // 23: validate.TimestampRules
        (*durationpb.Duration)(nil),         // 24: google.protobuf.Duration
        (*timestamppb.Timestamp)(nil),       // 25: google.protobuf.Timestamp
        (*descriptorpb.MessageOptions)(nil), // 26: google.protobuf.MessageOptions
        (*descriptorpb.OneofOptions)(nil),   // 27: google.protobuf.OneofOptions
        (*descriptorpb.FieldOptions)(nil),   // 28: google.protobuf.FieldOptions
}
var file_validate_validate_proto_depIdxs = []int32{
        18, // 0: validate.FieldRules.message:type_name -&gt; validate.MessageRules
        2,  // 1: validate.FieldRules.float:type_name -&gt; validate.FloatRules
        3,  // 2: validate.FieldRules.double:type_name -&gt; validate.DoubleRules
        4,  // 3: validate.FieldRules.int32:type_name -&gt; validate.Int32Rules
        5,  // 4: validate.FieldRules.int64:type_name -&gt; validate.Int64Rules
        6,  // 5: validate.FieldRules.uint32:type_name -&gt; validate.UInt32Rules
        7,  // 6: validate.FieldRules.uint64:type_name -&gt; validate.UInt64Rules
        8,  // 7: validate.FieldRules.sint32:type_name -&gt; validate.SInt32Rules
        9,  // 8: validate.FieldRules.sint64:type_name -&gt; validate.SInt64Rules
        10, // 9: validate.FieldRules.fixed32:type_name -&gt; validate.Fixed32Rules
        11, // 10: validate.FieldRules.fixed64:type_name -&gt; validate.Fixed64Rules
        12, // 11: validate.FieldRules.sfixed32:type_name -&gt; validate.SFixed32Rules
        13, // 12: validate.FieldRules.sfixed64:type_name -&gt; validate.SFixed64Rules
        14, // 13: validate.FieldRules.bool:type_name -&gt; validate.BoolRules
        15, // 14: validate.FieldRules.string:type_name -&gt; validate.StringRules
        16, // 15: validate.FieldRules.bytes:type_name -&gt; validate.BytesRules
        17, // 16: validate.FieldRules.enum:type_name -&gt; validate.EnumRules
        19, // 17: validate.FieldRules.repeated:type_name -&gt; validate.RepeatedRules
        20, // 18: validate.FieldRules.map:type_name -&gt; validate.MapRules
        21, // 19: validate.FieldRules.any:type_name -&gt; validate.AnyRules
        22, // 20: validate.FieldRules.duration:type_name -&gt; validate.DurationRules
        23, // 21: validate.FieldRules.timestamp:type_name -&gt; validate.TimestampRules
        0,  // 22: validate.StringRules.well_known_regex:type_name -&gt; validate.KnownRegex
        1,  // 23: validate.RepeatedRules.items:type_name -&gt; validate.FieldRules
        1,  // 24: validate.MapRules.keys:type_name -&gt; validate.FieldRules
        1,  // 25: validate.MapRules.values:type_name -&gt; validate.FieldRules
        24, // 26: validate.DurationRules.const:type_name -&gt; google.protobuf.Duration
        24, // 27: validate.DurationRules.lt:type_name -&gt; google.protobuf.Duration
        24, // 28: validate.DurationRules.lte:type_name -&gt; google.protobuf.Duration
        24, // 29: validate.DurationRules.gt:type_name -&gt; google.protobuf.Duration
        24, // 30: validate.DurationRules.gte:type_name -&gt; google.protobuf.Duration
        24, // 31: validate.DurationRules.in:type_name -&gt; google.protobuf.Duration
        24, // 32: validate.DurationRules.not_in:type_name -&gt; google.protobuf.Duration
        25, // 33: validate.TimestampRules.const:type_name -&gt; google.protobuf.Timestamp
        25, // 34: validate.TimestampRules.lt:type_name -&gt; google.protobuf.Timestamp
        25, // 35: validate.TimestampRules.lte:type_name -&gt; google.protobuf.Timestamp
        25, // 36: validate.TimestampRules.gt:type_name -&gt; google.protobuf.Timestamp
        25, // 37: validate.TimestampRules.gte:type_name -&gt; google.protobuf.Timestamp
        24, // 38: validate.TimestampRules.within:type_name -&gt; google.protobuf.Duration
        26, // 39: validate.disabled:extendee -&gt; google.protobuf.MessageOptions
        26, // 40: validate.ignored:extendee -&gt; google.protobuf.MessageOptions
        27, // 41: validate.required:extendee -&gt; google.protobuf.OneofOptions
        28, // 42: validate.rules:extendee -&gt; google.protobuf.FieldOptions
        1,  // 43: validate.rules:type_name -&gt; validate.FieldRules
        44, // [44:44] is the sub-list for method output_type
        44, // [44:44] is the sub-list for method input_type
        43, // [43:44] is the sub-list for extension type_name
        39, // [39:43] is the sub-list for extension extendee
        0,  // [0:39] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_validate_validate_proto_init() }</span>
func file_validate_validate_proto_init() <span class="cov0" title="0">{
        if File_validate_validate_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_validate_validate_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*FieldRules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*FloatRules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DoubleRules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Int32Rules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Int64Rules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UInt32Rules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UInt64Rules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*SInt32Rules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*SInt64Rules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Fixed32Rules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Fixed64Rules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*SFixed32Rules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*SFixed64Rules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*BoolRules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*StringRules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*BytesRules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*EnumRules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*MessageRules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*RepeatedRules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*MapRules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*AnyRules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[21].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DurationRules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_validate_validate_proto_msgTypes[22].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*TimestampRules); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">file_validate_validate_proto_msgTypes[0].OneofWrappers = []interface{}{
                (*FieldRules_Float)(nil),
                (*FieldRules_Double)(nil),
                (*FieldRules_Int32)(nil),
                (*FieldRules_Int64)(nil),
                (*FieldRules_Uint32)(nil),
                (*FieldRules_Uint64)(nil),
                (*FieldRules_Sint32)(nil),
                (*FieldRules_Sint64)(nil),
                (*FieldRules_Fixed32)(nil),
                (*FieldRules_Fixed64)(nil),
                (*FieldRules_Sfixed32)(nil),
                (*FieldRules_Sfixed64)(nil),
                (*FieldRules_Bool)(nil),
                (*FieldRules_String_)(nil),
                (*FieldRules_Bytes)(nil),
                (*FieldRules_Enum)(nil),
                (*FieldRules_Repeated)(nil),
                (*FieldRules_Map)(nil),
                (*FieldRules_Any)(nil),
                (*FieldRules_Duration)(nil),
                (*FieldRules_Timestamp)(nil),
        }
        file_validate_validate_proto_msgTypes[14].OneofWrappers = []interface{}{
                (*StringRules_Email)(nil),
                (*StringRules_Hostname)(nil),
                (*StringRules_Ip)(nil),
                (*StringRules_Ipv4)(nil),
                (*StringRules_Ipv6)(nil),
                (*StringRules_Uri)(nil),
                (*StringRules_UriRef)(nil),
                (*StringRules_Address)(nil),
                (*StringRules_Uuid)(nil),
                (*StringRules_WellKnownRegex)(nil),
        }
        file_validate_validate_proto_msgTypes[15].OneofWrappers = []interface{}{
                (*BytesRules_Ip)(nil),
                (*BytesRules_Ipv4)(nil),
                (*BytesRules_Ipv6)(nil),
        }
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_validate_validate_proto_rawDesc,
                        NumEnums:      1,
                        NumMessages:   23,
                        NumExtensions: 4,
                        NumServices:   0,
                },
                GoTypes:           file_validate_validate_proto_goTypes,
                DependencyIndexes: file_validate_validate_proto_depIdxs,
                EnumInfos:         file_validate_validate_proto_enumTypes,
                MessageInfos:      file_validate_validate_proto_msgTypes,
                ExtensionInfos:    file_validate_validate_proto_extTypes,
        }.Build()
        File_validate_validate_proto = out.File
        file_validate_validate_proto_rawDesc = nil
        file_validate_validate_proto_goTypes = nil
        file_validate_validate_proto_depIdxs = nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
