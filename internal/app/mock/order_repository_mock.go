// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

//go:generate minimock -i gitlab.ozon.dev/safariproxd/homework/internal/app.OrderRepository -o order_repository_mock.go -n OrderRepositoryMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/safariproxd/homework/internal/domain"
)

// OrderRepositoryMock implements mm_app.OrderRepository
type OrderRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetAllOrders          func(ctx context.Context) (oa1 []domain.Order, err error)
	funcGetAllOrdersOrigin    string
	inspectFuncGetAllOrders   func(ctx context.Context)
	afterGetAllOrdersCounter  uint64
	beforeGetAllOrdersCounter uint64
	GetAllOrdersMock          mOrderRepositoryMockGetAllOrders

	funcGetByID          func(ctx context.Context, orderID uint64) (o1 domain.Order, err error)
	funcGetByIDOrigin    string
	inspectFuncGetByID   func(ctx context.Context, orderID uint64)
	afterGetByIDCounter  uint64
	beforeGetByIDCounter uint64
	GetByIDMock          mOrderRepositoryMockGetByID

	funcGetByReceiverID          func(ctx context.Context, receiverID uint64) (oa1 []domain.Order, err error)
	funcGetByReceiverIDOrigin    string
	inspectFuncGetByReceiverID   func(ctx context.Context, receiverID uint64)
	afterGetByReceiverIDCounter  uint64
	beforeGetByReceiverIDCounter uint64
	GetByReceiverIDMock          mOrderRepositoryMockGetByReceiverID

	funcGetHistoryByOrderID          func(ctx context.Context, orderID uint64) (oa1 []domain.OrderHistory, err error)
	funcGetHistoryByOrderIDOrigin    string
	inspectFuncGetHistoryByOrderID   func(ctx context.Context, orderID uint64)
	afterGetHistoryByOrderIDCounter  uint64
	beforeGetHistoryByOrderIDCounter uint64
	GetHistoryByOrderIDMock          mOrderRepositoryMockGetHistoryByOrderID

	funcGetPackageRules          func(ctx context.Context, code string) (pa1 []domain.PackageRules, err error)
	funcGetPackageRulesOrigin    string
	inspectFuncGetPackageRules   func(ctx context.Context, code string)
	afterGetPackageRulesCounter  uint64
	beforeGetPackageRulesCounter uint64
	GetPackageRulesMock          mOrderRepositoryMockGetPackageRules

	funcGetReturnedOrders          func(ctx context.Context) (oa1 []domain.Order, err error)
	funcGetReturnedOrdersOrigin    string
	inspectFuncGetReturnedOrders   func(ctx context.Context)
	afterGetReturnedOrdersCounter  uint64
	beforeGetReturnedOrdersCounter uint64
	GetReturnedOrdersMock          mOrderRepositoryMockGetReturnedOrders

	funcSave          func(ctx context.Context, order domain.Order) (err error)
	funcSaveOrigin    string
	inspectFuncSave   func(ctx context.Context, order domain.Order)
	afterSaveCounter  uint64
	beforeSaveCounter uint64
	SaveMock          mOrderRepositoryMockSave

	funcSaveHistory          func(ctx context.Context, history domain.OrderHistory) (err error)
	funcSaveHistoryOrigin    string
	inspectFuncSaveHistory   func(ctx context.Context, history domain.OrderHistory)
	afterSaveHistoryCounter  uint64
	beforeSaveHistoryCounter uint64
	SaveHistoryMock          mOrderRepositoryMockSaveHistory

	funcUpdate          func(ctx context.Context, order domain.Order) (err error)
	funcUpdateOrigin    string
	inspectFuncUpdate   func(ctx context.Context, order domain.Order)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mOrderRepositoryMockUpdate
}

// NewOrderRepositoryMock returns a mock for mm_app.OrderRepository
func NewOrderRepositoryMock(t minimock.Tester) *OrderRepositoryMock {
	m := &OrderRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetAllOrdersMock = mOrderRepositoryMockGetAllOrders{mock: m}
	m.GetAllOrdersMock.callArgs = []*OrderRepositoryMockGetAllOrdersParams{}

	m.GetByIDMock = mOrderRepositoryMockGetByID{mock: m}
	m.GetByIDMock.callArgs = []*OrderRepositoryMockGetByIDParams{}

	m.GetByReceiverIDMock = mOrderRepositoryMockGetByReceiverID{mock: m}
	m.GetByReceiverIDMock.callArgs = []*OrderRepositoryMockGetByReceiverIDParams{}

	m.GetHistoryByOrderIDMock = mOrderRepositoryMockGetHistoryByOrderID{mock: m}
	m.GetHistoryByOrderIDMock.callArgs = []*OrderRepositoryMockGetHistoryByOrderIDParams{}

	m.GetPackageRulesMock = mOrderRepositoryMockGetPackageRules{mock: m}
	m.GetPackageRulesMock.callArgs = []*OrderRepositoryMockGetPackageRulesParams{}

	m.GetReturnedOrdersMock = mOrderRepositoryMockGetReturnedOrders{mock: m}
	m.GetReturnedOrdersMock.callArgs = []*OrderRepositoryMockGetReturnedOrdersParams{}

	m.SaveMock = mOrderRepositoryMockSave{mock: m}
	m.SaveMock.callArgs = []*OrderRepositoryMockSaveParams{}

	m.SaveHistoryMock = mOrderRepositoryMockSaveHistory{mock: m}
	m.SaveHistoryMock.callArgs = []*OrderRepositoryMockSaveHistoryParams{}

	m.UpdateMock = mOrderRepositoryMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*OrderRepositoryMockUpdateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mOrderRepositoryMockGetAllOrders struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockGetAllOrdersExpectation
	expectations       []*OrderRepositoryMockGetAllOrdersExpectation

	callArgs []*OrderRepositoryMockGetAllOrdersParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepositoryMockGetAllOrdersExpectation specifies expectation struct of the OrderRepository.GetAllOrders
type OrderRepositoryMockGetAllOrdersExpectation struct {
	mock               *OrderRepositoryMock
	params             *OrderRepositoryMockGetAllOrdersParams
	paramPtrs          *OrderRepositoryMockGetAllOrdersParamPtrs
	expectationOrigins OrderRepositoryMockGetAllOrdersExpectationOrigins
	results            *OrderRepositoryMockGetAllOrdersResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepositoryMockGetAllOrdersParams contains parameters of the OrderRepository.GetAllOrders
type OrderRepositoryMockGetAllOrdersParams struct {
	ctx context.Context
}

// OrderRepositoryMockGetAllOrdersParamPtrs contains pointers to parameters of the OrderRepository.GetAllOrders
type OrderRepositoryMockGetAllOrdersParamPtrs struct {
	ctx *context.Context
}

// OrderRepositoryMockGetAllOrdersResults contains results of the OrderRepository.GetAllOrders
type OrderRepositoryMockGetAllOrdersResults struct {
	oa1 []domain.Order
	err error
}

// OrderRepositoryMockGetAllOrdersOrigins contains origins of expectations of the OrderRepository.GetAllOrders
type OrderRepositoryMockGetAllOrdersExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAllOrders *mOrderRepositoryMockGetAllOrders) Optional() *mOrderRepositoryMockGetAllOrders {
	mmGetAllOrders.optional = true
	return mmGetAllOrders
}

// Expect sets up expected params for OrderRepository.GetAllOrders
func (mmGetAllOrders *mOrderRepositoryMockGetAllOrders) Expect(ctx context.Context) *mOrderRepositoryMockGetAllOrders {
	if mmGetAllOrders.mock.funcGetAllOrders != nil {
		mmGetAllOrders.mock.t.Fatalf("OrderRepositoryMock.GetAllOrders mock is already set by Set")
	}

	if mmGetAllOrders.defaultExpectation == nil {
		mmGetAllOrders.defaultExpectation = &OrderRepositoryMockGetAllOrdersExpectation{}
	}

	if mmGetAllOrders.defaultExpectation.paramPtrs != nil {
		mmGetAllOrders.mock.t.Fatalf("OrderRepositoryMock.GetAllOrders mock is already set by ExpectParams functions")
	}

	mmGetAllOrders.defaultExpectation.params = &OrderRepositoryMockGetAllOrdersParams{ctx}
	mmGetAllOrders.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetAllOrders.expectations {
		if minimock.Equal(e.params, mmGetAllOrders.defaultExpectation.params) {
			mmGetAllOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAllOrders.defaultExpectation.params)
		}
	}

	return mmGetAllOrders
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepository.GetAllOrders
func (mmGetAllOrders *mOrderRepositoryMockGetAllOrders) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockGetAllOrders {
	if mmGetAllOrders.mock.funcGetAllOrders != nil {
		mmGetAllOrders.mock.t.Fatalf("OrderRepositoryMock.GetAllOrders mock is already set by Set")
	}

	if mmGetAllOrders.defaultExpectation == nil {
		mmGetAllOrders.defaultExpectation = &OrderRepositoryMockGetAllOrdersExpectation{}
	}

	if mmGetAllOrders.defaultExpectation.params != nil {
		mmGetAllOrders.mock.t.Fatalf("OrderRepositoryMock.GetAllOrders mock is already set by Expect")
	}

	if mmGetAllOrders.defaultExpectation.paramPtrs == nil {
		mmGetAllOrders.defaultExpectation.paramPtrs = &OrderRepositoryMockGetAllOrdersParamPtrs{}
	}
	mmGetAllOrders.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetAllOrders.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetAllOrders
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.GetAllOrders
func (mmGetAllOrders *mOrderRepositoryMockGetAllOrders) Inspect(f func(ctx context.Context)) *mOrderRepositoryMockGetAllOrders {
	if mmGetAllOrders.mock.inspectFuncGetAllOrders != nil {
		mmGetAllOrders.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.GetAllOrders")
	}

	mmGetAllOrders.mock.inspectFuncGetAllOrders = f

	return mmGetAllOrders
}

// Return sets up results that will be returned by OrderRepository.GetAllOrders
func (mmGetAllOrders *mOrderRepositoryMockGetAllOrders) Return(oa1 []domain.Order, err error) *OrderRepositoryMock {
	if mmGetAllOrders.mock.funcGetAllOrders != nil {
		mmGetAllOrders.mock.t.Fatalf("OrderRepositoryMock.GetAllOrders mock is already set by Set")
	}

	if mmGetAllOrders.defaultExpectation == nil {
		mmGetAllOrders.defaultExpectation = &OrderRepositoryMockGetAllOrdersExpectation{mock: mmGetAllOrders.mock}
	}
	mmGetAllOrders.defaultExpectation.results = &OrderRepositoryMockGetAllOrdersResults{oa1, err}
	mmGetAllOrders.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetAllOrders.mock
}

// Set uses given function f to mock the OrderRepository.GetAllOrders method
func (mmGetAllOrders *mOrderRepositoryMockGetAllOrders) Set(f func(ctx context.Context) (oa1 []domain.Order, err error)) *OrderRepositoryMock {
	if mmGetAllOrders.defaultExpectation != nil {
		mmGetAllOrders.mock.t.Fatalf("Default expectation is already set for the OrderRepository.GetAllOrders method")
	}

	if len(mmGetAllOrders.expectations) > 0 {
		mmGetAllOrders.mock.t.Fatalf("Some expectations are already set for the OrderRepository.GetAllOrders method")
	}

	mmGetAllOrders.mock.funcGetAllOrders = f
	mmGetAllOrders.mock.funcGetAllOrdersOrigin = minimock.CallerInfo(1)
	return mmGetAllOrders.mock
}

// When sets expectation for the OrderRepository.GetAllOrders which will trigger the result defined by the following
// Then helper
func (mmGetAllOrders *mOrderRepositoryMockGetAllOrders) When(ctx context.Context) *OrderRepositoryMockGetAllOrdersExpectation {
	if mmGetAllOrders.mock.funcGetAllOrders != nil {
		mmGetAllOrders.mock.t.Fatalf("OrderRepositoryMock.GetAllOrders mock is already set by Set")
	}

	expectation := &OrderRepositoryMockGetAllOrdersExpectation{
		mock:               mmGetAllOrders.mock,
		params:             &OrderRepositoryMockGetAllOrdersParams{ctx},
		expectationOrigins: OrderRepositoryMockGetAllOrdersExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetAllOrders.expectations = append(mmGetAllOrders.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.GetAllOrders return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockGetAllOrdersExpectation) Then(oa1 []domain.Order, err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockGetAllOrdersResults{oa1, err}
	return e.mock
}

// Times sets number of times OrderRepository.GetAllOrders should be invoked
func (mmGetAllOrders *mOrderRepositoryMockGetAllOrders) Times(n uint64) *mOrderRepositoryMockGetAllOrders {
	if n == 0 {
		mmGetAllOrders.mock.t.Fatalf("Times of OrderRepositoryMock.GetAllOrders mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAllOrders.expectedInvocations, n)
	mmGetAllOrders.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetAllOrders
}

func (mmGetAllOrders *mOrderRepositoryMockGetAllOrders) invocationsDone() bool {
	if len(mmGetAllOrders.expectations) == 0 && mmGetAllOrders.defaultExpectation == nil && mmGetAllOrders.mock.funcGetAllOrders == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAllOrders.mock.afterGetAllOrdersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAllOrders.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAllOrders implements mm_app.OrderRepository
func (mmGetAllOrders *OrderRepositoryMock) GetAllOrders(ctx context.Context) (oa1 []domain.Order, err error) {
	mm_atomic.AddUint64(&mmGetAllOrders.beforeGetAllOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAllOrders.afterGetAllOrdersCounter, 1)

	mmGetAllOrders.t.Helper()

	if mmGetAllOrders.inspectFuncGetAllOrders != nil {
		mmGetAllOrders.inspectFuncGetAllOrders(ctx)
	}

	mm_params := OrderRepositoryMockGetAllOrdersParams{ctx}

	// Record call args
	mmGetAllOrders.GetAllOrdersMock.mutex.Lock()
	mmGetAllOrders.GetAllOrdersMock.callArgs = append(mmGetAllOrders.GetAllOrdersMock.callArgs, &mm_params)
	mmGetAllOrders.GetAllOrdersMock.mutex.Unlock()

	for _, e := range mmGetAllOrders.GetAllOrdersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmGetAllOrders.GetAllOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAllOrders.GetAllOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAllOrders.GetAllOrdersMock.defaultExpectation.params
		mm_want_ptrs := mmGetAllOrders.GetAllOrdersMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockGetAllOrdersParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetAllOrders.t.Errorf("OrderRepositoryMock.GetAllOrders got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAllOrders.GetAllOrdersMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAllOrders.t.Errorf("OrderRepositoryMock.GetAllOrders got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetAllOrders.GetAllOrdersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAllOrders.GetAllOrdersMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAllOrders.t.Fatal("No results are set for the OrderRepositoryMock.GetAllOrders")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmGetAllOrders.funcGetAllOrders != nil {
		return mmGetAllOrders.funcGetAllOrders(ctx)
	}
	mmGetAllOrders.t.Fatalf("Unexpected call to OrderRepositoryMock.GetAllOrders. %v", ctx)
	return
}

// GetAllOrdersAfterCounter returns a count of finished OrderRepositoryMock.GetAllOrders invocations
func (mmGetAllOrders *OrderRepositoryMock) GetAllOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllOrders.afterGetAllOrdersCounter)
}

// GetAllOrdersBeforeCounter returns a count of OrderRepositoryMock.GetAllOrders invocations
func (mmGetAllOrders *OrderRepositoryMock) GetAllOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllOrders.beforeGetAllOrdersCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.GetAllOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAllOrders *mOrderRepositoryMockGetAllOrders) Calls() []*OrderRepositoryMockGetAllOrdersParams {
	mmGetAllOrders.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockGetAllOrdersParams, len(mmGetAllOrders.callArgs))
	copy(argCopy, mmGetAllOrders.callArgs)

	mmGetAllOrders.mutex.RUnlock()

	return argCopy
}

// MinimockGetAllOrdersDone returns true if the count of the GetAllOrders invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockGetAllOrdersDone() bool {
	if m.GetAllOrdersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAllOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAllOrdersMock.invocationsDone()
}

// MinimockGetAllOrdersInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockGetAllOrdersInspect() {
	for _, e := range m.GetAllOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetAllOrders at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetAllOrdersCounter := mm_atomic.LoadUint64(&m.afterGetAllOrdersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllOrdersMock.defaultExpectation != nil && afterGetAllOrdersCounter < 1 {
		if m.GetAllOrdersMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetAllOrders at\n%s", m.GetAllOrdersMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetAllOrders at\n%s with params: %#v", m.GetAllOrdersMock.defaultExpectation.expectationOrigins.origin, *m.GetAllOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAllOrders != nil && afterGetAllOrdersCounter < 1 {
		m.t.Errorf("Expected call to OrderRepositoryMock.GetAllOrders at\n%s", m.funcGetAllOrdersOrigin)
	}

	if !m.GetAllOrdersMock.invocationsDone() && afterGetAllOrdersCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.GetAllOrders at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetAllOrdersMock.expectedInvocations), m.GetAllOrdersMock.expectedInvocationsOrigin, afterGetAllOrdersCounter)
	}
}

type mOrderRepositoryMockGetByID struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockGetByIDExpectation
	expectations       []*OrderRepositoryMockGetByIDExpectation

	callArgs []*OrderRepositoryMockGetByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepositoryMockGetByIDExpectation specifies expectation struct of the OrderRepository.GetByID
type OrderRepositoryMockGetByIDExpectation struct {
	mock               *OrderRepositoryMock
	params             *OrderRepositoryMockGetByIDParams
	paramPtrs          *OrderRepositoryMockGetByIDParamPtrs
	expectationOrigins OrderRepositoryMockGetByIDExpectationOrigins
	results            *OrderRepositoryMockGetByIDResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepositoryMockGetByIDParams contains parameters of the OrderRepository.GetByID
type OrderRepositoryMockGetByIDParams struct {
	ctx     context.Context
	orderID uint64
}

// OrderRepositoryMockGetByIDParamPtrs contains pointers to parameters of the OrderRepository.GetByID
type OrderRepositoryMockGetByIDParamPtrs struct {
	ctx     *context.Context
	orderID *uint64
}

// OrderRepositoryMockGetByIDResults contains results of the OrderRepository.GetByID
type OrderRepositoryMockGetByIDResults struct {
	o1  domain.Order
	err error
}

// OrderRepositoryMockGetByIDOrigins contains origins of expectations of the OrderRepository.GetByID
type OrderRepositoryMockGetByIDExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetByID *mOrderRepositoryMockGetByID) Optional() *mOrderRepositoryMockGetByID {
	mmGetByID.optional = true
	return mmGetByID
}

// Expect sets up expected params for OrderRepository.GetByID
func (mmGetByID *mOrderRepositoryMockGetByID) Expect(ctx context.Context, orderID uint64) *mOrderRepositoryMockGetByID {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("OrderRepositoryMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &OrderRepositoryMockGetByIDExpectation{}
	}

	if mmGetByID.defaultExpectation.paramPtrs != nil {
		mmGetByID.mock.t.Fatalf("OrderRepositoryMock.GetByID mock is already set by ExpectParams functions")
	}

	mmGetByID.defaultExpectation.params = &OrderRepositoryMockGetByIDParams{ctx, orderID}
	mmGetByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetByID.expectations {
		if minimock.Equal(e.params, mmGetByID.defaultExpectation.params) {
			mmGetByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByID.defaultExpectation.params)
		}
	}

	return mmGetByID
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepository.GetByID
func (mmGetByID *mOrderRepositoryMockGetByID) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockGetByID {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("OrderRepositoryMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &OrderRepositoryMockGetByIDExpectation{}
	}

	if mmGetByID.defaultExpectation.params != nil {
		mmGetByID.mock.t.Fatalf("OrderRepositoryMock.GetByID mock is already set by Expect")
	}

	if mmGetByID.defaultExpectation.paramPtrs == nil {
		mmGetByID.defaultExpectation.paramPtrs = &OrderRepositoryMockGetByIDParamPtrs{}
	}
	mmGetByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetByID
}

// ExpectOrderIDParam2 sets up expected param orderID for OrderRepository.GetByID
func (mmGetByID *mOrderRepositoryMockGetByID) ExpectOrderIDParam2(orderID uint64) *mOrderRepositoryMockGetByID {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("OrderRepositoryMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &OrderRepositoryMockGetByIDExpectation{}
	}

	if mmGetByID.defaultExpectation.params != nil {
		mmGetByID.mock.t.Fatalf("OrderRepositoryMock.GetByID mock is already set by Expect")
	}

	if mmGetByID.defaultExpectation.paramPtrs == nil {
		mmGetByID.defaultExpectation.paramPtrs = &OrderRepositoryMockGetByIDParamPtrs{}
	}
	mmGetByID.defaultExpectation.paramPtrs.orderID = &orderID
	mmGetByID.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmGetByID
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.GetByID
func (mmGetByID *mOrderRepositoryMockGetByID) Inspect(f func(ctx context.Context, orderID uint64)) *mOrderRepositoryMockGetByID {
	if mmGetByID.mock.inspectFuncGetByID != nil {
		mmGetByID.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.GetByID")
	}

	mmGetByID.mock.inspectFuncGetByID = f

	return mmGetByID
}

// Return sets up results that will be returned by OrderRepository.GetByID
func (mmGetByID *mOrderRepositoryMockGetByID) Return(o1 domain.Order, err error) *OrderRepositoryMock {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("OrderRepositoryMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &OrderRepositoryMockGetByIDExpectation{mock: mmGetByID.mock}
	}
	mmGetByID.defaultExpectation.results = &OrderRepositoryMockGetByIDResults{o1, err}
	mmGetByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetByID.mock
}

// Set uses given function f to mock the OrderRepository.GetByID method
func (mmGetByID *mOrderRepositoryMockGetByID) Set(f func(ctx context.Context, orderID uint64) (o1 domain.Order, err error)) *OrderRepositoryMock {
	if mmGetByID.defaultExpectation != nil {
		mmGetByID.mock.t.Fatalf("Default expectation is already set for the OrderRepository.GetByID method")
	}

	if len(mmGetByID.expectations) > 0 {
		mmGetByID.mock.t.Fatalf("Some expectations are already set for the OrderRepository.GetByID method")
	}

	mmGetByID.mock.funcGetByID = f
	mmGetByID.mock.funcGetByIDOrigin = minimock.CallerInfo(1)
	return mmGetByID.mock
}

// When sets expectation for the OrderRepository.GetByID which will trigger the result defined by the following
// Then helper
func (mmGetByID *mOrderRepositoryMockGetByID) When(ctx context.Context, orderID uint64) *OrderRepositoryMockGetByIDExpectation {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("OrderRepositoryMock.GetByID mock is already set by Set")
	}

	expectation := &OrderRepositoryMockGetByIDExpectation{
		mock:               mmGetByID.mock,
		params:             &OrderRepositoryMockGetByIDParams{ctx, orderID},
		expectationOrigins: OrderRepositoryMockGetByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetByID.expectations = append(mmGetByID.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.GetByID return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockGetByIDExpectation) Then(o1 domain.Order, err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockGetByIDResults{o1, err}
	return e.mock
}

// Times sets number of times OrderRepository.GetByID should be invoked
func (mmGetByID *mOrderRepositoryMockGetByID) Times(n uint64) *mOrderRepositoryMockGetByID {
	if n == 0 {
		mmGetByID.mock.t.Fatalf("Times of OrderRepositoryMock.GetByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetByID.expectedInvocations, n)
	mmGetByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetByID
}

func (mmGetByID *mOrderRepositoryMockGetByID) invocationsDone() bool {
	if len(mmGetByID.expectations) == 0 && mmGetByID.defaultExpectation == nil && mmGetByID.mock.funcGetByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetByID.mock.afterGetByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetByID implements mm_app.OrderRepository
func (mmGetByID *OrderRepositoryMock) GetByID(ctx context.Context, orderID uint64) (o1 domain.Order, err error) {
	mm_atomic.AddUint64(&mmGetByID.beforeGetByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByID.afterGetByIDCounter, 1)

	mmGetByID.t.Helper()

	if mmGetByID.inspectFuncGetByID != nil {
		mmGetByID.inspectFuncGetByID(ctx, orderID)
	}

	mm_params := OrderRepositoryMockGetByIDParams{ctx, orderID}

	// Record call args
	mmGetByID.GetByIDMock.mutex.Lock()
	mmGetByID.GetByIDMock.callArgs = append(mmGetByID.GetByIDMock.callArgs, &mm_params)
	mmGetByID.GetByIDMock.mutex.Unlock()

	for _, e := range mmGetByID.GetByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmGetByID.GetByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByID.GetByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByID.GetByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetByID.GetByIDMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockGetByIDParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetByID.t.Errorf("OrderRepositoryMock.GetByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByID.GetByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmGetByID.t.Errorf("OrderRepositoryMock.GetByID got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByID.GetByIDMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByID.t.Errorf("OrderRepositoryMock.GetByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetByID.GetByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByID.GetByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByID.t.Fatal("No results are set for the OrderRepositoryMock.GetByID")
		}
		return (*mm_results).o1, (*mm_results).err
	}
	if mmGetByID.funcGetByID != nil {
		return mmGetByID.funcGetByID(ctx, orderID)
	}
	mmGetByID.t.Fatalf("Unexpected call to OrderRepositoryMock.GetByID. %v %v", ctx, orderID)
	return
}

// GetByIDAfterCounter returns a count of finished OrderRepositoryMock.GetByID invocations
func (mmGetByID *OrderRepositoryMock) GetByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByID.afterGetByIDCounter)
}

// GetByIDBeforeCounter returns a count of OrderRepositoryMock.GetByID invocations
func (mmGetByID *OrderRepositoryMock) GetByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByID.beforeGetByIDCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.GetByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByID *mOrderRepositoryMockGetByID) Calls() []*OrderRepositoryMockGetByIDParams {
	mmGetByID.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockGetByIDParams, len(mmGetByID.callArgs))
	copy(argCopy, mmGetByID.callArgs)

	mmGetByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetByIDDone returns true if the count of the GetByID invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockGetByIDDone() bool {
	if m.GetByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetByIDMock.invocationsDone()
}

// MinimockGetByIDInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockGetByIDInspect() {
	for _, e := range m.GetByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetByIDCounter := mm_atomic.LoadUint64(&m.afterGetByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetByIDMock.defaultExpectation != nil && afterGetByIDCounter < 1 {
		if m.GetByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetByID at\n%s", m.GetByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetByID at\n%s with params: %#v", m.GetByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByID != nil && afterGetByIDCounter < 1 {
		m.t.Errorf("Expected call to OrderRepositoryMock.GetByID at\n%s", m.funcGetByIDOrigin)
	}

	if !m.GetByIDMock.invocationsDone() && afterGetByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.GetByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetByIDMock.expectedInvocations), m.GetByIDMock.expectedInvocationsOrigin, afterGetByIDCounter)
	}
}

type mOrderRepositoryMockGetByReceiverID struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockGetByReceiverIDExpectation
	expectations       []*OrderRepositoryMockGetByReceiverIDExpectation

	callArgs []*OrderRepositoryMockGetByReceiverIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepositoryMockGetByReceiverIDExpectation specifies expectation struct of the OrderRepository.GetByReceiverID
type OrderRepositoryMockGetByReceiverIDExpectation struct {
	mock               *OrderRepositoryMock
	params             *OrderRepositoryMockGetByReceiverIDParams
	paramPtrs          *OrderRepositoryMockGetByReceiverIDParamPtrs
	expectationOrigins OrderRepositoryMockGetByReceiverIDExpectationOrigins
	results            *OrderRepositoryMockGetByReceiverIDResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepositoryMockGetByReceiverIDParams contains parameters of the OrderRepository.GetByReceiverID
type OrderRepositoryMockGetByReceiverIDParams struct {
	ctx        context.Context
	receiverID uint64
}

// OrderRepositoryMockGetByReceiverIDParamPtrs contains pointers to parameters of the OrderRepository.GetByReceiverID
type OrderRepositoryMockGetByReceiverIDParamPtrs struct {
	ctx        *context.Context
	receiverID *uint64
}

// OrderRepositoryMockGetByReceiverIDResults contains results of the OrderRepository.GetByReceiverID
type OrderRepositoryMockGetByReceiverIDResults struct {
	oa1 []domain.Order
	err error
}

// OrderRepositoryMockGetByReceiverIDOrigins contains origins of expectations of the OrderRepository.GetByReceiverID
type OrderRepositoryMockGetByReceiverIDExpectationOrigins struct {
	origin           string
	originCtx        string
	originReceiverID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetByReceiverID *mOrderRepositoryMockGetByReceiverID) Optional() *mOrderRepositoryMockGetByReceiverID {
	mmGetByReceiverID.optional = true
	return mmGetByReceiverID
}

// Expect sets up expected params for OrderRepository.GetByReceiverID
func (mmGetByReceiverID *mOrderRepositoryMockGetByReceiverID) Expect(ctx context.Context, receiverID uint64) *mOrderRepositoryMockGetByReceiverID {
	if mmGetByReceiverID.mock.funcGetByReceiverID != nil {
		mmGetByReceiverID.mock.t.Fatalf("OrderRepositoryMock.GetByReceiverID mock is already set by Set")
	}

	if mmGetByReceiverID.defaultExpectation == nil {
		mmGetByReceiverID.defaultExpectation = &OrderRepositoryMockGetByReceiverIDExpectation{}
	}

	if mmGetByReceiverID.defaultExpectation.paramPtrs != nil {
		mmGetByReceiverID.mock.t.Fatalf("OrderRepositoryMock.GetByReceiverID mock is already set by ExpectParams functions")
	}

	mmGetByReceiverID.defaultExpectation.params = &OrderRepositoryMockGetByReceiverIDParams{ctx, receiverID}
	mmGetByReceiverID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetByReceiverID.expectations {
		if minimock.Equal(e.params, mmGetByReceiverID.defaultExpectation.params) {
			mmGetByReceiverID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByReceiverID.defaultExpectation.params)
		}
	}

	return mmGetByReceiverID
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepository.GetByReceiverID
func (mmGetByReceiverID *mOrderRepositoryMockGetByReceiverID) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockGetByReceiverID {
	if mmGetByReceiverID.mock.funcGetByReceiverID != nil {
		mmGetByReceiverID.mock.t.Fatalf("OrderRepositoryMock.GetByReceiverID mock is already set by Set")
	}

	if mmGetByReceiverID.defaultExpectation == nil {
		mmGetByReceiverID.defaultExpectation = &OrderRepositoryMockGetByReceiverIDExpectation{}
	}

	if mmGetByReceiverID.defaultExpectation.params != nil {
		mmGetByReceiverID.mock.t.Fatalf("OrderRepositoryMock.GetByReceiverID mock is already set by Expect")
	}

	if mmGetByReceiverID.defaultExpectation.paramPtrs == nil {
		mmGetByReceiverID.defaultExpectation.paramPtrs = &OrderRepositoryMockGetByReceiverIDParamPtrs{}
	}
	mmGetByReceiverID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetByReceiverID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetByReceiverID
}

// ExpectReceiverIDParam2 sets up expected param receiverID for OrderRepository.GetByReceiverID
func (mmGetByReceiverID *mOrderRepositoryMockGetByReceiverID) ExpectReceiverIDParam2(receiverID uint64) *mOrderRepositoryMockGetByReceiverID {
	if mmGetByReceiverID.mock.funcGetByReceiverID != nil {
		mmGetByReceiverID.mock.t.Fatalf("OrderRepositoryMock.GetByReceiverID mock is already set by Set")
	}

	if mmGetByReceiverID.defaultExpectation == nil {
		mmGetByReceiverID.defaultExpectation = &OrderRepositoryMockGetByReceiverIDExpectation{}
	}

	if mmGetByReceiverID.defaultExpectation.params != nil {
		mmGetByReceiverID.mock.t.Fatalf("OrderRepositoryMock.GetByReceiverID mock is already set by Expect")
	}

	if mmGetByReceiverID.defaultExpectation.paramPtrs == nil {
		mmGetByReceiverID.defaultExpectation.paramPtrs = &OrderRepositoryMockGetByReceiverIDParamPtrs{}
	}
	mmGetByReceiverID.defaultExpectation.paramPtrs.receiverID = &receiverID
	mmGetByReceiverID.defaultExpectation.expectationOrigins.originReceiverID = minimock.CallerInfo(1)

	return mmGetByReceiverID
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.GetByReceiverID
func (mmGetByReceiverID *mOrderRepositoryMockGetByReceiverID) Inspect(f func(ctx context.Context, receiverID uint64)) *mOrderRepositoryMockGetByReceiverID {
	if mmGetByReceiverID.mock.inspectFuncGetByReceiverID != nil {
		mmGetByReceiverID.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.GetByReceiverID")
	}

	mmGetByReceiverID.mock.inspectFuncGetByReceiverID = f

	return mmGetByReceiverID
}

// Return sets up results that will be returned by OrderRepository.GetByReceiverID
func (mmGetByReceiverID *mOrderRepositoryMockGetByReceiverID) Return(oa1 []domain.Order, err error) *OrderRepositoryMock {
	if mmGetByReceiverID.mock.funcGetByReceiverID != nil {
		mmGetByReceiverID.mock.t.Fatalf("OrderRepositoryMock.GetByReceiverID mock is already set by Set")
	}

	if mmGetByReceiverID.defaultExpectation == nil {
		mmGetByReceiverID.defaultExpectation = &OrderRepositoryMockGetByReceiverIDExpectation{mock: mmGetByReceiverID.mock}
	}
	mmGetByReceiverID.defaultExpectation.results = &OrderRepositoryMockGetByReceiverIDResults{oa1, err}
	mmGetByReceiverID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetByReceiverID.mock
}

// Set uses given function f to mock the OrderRepository.GetByReceiverID method
func (mmGetByReceiverID *mOrderRepositoryMockGetByReceiverID) Set(f func(ctx context.Context, receiverID uint64) (oa1 []domain.Order, err error)) *OrderRepositoryMock {
	if mmGetByReceiverID.defaultExpectation != nil {
		mmGetByReceiverID.mock.t.Fatalf("Default expectation is already set for the OrderRepository.GetByReceiverID method")
	}

	if len(mmGetByReceiverID.expectations) > 0 {
		mmGetByReceiverID.mock.t.Fatalf("Some expectations are already set for the OrderRepository.GetByReceiverID method")
	}

	mmGetByReceiverID.mock.funcGetByReceiverID = f
	mmGetByReceiverID.mock.funcGetByReceiverIDOrigin = minimock.CallerInfo(1)
	return mmGetByReceiverID.mock
}

// When sets expectation for the OrderRepository.GetByReceiverID which will trigger the result defined by the following
// Then helper
func (mmGetByReceiverID *mOrderRepositoryMockGetByReceiverID) When(ctx context.Context, receiverID uint64) *OrderRepositoryMockGetByReceiverIDExpectation {
	if mmGetByReceiverID.mock.funcGetByReceiverID != nil {
		mmGetByReceiverID.mock.t.Fatalf("OrderRepositoryMock.GetByReceiverID mock is already set by Set")
	}

	expectation := &OrderRepositoryMockGetByReceiverIDExpectation{
		mock:               mmGetByReceiverID.mock,
		params:             &OrderRepositoryMockGetByReceiverIDParams{ctx, receiverID},
		expectationOrigins: OrderRepositoryMockGetByReceiverIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetByReceiverID.expectations = append(mmGetByReceiverID.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.GetByReceiverID return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockGetByReceiverIDExpectation) Then(oa1 []domain.Order, err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockGetByReceiverIDResults{oa1, err}
	return e.mock
}

// Times sets number of times OrderRepository.GetByReceiverID should be invoked
func (mmGetByReceiverID *mOrderRepositoryMockGetByReceiverID) Times(n uint64) *mOrderRepositoryMockGetByReceiverID {
	if n == 0 {
		mmGetByReceiverID.mock.t.Fatalf("Times of OrderRepositoryMock.GetByReceiverID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetByReceiverID.expectedInvocations, n)
	mmGetByReceiverID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetByReceiverID
}

func (mmGetByReceiverID *mOrderRepositoryMockGetByReceiverID) invocationsDone() bool {
	if len(mmGetByReceiverID.expectations) == 0 && mmGetByReceiverID.defaultExpectation == nil && mmGetByReceiverID.mock.funcGetByReceiverID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetByReceiverID.mock.afterGetByReceiverIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetByReceiverID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetByReceiverID implements mm_app.OrderRepository
func (mmGetByReceiverID *OrderRepositoryMock) GetByReceiverID(ctx context.Context, receiverID uint64) (oa1 []domain.Order, err error) {
	mm_atomic.AddUint64(&mmGetByReceiverID.beforeGetByReceiverIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByReceiverID.afterGetByReceiverIDCounter, 1)

	mmGetByReceiverID.t.Helper()

	if mmGetByReceiverID.inspectFuncGetByReceiverID != nil {
		mmGetByReceiverID.inspectFuncGetByReceiverID(ctx, receiverID)
	}

	mm_params := OrderRepositoryMockGetByReceiverIDParams{ctx, receiverID}

	// Record call args
	mmGetByReceiverID.GetByReceiverIDMock.mutex.Lock()
	mmGetByReceiverID.GetByReceiverIDMock.callArgs = append(mmGetByReceiverID.GetByReceiverIDMock.callArgs, &mm_params)
	mmGetByReceiverID.GetByReceiverIDMock.mutex.Unlock()

	for _, e := range mmGetByReceiverID.GetByReceiverIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmGetByReceiverID.GetByReceiverIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByReceiverID.GetByReceiverIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByReceiverID.GetByReceiverIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetByReceiverID.GetByReceiverIDMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockGetByReceiverIDParams{ctx, receiverID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetByReceiverID.t.Errorf("OrderRepositoryMock.GetByReceiverID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByReceiverID.GetByReceiverIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.receiverID != nil && !minimock.Equal(*mm_want_ptrs.receiverID, mm_got.receiverID) {
				mmGetByReceiverID.t.Errorf("OrderRepositoryMock.GetByReceiverID got unexpected parameter receiverID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByReceiverID.GetByReceiverIDMock.defaultExpectation.expectationOrigins.originReceiverID, *mm_want_ptrs.receiverID, mm_got.receiverID, minimock.Diff(*mm_want_ptrs.receiverID, mm_got.receiverID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByReceiverID.t.Errorf("OrderRepositoryMock.GetByReceiverID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetByReceiverID.GetByReceiverIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByReceiverID.GetByReceiverIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByReceiverID.t.Fatal("No results are set for the OrderRepositoryMock.GetByReceiverID")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmGetByReceiverID.funcGetByReceiverID != nil {
		return mmGetByReceiverID.funcGetByReceiverID(ctx, receiverID)
	}
	mmGetByReceiverID.t.Fatalf("Unexpected call to OrderRepositoryMock.GetByReceiverID. %v %v", ctx, receiverID)
	return
}

// GetByReceiverIDAfterCounter returns a count of finished OrderRepositoryMock.GetByReceiverID invocations
func (mmGetByReceiverID *OrderRepositoryMock) GetByReceiverIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByReceiverID.afterGetByReceiverIDCounter)
}

// GetByReceiverIDBeforeCounter returns a count of OrderRepositoryMock.GetByReceiverID invocations
func (mmGetByReceiverID *OrderRepositoryMock) GetByReceiverIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByReceiverID.beforeGetByReceiverIDCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.GetByReceiverID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByReceiverID *mOrderRepositoryMockGetByReceiverID) Calls() []*OrderRepositoryMockGetByReceiverIDParams {
	mmGetByReceiverID.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockGetByReceiverIDParams, len(mmGetByReceiverID.callArgs))
	copy(argCopy, mmGetByReceiverID.callArgs)

	mmGetByReceiverID.mutex.RUnlock()

	return argCopy
}

// MinimockGetByReceiverIDDone returns true if the count of the GetByReceiverID invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockGetByReceiverIDDone() bool {
	if m.GetByReceiverIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetByReceiverIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetByReceiverIDMock.invocationsDone()
}

// MinimockGetByReceiverIDInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockGetByReceiverIDInspect() {
	for _, e := range m.GetByReceiverIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetByReceiverID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetByReceiverIDCounter := mm_atomic.LoadUint64(&m.afterGetByReceiverIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetByReceiverIDMock.defaultExpectation != nil && afterGetByReceiverIDCounter < 1 {
		if m.GetByReceiverIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetByReceiverID at\n%s", m.GetByReceiverIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetByReceiverID at\n%s with params: %#v", m.GetByReceiverIDMock.defaultExpectation.expectationOrigins.origin, *m.GetByReceiverIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByReceiverID != nil && afterGetByReceiverIDCounter < 1 {
		m.t.Errorf("Expected call to OrderRepositoryMock.GetByReceiverID at\n%s", m.funcGetByReceiverIDOrigin)
	}

	if !m.GetByReceiverIDMock.invocationsDone() && afterGetByReceiverIDCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.GetByReceiverID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetByReceiverIDMock.expectedInvocations), m.GetByReceiverIDMock.expectedInvocationsOrigin, afterGetByReceiverIDCounter)
	}
}

type mOrderRepositoryMockGetHistoryByOrderID struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockGetHistoryByOrderIDExpectation
	expectations       []*OrderRepositoryMockGetHistoryByOrderIDExpectation

	callArgs []*OrderRepositoryMockGetHistoryByOrderIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepositoryMockGetHistoryByOrderIDExpectation specifies expectation struct of the OrderRepository.GetHistoryByOrderID
type OrderRepositoryMockGetHistoryByOrderIDExpectation struct {
	mock               *OrderRepositoryMock
	params             *OrderRepositoryMockGetHistoryByOrderIDParams
	paramPtrs          *OrderRepositoryMockGetHistoryByOrderIDParamPtrs
	expectationOrigins OrderRepositoryMockGetHistoryByOrderIDExpectationOrigins
	results            *OrderRepositoryMockGetHistoryByOrderIDResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepositoryMockGetHistoryByOrderIDParams contains parameters of the OrderRepository.GetHistoryByOrderID
type OrderRepositoryMockGetHistoryByOrderIDParams struct {
	ctx     context.Context
	orderID uint64
}

// OrderRepositoryMockGetHistoryByOrderIDParamPtrs contains pointers to parameters of the OrderRepository.GetHistoryByOrderID
type OrderRepositoryMockGetHistoryByOrderIDParamPtrs struct {
	ctx     *context.Context
	orderID *uint64
}

// OrderRepositoryMockGetHistoryByOrderIDResults contains results of the OrderRepository.GetHistoryByOrderID
type OrderRepositoryMockGetHistoryByOrderIDResults struct {
	oa1 []domain.OrderHistory
	err error
}

// OrderRepositoryMockGetHistoryByOrderIDOrigins contains origins of expectations of the OrderRepository.GetHistoryByOrderID
type OrderRepositoryMockGetHistoryByOrderIDExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetHistoryByOrderID *mOrderRepositoryMockGetHistoryByOrderID) Optional() *mOrderRepositoryMockGetHistoryByOrderID {
	mmGetHistoryByOrderID.optional = true
	return mmGetHistoryByOrderID
}

// Expect sets up expected params for OrderRepository.GetHistoryByOrderID
func (mmGetHistoryByOrderID *mOrderRepositoryMockGetHistoryByOrderID) Expect(ctx context.Context, orderID uint64) *mOrderRepositoryMockGetHistoryByOrderID {
	if mmGetHistoryByOrderID.mock.funcGetHistoryByOrderID != nil {
		mmGetHistoryByOrderID.mock.t.Fatalf("OrderRepositoryMock.GetHistoryByOrderID mock is already set by Set")
	}

	if mmGetHistoryByOrderID.defaultExpectation == nil {
		mmGetHistoryByOrderID.defaultExpectation = &OrderRepositoryMockGetHistoryByOrderIDExpectation{}
	}

	if mmGetHistoryByOrderID.defaultExpectation.paramPtrs != nil {
		mmGetHistoryByOrderID.mock.t.Fatalf("OrderRepositoryMock.GetHistoryByOrderID mock is already set by ExpectParams functions")
	}

	mmGetHistoryByOrderID.defaultExpectation.params = &OrderRepositoryMockGetHistoryByOrderIDParams{ctx, orderID}
	mmGetHistoryByOrderID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetHistoryByOrderID.expectations {
		if minimock.Equal(e.params, mmGetHistoryByOrderID.defaultExpectation.params) {
			mmGetHistoryByOrderID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetHistoryByOrderID.defaultExpectation.params)
		}
	}

	return mmGetHistoryByOrderID
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepository.GetHistoryByOrderID
func (mmGetHistoryByOrderID *mOrderRepositoryMockGetHistoryByOrderID) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockGetHistoryByOrderID {
	if mmGetHistoryByOrderID.mock.funcGetHistoryByOrderID != nil {
		mmGetHistoryByOrderID.mock.t.Fatalf("OrderRepositoryMock.GetHistoryByOrderID mock is already set by Set")
	}

	if mmGetHistoryByOrderID.defaultExpectation == nil {
		mmGetHistoryByOrderID.defaultExpectation = &OrderRepositoryMockGetHistoryByOrderIDExpectation{}
	}

	if mmGetHistoryByOrderID.defaultExpectation.params != nil {
		mmGetHistoryByOrderID.mock.t.Fatalf("OrderRepositoryMock.GetHistoryByOrderID mock is already set by Expect")
	}

	if mmGetHistoryByOrderID.defaultExpectation.paramPtrs == nil {
		mmGetHistoryByOrderID.defaultExpectation.paramPtrs = &OrderRepositoryMockGetHistoryByOrderIDParamPtrs{}
	}
	mmGetHistoryByOrderID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetHistoryByOrderID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetHistoryByOrderID
}

// ExpectOrderIDParam2 sets up expected param orderID for OrderRepository.GetHistoryByOrderID
func (mmGetHistoryByOrderID *mOrderRepositoryMockGetHistoryByOrderID) ExpectOrderIDParam2(orderID uint64) *mOrderRepositoryMockGetHistoryByOrderID {
	if mmGetHistoryByOrderID.mock.funcGetHistoryByOrderID != nil {
		mmGetHistoryByOrderID.mock.t.Fatalf("OrderRepositoryMock.GetHistoryByOrderID mock is already set by Set")
	}

	if mmGetHistoryByOrderID.defaultExpectation == nil {
		mmGetHistoryByOrderID.defaultExpectation = &OrderRepositoryMockGetHistoryByOrderIDExpectation{}
	}

	if mmGetHistoryByOrderID.defaultExpectation.params != nil {
		mmGetHistoryByOrderID.mock.t.Fatalf("OrderRepositoryMock.GetHistoryByOrderID mock is already set by Expect")
	}

	if mmGetHistoryByOrderID.defaultExpectation.paramPtrs == nil {
		mmGetHistoryByOrderID.defaultExpectation.paramPtrs = &OrderRepositoryMockGetHistoryByOrderIDParamPtrs{}
	}
	mmGetHistoryByOrderID.defaultExpectation.paramPtrs.orderID = &orderID
	mmGetHistoryByOrderID.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmGetHistoryByOrderID
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.GetHistoryByOrderID
func (mmGetHistoryByOrderID *mOrderRepositoryMockGetHistoryByOrderID) Inspect(f func(ctx context.Context, orderID uint64)) *mOrderRepositoryMockGetHistoryByOrderID {
	if mmGetHistoryByOrderID.mock.inspectFuncGetHistoryByOrderID != nil {
		mmGetHistoryByOrderID.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.GetHistoryByOrderID")
	}

	mmGetHistoryByOrderID.mock.inspectFuncGetHistoryByOrderID = f

	return mmGetHistoryByOrderID
}

// Return sets up results that will be returned by OrderRepository.GetHistoryByOrderID
func (mmGetHistoryByOrderID *mOrderRepositoryMockGetHistoryByOrderID) Return(oa1 []domain.OrderHistory, err error) *OrderRepositoryMock {
	if mmGetHistoryByOrderID.mock.funcGetHistoryByOrderID != nil {
		mmGetHistoryByOrderID.mock.t.Fatalf("OrderRepositoryMock.GetHistoryByOrderID mock is already set by Set")
	}

	if mmGetHistoryByOrderID.defaultExpectation == nil {
		mmGetHistoryByOrderID.defaultExpectation = &OrderRepositoryMockGetHistoryByOrderIDExpectation{mock: mmGetHistoryByOrderID.mock}
	}
	mmGetHistoryByOrderID.defaultExpectation.results = &OrderRepositoryMockGetHistoryByOrderIDResults{oa1, err}
	mmGetHistoryByOrderID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetHistoryByOrderID.mock
}

// Set uses given function f to mock the OrderRepository.GetHistoryByOrderID method
func (mmGetHistoryByOrderID *mOrderRepositoryMockGetHistoryByOrderID) Set(f func(ctx context.Context, orderID uint64) (oa1 []domain.OrderHistory, err error)) *OrderRepositoryMock {
	if mmGetHistoryByOrderID.defaultExpectation != nil {
		mmGetHistoryByOrderID.mock.t.Fatalf("Default expectation is already set for the OrderRepository.GetHistoryByOrderID method")
	}

	if len(mmGetHistoryByOrderID.expectations) > 0 {
		mmGetHistoryByOrderID.mock.t.Fatalf("Some expectations are already set for the OrderRepository.GetHistoryByOrderID method")
	}

	mmGetHistoryByOrderID.mock.funcGetHistoryByOrderID = f
	mmGetHistoryByOrderID.mock.funcGetHistoryByOrderIDOrigin = minimock.CallerInfo(1)
	return mmGetHistoryByOrderID.mock
}

// When sets expectation for the OrderRepository.GetHistoryByOrderID which will trigger the result defined by the following
// Then helper
func (mmGetHistoryByOrderID *mOrderRepositoryMockGetHistoryByOrderID) When(ctx context.Context, orderID uint64) *OrderRepositoryMockGetHistoryByOrderIDExpectation {
	if mmGetHistoryByOrderID.mock.funcGetHistoryByOrderID != nil {
		mmGetHistoryByOrderID.mock.t.Fatalf("OrderRepositoryMock.GetHistoryByOrderID mock is already set by Set")
	}

	expectation := &OrderRepositoryMockGetHistoryByOrderIDExpectation{
		mock:               mmGetHistoryByOrderID.mock,
		params:             &OrderRepositoryMockGetHistoryByOrderIDParams{ctx, orderID},
		expectationOrigins: OrderRepositoryMockGetHistoryByOrderIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetHistoryByOrderID.expectations = append(mmGetHistoryByOrderID.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.GetHistoryByOrderID return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockGetHistoryByOrderIDExpectation) Then(oa1 []domain.OrderHistory, err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockGetHistoryByOrderIDResults{oa1, err}
	return e.mock
}

// Times sets number of times OrderRepository.GetHistoryByOrderID should be invoked
func (mmGetHistoryByOrderID *mOrderRepositoryMockGetHistoryByOrderID) Times(n uint64) *mOrderRepositoryMockGetHistoryByOrderID {
	if n == 0 {
		mmGetHistoryByOrderID.mock.t.Fatalf("Times of OrderRepositoryMock.GetHistoryByOrderID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetHistoryByOrderID.expectedInvocations, n)
	mmGetHistoryByOrderID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetHistoryByOrderID
}

func (mmGetHistoryByOrderID *mOrderRepositoryMockGetHistoryByOrderID) invocationsDone() bool {
	if len(mmGetHistoryByOrderID.expectations) == 0 && mmGetHistoryByOrderID.defaultExpectation == nil && mmGetHistoryByOrderID.mock.funcGetHistoryByOrderID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetHistoryByOrderID.mock.afterGetHistoryByOrderIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetHistoryByOrderID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetHistoryByOrderID implements mm_app.OrderRepository
func (mmGetHistoryByOrderID *OrderRepositoryMock) GetHistoryByOrderID(ctx context.Context, orderID uint64) (oa1 []domain.OrderHistory, err error) {
	mm_atomic.AddUint64(&mmGetHistoryByOrderID.beforeGetHistoryByOrderIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetHistoryByOrderID.afterGetHistoryByOrderIDCounter, 1)

	mmGetHistoryByOrderID.t.Helper()

	if mmGetHistoryByOrderID.inspectFuncGetHistoryByOrderID != nil {
		mmGetHistoryByOrderID.inspectFuncGetHistoryByOrderID(ctx, orderID)
	}

	mm_params := OrderRepositoryMockGetHistoryByOrderIDParams{ctx, orderID}

	// Record call args
	mmGetHistoryByOrderID.GetHistoryByOrderIDMock.mutex.Lock()
	mmGetHistoryByOrderID.GetHistoryByOrderIDMock.callArgs = append(mmGetHistoryByOrderID.GetHistoryByOrderIDMock.callArgs, &mm_params)
	mmGetHistoryByOrderID.GetHistoryByOrderIDMock.mutex.Unlock()

	for _, e := range mmGetHistoryByOrderID.GetHistoryByOrderIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmGetHistoryByOrderID.GetHistoryByOrderIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetHistoryByOrderID.GetHistoryByOrderIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetHistoryByOrderID.GetHistoryByOrderIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetHistoryByOrderID.GetHistoryByOrderIDMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockGetHistoryByOrderIDParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetHistoryByOrderID.t.Errorf("OrderRepositoryMock.GetHistoryByOrderID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetHistoryByOrderID.GetHistoryByOrderIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmGetHistoryByOrderID.t.Errorf("OrderRepositoryMock.GetHistoryByOrderID got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetHistoryByOrderID.GetHistoryByOrderIDMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetHistoryByOrderID.t.Errorf("OrderRepositoryMock.GetHistoryByOrderID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetHistoryByOrderID.GetHistoryByOrderIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetHistoryByOrderID.GetHistoryByOrderIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetHistoryByOrderID.t.Fatal("No results are set for the OrderRepositoryMock.GetHistoryByOrderID")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmGetHistoryByOrderID.funcGetHistoryByOrderID != nil {
		return mmGetHistoryByOrderID.funcGetHistoryByOrderID(ctx, orderID)
	}
	mmGetHistoryByOrderID.t.Fatalf("Unexpected call to OrderRepositoryMock.GetHistoryByOrderID. %v %v", ctx, orderID)
	return
}

// GetHistoryByOrderIDAfterCounter returns a count of finished OrderRepositoryMock.GetHistoryByOrderID invocations
func (mmGetHistoryByOrderID *OrderRepositoryMock) GetHistoryByOrderIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetHistoryByOrderID.afterGetHistoryByOrderIDCounter)
}

// GetHistoryByOrderIDBeforeCounter returns a count of OrderRepositoryMock.GetHistoryByOrderID invocations
func (mmGetHistoryByOrderID *OrderRepositoryMock) GetHistoryByOrderIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetHistoryByOrderID.beforeGetHistoryByOrderIDCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.GetHistoryByOrderID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetHistoryByOrderID *mOrderRepositoryMockGetHistoryByOrderID) Calls() []*OrderRepositoryMockGetHistoryByOrderIDParams {
	mmGetHistoryByOrderID.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockGetHistoryByOrderIDParams, len(mmGetHistoryByOrderID.callArgs))
	copy(argCopy, mmGetHistoryByOrderID.callArgs)

	mmGetHistoryByOrderID.mutex.RUnlock()

	return argCopy
}

// MinimockGetHistoryByOrderIDDone returns true if the count of the GetHistoryByOrderID invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockGetHistoryByOrderIDDone() bool {
	if m.GetHistoryByOrderIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetHistoryByOrderIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetHistoryByOrderIDMock.invocationsDone()
}

// MinimockGetHistoryByOrderIDInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockGetHistoryByOrderIDInspect() {
	for _, e := range m.GetHistoryByOrderIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetHistoryByOrderID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetHistoryByOrderIDCounter := mm_atomic.LoadUint64(&m.afterGetHistoryByOrderIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetHistoryByOrderIDMock.defaultExpectation != nil && afterGetHistoryByOrderIDCounter < 1 {
		if m.GetHistoryByOrderIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetHistoryByOrderID at\n%s", m.GetHistoryByOrderIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetHistoryByOrderID at\n%s with params: %#v", m.GetHistoryByOrderIDMock.defaultExpectation.expectationOrigins.origin, *m.GetHistoryByOrderIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetHistoryByOrderID != nil && afterGetHistoryByOrderIDCounter < 1 {
		m.t.Errorf("Expected call to OrderRepositoryMock.GetHistoryByOrderID at\n%s", m.funcGetHistoryByOrderIDOrigin)
	}

	if !m.GetHistoryByOrderIDMock.invocationsDone() && afterGetHistoryByOrderIDCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.GetHistoryByOrderID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetHistoryByOrderIDMock.expectedInvocations), m.GetHistoryByOrderIDMock.expectedInvocationsOrigin, afterGetHistoryByOrderIDCounter)
	}
}

type mOrderRepositoryMockGetPackageRules struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockGetPackageRulesExpectation
	expectations       []*OrderRepositoryMockGetPackageRulesExpectation

	callArgs []*OrderRepositoryMockGetPackageRulesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepositoryMockGetPackageRulesExpectation specifies expectation struct of the OrderRepository.GetPackageRules
type OrderRepositoryMockGetPackageRulesExpectation struct {
	mock               *OrderRepositoryMock
	params             *OrderRepositoryMockGetPackageRulesParams
	paramPtrs          *OrderRepositoryMockGetPackageRulesParamPtrs
	expectationOrigins OrderRepositoryMockGetPackageRulesExpectationOrigins
	results            *OrderRepositoryMockGetPackageRulesResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepositoryMockGetPackageRulesParams contains parameters of the OrderRepository.GetPackageRules
type OrderRepositoryMockGetPackageRulesParams struct {
	ctx  context.Context
	code string
}

// OrderRepositoryMockGetPackageRulesParamPtrs contains pointers to parameters of the OrderRepository.GetPackageRules
type OrderRepositoryMockGetPackageRulesParamPtrs struct {
	ctx  *context.Context
	code *string
}

// OrderRepositoryMockGetPackageRulesResults contains results of the OrderRepository.GetPackageRules
type OrderRepositoryMockGetPackageRulesResults struct {
	pa1 []domain.PackageRules
	err error
}

// OrderRepositoryMockGetPackageRulesOrigins contains origins of expectations of the OrderRepository.GetPackageRules
type OrderRepositoryMockGetPackageRulesExpectationOrigins struct {
	origin     string
	originCtx  string
	originCode string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPackageRules *mOrderRepositoryMockGetPackageRules) Optional() *mOrderRepositoryMockGetPackageRules {
	mmGetPackageRules.optional = true
	return mmGetPackageRules
}

// Expect sets up expected params for OrderRepository.GetPackageRules
func (mmGetPackageRules *mOrderRepositoryMockGetPackageRules) Expect(ctx context.Context, code string) *mOrderRepositoryMockGetPackageRules {
	if mmGetPackageRules.mock.funcGetPackageRules != nil {
		mmGetPackageRules.mock.t.Fatalf("OrderRepositoryMock.GetPackageRules mock is already set by Set")
	}

	if mmGetPackageRules.defaultExpectation == nil {
		mmGetPackageRules.defaultExpectation = &OrderRepositoryMockGetPackageRulesExpectation{}
	}

	if mmGetPackageRules.defaultExpectation.paramPtrs != nil {
		mmGetPackageRules.mock.t.Fatalf("OrderRepositoryMock.GetPackageRules mock is already set by ExpectParams functions")
	}

	mmGetPackageRules.defaultExpectation.params = &OrderRepositoryMockGetPackageRulesParams{ctx, code}
	mmGetPackageRules.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPackageRules.expectations {
		if minimock.Equal(e.params, mmGetPackageRules.defaultExpectation.params) {
			mmGetPackageRules.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPackageRules.defaultExpectation.params)
		}
	}

	return mmGetPackageRules
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepository.GetPackageRules
func (mmGetPackageRules *mOrderRepositoryMockGetPackageRules) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockGetPackageRules {
	if mmGetPackageRules.mock.funcGetPackageRules != nil {
		mmGetPackageRules.mock.t.Fatalf("OrderRepositoryMock.GetPackageRules mock is already set by Set")
	}

	if mmGetPackageRules.defaultExpectation == nil {
		mmGetPackageRules.defaultExpectation = &OrderRepositoryMockGetPackageRulesExpectation{}
	}

	if mmGetPackageRules.defaultExpectation.params != nil {
		mmGetPackageRules.mock.t.Fatalf("OrderRepositoryMock.GetPackageRules mock is already set by Expect")
	}

	if mmGetPackageRules.defaultExpectation.paramPtrs == nil {
		mmGetPackageRules.defaultExpectation.paramPtrs = &OrderRepositoryMockGetPackageRulesParamPtrs{}
	}
	mmGetPackageRules.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPackageRules.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPackageRules
}

// ExpectCodeParam2 sets up expected param code for OrderRepository.GetPackageRules
func (mmGetPackageRules *mOrderRepositoryMockGetPackageRules) ExpectCodeParam2(code string) *mOrderRepositoryMockGetPackageRules {
	if mmGetPackageRules.mock.funcGetPackageRules != nil {
		mmGetPackageRules.mock.t.Fatalf("OrderRepositoryMock.GetPackageRules mock is already set by Set")
	}

	if mmGetPackageRules.defaultExpectation == nil {
		mmGetPackageRules.defaultExpectation = &OrderRepositoryMockGetPackageRulesExpectation{}
	}

	if mmGetPackageRules.defaultExpectation.params != nil {
		mmGetPackageRules.mock.t.Fatalf("OrderRepositoryMock.GetPackageRules mock is already set by Expect")
	}

	if mmGetPackageRules.defaultExpectation.paramPtrs == nil {
		mmGetPackageRules.defaultExpectation.paramPtrs = &OrderRepositoryMockGetPackageRulesParamPtrs{}
	}
	mmGetPackageRules.defaultExpectation.paramPtrs.code = &code
	mmGetPackageRules.defaultExpectation.expectationOrigins.originCode = minimock.CallerInfo(1)

	return mmGetPackageRules
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.GetPackageRules
func (mmGetPackageRules *mOrderRepositoryMockGetPackageRules) Inspect(f func(ctx context.Context, code string)) *mOrderRepositoryMockGetPackageRules {
	if mmGetPackageRules.mock.inspectFuncGetPackageRules != nil {
		mmGetPackageRules.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.GetPackageRules")
	}

	mmGetPackageRules.mock.inspectFuncGetPackageRules = f

	return mmGetPackageRules
}

// Return sets up results that will be returned by OrderRepository.GetPackageRules
func (mmGetPackageRules *mOrderRepositoryMockGetPackageRules) Return(pa1 []domain.PackageRules, err error) *OrderRepositoryMock {
	if mmGetPackageRules.mock.funcGetPackageRules != nil {
		mmGetPackageRules.mock.t.Fatalf("OrderRepositoryMock.GetPackageRules mock is already set by Set")
	}

	if mmGetPackageRules.defaultExpectation == nil {
		mmGetPackageRules.defaultExpectation = &OrderRepositoryMockGetPackageRulesExpectation{mock: mmGetPackageRules.mock}
	}
	mmGetPackageRules.defaultExpectation.results = &OrderRepositoryMockGetPackageRulesResults{pa1, err}
	mmGetPackageRules.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPackageRules.mock
}

// Set uses given function f to mock the OrderRepository.GetPackageRules method
func (mmGetPackageRules *mOrderRepositoryMockGetPackageRules) Set(f func(ctx context.Context, code string) (pa1 []domain.PackageRules, err error)) *OrderRepositoryMock {
	if mmGetPackageRules.defaultExpectation != nil {
		mmGetPackageRules.mock.t.Fatalf("Default expectation is already set for the OrderRepository.GetPackageRules method")
	}

	if len(mmGetPackageRules.expectations) > 0 {
		mmGetPackageRules.mock.t.Fatalf("Some expectations are already set for the OrderRepository.GetPackageRules method")
	}

	mmGetPackageRules.mock.funcGetPackageRules = f
	mmGetPackageRules.mock.funcGetPackageRulesOrigin = minimock.CallerInfo(1)
	return mmGetPackageRules.mock
}

// When sets expectation for the OrderRepository.GetPackageRules which will trigger the result defined by the following
// Then helper
func (mmGetPackageRules *mOrderRepositoryMockGetPackageRules) When(ctx context.Context, code string) *OrderRepositoryMockGetPackageRulesExpectation {
	if mmGetPackageRules.mock.funcGetPackageRules != nil {
		mmGetPackageRules.mock.t.Fatalf("OrderRepositoryMock.GetPackageRules mock is already set by Set")
	}

	expectation := &OrderRepositoryMockGetPackageRulesExpectation{
		mock:               mmGetPackageRules.mock,
		params:             &OrderRepositoryMockGetPackageRulesParams{ctx, code},
		expectationOrigins: OrderRepositoryMockGetPackageRulesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPackageRules.expectations = append(mmGetPackageRules.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.GetPackageRules return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockGetPackageRulesExpectation) Then(pa1 []domain.PackageRules, err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockGetPackageRulesResults{pa1, err}
	return e.mock
}

// Times sets number of times OrderRepository.GetPackageRules should be invoked
func (mmGetPackageRules *mOrderRepositoryMockGetPackageRules) Times(n uint64) *mOrderRepositoryMockGetPackageRules {
	if n == 0 {
		mmGetPackageRules.mock.t.Fatalf("Times of OrderRepositoryMock.GetPackageRules mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPackageRules.expectedInvocations, n)
	mmGetPackageRules.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPackageRules
}

func (mmGetPackageRules *mOrderRepositoryMockGetPackageRules) invocationsDone() bool {
	if len(mmGetPackageRules.expectations) == 0 && mmGetPackageRules.defaultExpectation == nil && mmGetPackageRules.mock.funcGetPackageRules == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPackageRules.mock.afterGetPackageRulesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPackageRules.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPackageRules implements mm_app.OrderRepository
func (mmGetPackageRules *OrderRepositoryMock) GetPackageRules(ctx context.Context, code string) (pa1 []domain.PackageRules, err error) {
	mm_atomic.AddUint64(&mmGetPackageRules.beforeGetPackageRulesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPackageRules.afterGetPackageRulesCounter, 1)

	mmGetPackageRules.t.Helper()

	if mmGetPackageRules.inspectFuncGetPackageRules != nil {
		mmGetPackageRules.inspectFuncGetPackageRules(ctx, code)
	}

	mm_params := OrderRepositoryMockGetPackageRulesParams{ctx, code}

	// Record call args
	mmGetPackageRules.GetPackageRulesMock.mutex.Lock()
	mmGetPackageRules.GetPackageRulesMock.callArgs = append(mmGetPackageRules.GetPackageRulesMock.callArgs, &mm_params)
	mmGetPackageRules.GetPackageRulesMock.mutex.Unlock()

	for _, e := range mmGetPackageRules.GetPackageRulesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1, e.results.err
		}
	}

	if mmGetPackageRules.GetPackageRulesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPackageRules.GetPackageRulesMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPackageRules.GetPackageRulesMock.defaultExpectation.params
		mm_want_ptrs := mmGetPackageRules.GetPackageRulesMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockGetPackageRulesParams{ctx, code}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPackageRules.t.Errorf("OrderRepositoryMock.GetPackageRules got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPackageRules.GetPackageRulesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.code != nil && !minimock.Equal(*mm_want_ptrs.code, mm_got.code) {
				mmGetPackageRules.t.Errorf("OrderRepositoryMock.GetPackageRules got unexpected parameter code, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPackageRules.GetPackageRulesMock.defaultExpectation.expectationOrigins.originCode, *mm_want_ptrs.code, mm_got.code, minimock.Diff(*mm_want_ptrs.code, mm_got.code))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPackageRules.t.Errorf("OrderRepositoryMock.GetPackageRules got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPackageRules.GetPackageRulesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPackageRules.GetPackageRulesMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPackageRules.t.Fatal("No results are set for the OrderRepositoryMock.GetPackageRules")
		}
		return (*mm_results).pa1, (*mm_results).err
	}
	if mmGetPackageRules.funcGetPackageRules != nil {
		return mmGetPackageRules.funcGetPackageRules(ctx, code)
	}
	mmGetPackageRules.t.Fatalf("Unexpected call to OrderRepositoryMock.GetPackageRules. %v %v", ctx, code)
	return
}

// GetPackageRulesAfterCounter returns a count of finished OrderRepositoryMock.GetPackageRules invocations
func (mmGetPackageRules *OrderRepositoryMock) GetPackageRulesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPackageRules.afterGetPackageRulesCounter)
}

// GetPackageRulesBeforeCounter returns a count of OrderRepositoryMock.GetPackageRules invocations
func (mmGetPackageRules *OrderRepositoryMock) GetPackageRulesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPackageRules.beforeGetPackageRulesCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.GetPackageRules.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPackageRules *mOrderRepositoryMockGetPackageRules) Calls() []*OrderRepositoryMockGetPackageRulesParams {
	mmGetPackageRules.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockGetPackageRulesParams, len(mmGetPackageRules.callArgs))
	copy(argCopy, mmGetPackageRules.callArgs)

	mmGetPackageRules.mutex.RUnlock()

	return argCopy
}

// MinimockGetPackageRulesDone returns true if the count of the GetPackageRules invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockGetPackageRulesDone() bool {
	if m.GetPackageRulesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPackageRulesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPackageRulesMock.invocationsDone()
}

// MinimockGetPackageRulesInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockGetPackageRulesInspect() {
	for _, e := range m.GetPackageRulesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetPackageRules at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPackageRulesCounter := mm_atomic.LoadUint64(&m.afterGetPackageRulesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPackageRulesMock.defaultExpectation != nil && afterGetPackageRulesCounter < 1 {
		if m.GetPackageRulesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetPackageRules at\n%s", m.GetPackageRulesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetPackageRules at\n%s with params: %#v", m.GetPackageRulesMock.defaultExpectation.expectationOrigins.origin, *m.GetPackageRulesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPackageRules != nil && afterGetPackageRulesCounter < 1 {
		m.t.Errorf("Expected call to OrderRepositoryMock.GetPackageRules at\n%s", m.funcGetPackageRulesOrigin)
	}

	if !m.GetPackageRulesMock.invocationsDone() && afterGetPackageRulesCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.GetPackageRules at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPackageRulesMock.expectedInvocations), m.GetPackageRulesMock.expectedInvocationsOrigin, afterGetPackageRulesCounter)
	}
}

type mOrderRepositoryMockGetReturnedOrders struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockGetReturnedOrdersExpectation
	expectations       []*OrderRepositoryMockGetReturnedOrdersExpectation

	callArgs []*OrderRepositoryMockGetReturnedOrdersParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepositoryMockGetReturnedOrdersExpectation specifies expectation struct of the OrderRepository.GetReturnedOrders
type OrderRepositoryMockGetReturnedOrdersExpectation struct {
	mock               *OrderRepositoryMock
	params             *OrderRepositoryMockGetReturnedOrdersParams
	paramPtrs          *OrderRepositoryMockGetReturnedOrdersParamPtrs
	expectationOrigins OrderRepositoryMockGetReturnedOrdersExpectationOrigins
	results            *OrderRepositoryMockGetReturnedOrdersResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepositoryMockGetReturnedOrdersParams contains parameters of the OrderRepository.GetReturnedOrders
type OrderRepositoryMockGetReturnedOrdersParams struct {
	ctx context.Context
}

// OrderRepositoryMockGetReturnedOrdersParamPtrs contains pointers to parameters of the OrderRepository.GetReturnedOrders
type OrderRepositoryMockGetReturnedOrdersParamPtrs struct {
	ctx *context.Context
}

// OrderRepositoryMockGetReturnedOrdersResults contains results of the OrderRepository.GetReturnedOrders
type OrderRepositoryMockGetReturnedOrdersResults struct {
	oa1 []domain.Order
	err error
}

// OrderRepositoryMockGetReturnedOrdersOrigins contains origins of expectations of the OrderRepository.GetReturnedOrders
type OrderRepositoryMockGetReturnedOrdersExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetReturnedOrders *mOrderRepositoryMockGetReturnedOrders) Optional() *mOrderRepositoryMockGetReturnedOrders {
	mmGetReturnedOrders.optional = true
	return mmGetReturnedOrders
}

// Expect sets up expected params for OrderRepository.GetReturnedOrders
func (mmGetReturnedOrders *mOrderRepositoryMockGetReturnedOrders) Expect(ctx context.Context) *mOrderRepositoryMockGetReturnedOrders {
	if mmGetReturnedOrders.mock.funcGetReturnedOrders != nil {
		mmGetReturnedOrders.mock.t.Fatalf("OrderRepositoryMock.GetReturnedOrders mock is already set by Set")
	}

	if mmGetReturnedOrders.defaultExpectation == nil {
		mmGetReturnedOrders.defaultExpectation = &OrderRepositoryMockGetReturnedOrdersExpectation{}
	}

	if mmGetReturnedOrders.defaultExpectation.paramPtrs != nil {
		mmGetReturnedOrders.mock.t.Fatalf("OrderRepositoryMock.GetReturnedOrders mock is already set by ExpectParams functions")
	}

	mmGetReturnedOrders.defaultExpectation.params = &OrderRepositoryMockGetReturnedOrdersParams{ctx}
	mmGetReturnedOrders.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetReturnedOrders.expectations {
		if minimock.Equal(e.params, mmGetReturnedOrders.defaultExpectation.params) {
			mmGetReturnedOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetReturnedOrders.defaultExpectation.params)
		}
	}

	return mmGetReturnedOrders
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepository.GetReturnedOrders
func (mmGetReturnedOrders *mOrderRepositoryMockGetReturnedOrders) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockGetReturnedOrders {
	if mmGetReturnedOrders.mock.funcGetReturnedOrders != nil {
		mmGetReturnedOrders.mock.t.Fatalf("OrderRepositoryMock.GetReturnedOrders mock is already set by Set")
	}

	if mmGetReturnedOrders.defaultExpectation == nil {
		mmGetReturnedOrders.defaultExpectation = &OrderRepositoryMockGetReturnedOrdersExpectation{}
	}

	if mmGetReturnedOrders.defaultExpectation.params != nil {
		mmGetReturnedOrders.mock.t.Fatalf("OrderRepositoryMock.GetReturnedOrders mock is already set by Expect")
	}

	if mmGetReturnedOrders.defaultExpectation.paramPtrs == nil {
		mmGetReturnedOrders.defaultExpectation.paramPtrs = &OrderRepositoryMockGetReturnedOrdersParamPtrs{}
	}
	mmGetReturnedOrders.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetReturnedOrders.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetReturnedOrders
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.GetReturnedOrders
func (mmGetReturnedOrders *mOrderRepositoryMockGetReturnedOrders) Inspect(f func(ctx context.Context)) *mOrderRepositoryMockGetReturnedOrders {
	if mmGetReturnedOrders.mock.inspectFuncGetReturnedOrders != nil {
		mmGetReturnedOrders.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.GetReturnedOrders")
	}

	mmGetReturnedOrders.mock.inspectFuncGetReturnedOrders = f

	return mmGetReturnedOrders
}

// Return sets up results that will be returned by OrderRepository.GetReturnedOrders
func (mmGetReturnedOrders *mOrderRepositoryMockGetReturnedOrders) Return(oa1 []domain.Order, err error) *OrderRepositoryMock {
	if mmGetReturnedOrders.mock.funcGetReturnedOrders != nil {
		mmGetReturnedOrders.mock.t.Fatalf("OrderRepositoryMock.GetReturnedOrders mock is already set by Set")
	}

	if mmGetReturnedOrders.defaultExpectation == nil {
		mmGetReturnedOrders.defaultExpectation = &OrderRepositoryMockGetReturnedOrdersExpectation{mock: mmGetReturnedOrders.mock}
	}
	mmGetReturnedOrders.defaultExpectation.results = &OrderRepositoryMockGetReturnedOrdersResults{oa1, err}
	mmGetReturnedOrders.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetReturnedOrders.mock
}

// Set uses given function f to mock the OrderRepository.GetReturnedOrders method
func (mmGetReturnedOrders *mOrderRepositoryMockGetReturnedOrders) Set(f func(ctx context.Context) (oa1 []domain.Order, err error)) *OrderRepositoryMock {
	if mmGetReturnedOrders.defaultExpectation != nil {
		mmGetReturnedOrders.mock.t.Fatalf("Default expectation is already set for the OrderRepository.GetReturnedOrders method")
	}

	if len(mmGetReturnedOrders.expectations) > 0 {
		mmGetReturnedOrders.mock.t.Fatalf("Some expectations are already set for the OrderRepository.GetReturnedOrders method")
	}

	mmGetReturnedOrders.mock.funcGetReturnedOrders = f
	mmGetReturnedOrders.mock.funcGetReturnedOrdersOrigin = minimock.CallerInfo(1)
	return mmGetReturnedOrders.mock
}

// When sets expectation for the OrderRepository.GetReturnedOrders which will trigger the result defined by the following
// Then helper
func (mmGetReturnedOrders *mOrderRepositoryMockGetReturnedOrders) When(ctx context.Context) *OrderRepositoryMockGetReturnedOrdersExpectation {
	if mmGetReturnedOrders.mock.funcGetReturnedOrders != nil {
		mmGetReturnedOrders.mock.t.Fatalf("OrderRepositoryMock.GetReturnedOrders mock is already set by Set")
	}

	expectation := &OrderRepositoryMockGetReturnedOrdersExpectation{
		mock:               mmGetReturnedOrders.mock,
		params:             &OrderRepositoryMockGetReturnedOrdersParams{ctx},
		expectationOrigins: OrderRepositoryMockGetReturnedOrdersExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetReturnedOrders.expectations = append(mmGetReturnedOrders.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.GetReturnedOrders return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockGetReturnedOrdersExpectation) Then(oa1 []domain.Order, err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockGetReturnedOrdersResults{oa1, err}
	return e.mock
}

// Times sets number of times OrderRepository.GetReturnedOrders should be invoked
func (mmGetReturnedOrders *mOrderRepositoryMockGetReturnedOrders) Times(n uint64) *mOrderRepositoryMockGetReturnedOrders {
	if n == 0 {
		mmGetReturnedOrders.mock.t.Fatalf("Times of OrderRepositoryMock.GetReturnedOrders mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetReturnedOrders.expectedInvocations, n)
	mmGetReturnedOrders.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetReturnedOrders
}

func (mmGetReturnedOrders *mOrderRepositoryMockGetReturnedOrders) invocationsDone() bool {
	if len(mmGetReturnedOrders.expectations) == 0 && mmGetReturnedOrders.defaultExpectation == nil && mmGetReturnedOrders.mock.funcGetReturnedOrders == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetReturnedOrders.mock.afterGetReturnedOrdersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetReturnedOrders.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetReturnedOrders implements mm_app.OrderRepository
func (mmGetReturnedOrders *OrderRepositoryMock) GetReturnedOrders(ctx context.Context) (oa1 []domain.Order, err error) {
	mm_atomic.AddUint64(&mmGetReturnedOrders.beforeGetReturnedOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmGetReturnedOrders.afterGetReturnedOrdersCounter, 1)

	mmGetReturnedOrders.t.Helper()

	if mmGetReturnedOrders.inspectFuncGetReturnedOrders != nil {
		mmGetReturnedOrders.inspectFuncGetReturnedOrders(ctx)
	}

	mm_params := OrderRepositoryMockGetReturnedOrdersParams{ctx}

	// Record call args
	mmGetReturnedOrders.GetReturnedOrdersMock.mutex.Lock()
	mmGetReturnedOrders.GetReturnedOrdersMock.callArgs = append(mmGetReturnedOrders.GetReturnedOrdersMock.callArgs, &mm_params)
	mmGetReturnedOrders.GetReturnedOrdersMock.mutex.Unlock()

	for _, e := range mmGetReturnedOrders.GetReturnedOrdersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmGetReturnedOrders.GetReturnedOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetReturnedOrders.GetReturnedOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmGetReturnedOrders.GetReturnedOrdersMock.defaultExpectation.params
		mm_want_ptrs := mmGetReturnedOrders.GetReturnedOrdersMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockGetReturnedOrdersParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetReturnedOrders.t.Errorf("OrderRepositoryMock.GetReturnedOrders got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetReturnedOrders.GetReturnedOrdersMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetReturnedOrders.t.Errorf("OrderRepositoryMock.GetReturnedOrders got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetReturnedOrders.GetReturnedOrdersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetReturnedOrders.GetReturnedOrdersMock.defaultExpectation.results
		if mm_results == nil {
			mmGetReturnedOrders.t.Fatal("No results are set for the OrderRepositoryMock.GetReturnedOrders")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmGetReturnedOrders.funcGetReturnedOrders != nil {
		return mmGetReturnedOrders.funcGetReturnedOrders(ctx)
	}
	mmGetReturnedOrders.t.Fatalf("Unexpected call to OrderRepositoryMock.GetReturnedOrders. %v", ctx)
	return
}

// GetReturnedOrdersAfterCounter returns a count of finished OrderRepositoryMock.GetReturnedOrders invocations
func (mmGetReturnedOrders *OrderRepositoryMock) GetReturnedOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReturnedOrders.afterGetReturnedOrdersCounter)
}

// GetReturnedOrdersBeforeCounter returns a count of OrderRepositoryMock.GetReturnedOrders invocations
func (mmGetReturnedOrders *OrderRepositoryMock) GetReturnedOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReturnedOrders.beforeGetReturnedOrdersCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.GetReturnedOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetReturnedOrders *mOrderRepositoryMockGetReturnedOrders) Calls() []*OrderRepositoryMockGetReturnedOrdersParams {
	mmGetReturnedOrders.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockGetReturnedOrdersParams, len(mmGetReturnedOrders.callArgs))
	copy(argCopy, mmGetReturnedOrders.callArgs)

	mmGetReturnedOrders.mutex.RUnlock()

	return argCopy
}

// MinimockGetReturnedOrdersDone returns true if the count of the GetReturnedOrders invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockGetReturnedOrdersDone() bool {
	if m.GetReturnedOrdersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetReturnedOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetReturnedOrdersMock.invocationsDone()
}

// MinimockGetReturnedOrdersInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockGetReturnedOrdersInspect() {
	for _, e := range m.GetReturnedOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetReturnedOrders at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetReturnedOrdersCounter := mm_atomic.LoadUint64(&m.afterGetReturnedOrdersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetReturnedOrdersMock.defaultExpectation != nil && afterGetReturnedOrdersCounter < 1 {
		if m.GetReturnedOrdersMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetReturnedOrders at\n%s", m.GetReturnedOrdersMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetReturnedOrders at\n%s with params: %#v", m.GetReturnedOrdersMock.defaultExpectation.expectationOrigins.origin, *m.GetReturnedOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetReturnedOrders != nil && afterGetReturnedOrdersCounter < 1 {
		m.t.Errorf("Expected call to OrderRepositoryMock.GetReturnedOrders at\n%s", m.funcGetReturnedOrdersOrigin)
	}

	if !m.GetReturnedOrdersMock.invocationsDone() && afterGetReturnedOrdersCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.GetReturnedOrders at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetReturnedOrdersMock.expectedInvocations), m.GetReturnedOrdersMock.expectedInvocationsOrigin, afterGetReturnedOrdersCounter)
	}
}

type mOrderRepositoryMockSave struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockSaveExpectation
	expectations       []*OrderRepositoryMockSaveExpectation

	callArgs []*OrderRepositoryMockSaveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepositoryMockSaveExpectation specifies expectation struct of the OrderRepository.Save
type OrderRepositoryMockSaveExpectation struct {
	mock               *OrderRepositoryMock
	params             *OrderRepositoryMockSaveParams
	paramPtrs          *OrderRepositoryMockSaveParamPtrs
	expectationOrigins OrderRepositoryMockSaveExpectationOrigins
	results            *OrderRepositoryMockSaveResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepositoryMockSaveParams contains parameters of the OrderRepository.Save
type OrderRepositoryMockSaveParams struct {
	ctx   context.Context
	order domain.Order
}

// OrderRepositoryMockSaveParamPtrs contains pointers to parameters of the OrderRepository.Save
type OrderRepositoryMockSaveParamPtrs struct {
	ctx   *context.Context
	order *domain.Order
}

// OrderRepositoryMockSaveResults contains results of the OrderRepository.Save
type OrderRepositoryMockSaveResults struct {
	err error
}

// OrderRepositoryMockSaveOrigins contains origins of expectations of the OrderRepository.Save
type OrderRepositoryMockSaveExpectationOrigins struct {
	origin      string
	originCtx   string
	originOrder string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSave *mOrderRepositoryMockSave) Optional() *mOrderRepositoryMockSave {
	mmSave.optional = true
	return mmSave
}

// Expect sets up expected params for OrderRepository.Save
func (mmSave *mOrderRepositoryMockSave) Expect(ctx context.Context, order domain.Order) *mOrderRepositoryMockSave {
	if mmSave.mock.funcSave != nil {
		mmSave.mock.t.Fatalf("OrderRepositoryMock.Save mock is already set by Set")
	}

	if mmSave.defaultExpectation == nil {
		mmSave.defaultExpectation = &OrderRepositoryMockSaveExpectation{}
	}

	if mmSave.defaultExpectation.paramPtrs != nil {
		mmSave.mock.t.Fatalf("OrderRepositoryMock.Save mock is already set by ExpectParams functions")
	}

	mmSave.defaultExpectation.params = &OrderRepositoryMockSaveParams{ctx, order}
	mmSave.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSave.expectations {
		if minimock.Equal(e.params, mmSave.defaultExpectation.params) {
			mmSave.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSave.defaultExpectation.params)
		}
	}

	return mmSave
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepository.Save
func (mmSave *mOrderRepositoryMockSave) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockSave {
	if mmSave.mock.funcSave != nil {
		mmSave.mock.t.Fatalf("OrderRepositoryMock.Save mock is already set by Set")
	}

	if mmSave.defaultExpectation == nil {
		mmSave.defaultExpectation = &OrderRepositoryMockSaveExpectation{}
	}

	if mmSave.defaultExpectation.params != nil {
		mmSave.mock.t.Fatalf("OrderRepositoryMock.Save mock is already set by Expect")
	}

	if mmSave.defaultExpectation.paramPtrs == nil {
		mmSave.defaultExpectation.paramPtrs = &OrderRepositoryMockSaveParamPtrs{}
	}
	mmSave.defaultExpectation.paramPtrs.ctx = &ctx
	mmSave.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSave
}

// ExpectOrderParam2 sets up expected param order for OrderRepository.Save
func (mmSave *mOrderRepositoryMockSave) ExpectOrderParam2(order domain.Order) *mOrderRepositoryMockSave {
	if mmSave.mock.funcSave != nil {
		mmSave.mock.t.Fatalf("OrderRepositoryMock.Save mock is already set by Set")
	}

	if mmSave.defaultExpectation == nil {
		mmSave.defaultExpectation = &OrderRepositoryMockSaveExpectation{}
	}

	if mmSave.defaultExpectation.params != nil {
		mmSave.mock.t.Fatalf("OrderRepositoryMock.Save mock is already set by Expect")
	}

	if mmSave.defaultExpectation.paramPtrs == nil {
		mmSave.defaultExpectation.paramPtrs = &OrderRepositoryMockSaveParamPtrs{}
	}
	mmSave.defaultExpectation.paramPtrs.order = &order
	mmSave.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmSave
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.Save
func (mmSave *mOrderRepositoryMockSave) Inspect(f func(ctx context.Context, order domain.Order)) *mOrderRepositoryMockSave {
	if mmSave.mock.inspectFuncSave != nil {
		mmSave.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.Save")
	}

	mmSave.mock.inspectFuncSave = f

	return mmSave
}

// Return sets up results that will be returned by OrderRepository.Save
func (mmSave *mOrderRepositoryMockSave) Return(err error) *OrderRepositoryMock {
	if mmSave.mock.funcSave != nil {
		mmSave.mock.t.Fatalf("OrderRepositoryMock.Save mock is already set by Set")
	}

	if mmSave.defaultExpectation == nil {
		mmSave.defaultExpectation = &OrderRepositoryMockSaveExpectation{mock: mmSave.mock}
	}
	mmSave.defaultExpectation.results = &OrderRepositoryMockSaveResults{err}
	mmSave.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSave.mock
}

// Set uses given function f to mock the OrderRepository.Save method
func (mmSave *mOrderRepositoryMockSave) Set(f func(ctx context.Context, order domain.Order) (err error)) *OrderRepositoryMock {
	if mmSave.defaultExpectation != nil {
		mmSave.mock.t.Fatalf("Default expectation is already set for the OrderRepository.Save method")
	}

	if len(mmSave.expectations) > 0 {
		mmSave.mock.t.Fatalf("Some expectations are already set for the OrderRepository.Save method")
	}

	mmSave.mock.funcSave = f
	mmSave.mock.funcSaveOrigin = minimock.CallerInfo(1)
	return mmSave.mock
}

// When sets expectation for the OrderRepository.Save which will trigger the result defined by the following
// Then helper
func (mmSave *mOrderRepositoryMockSave) When(ctx context.Context, order domain.Order) *OrderRepositoryMockSaveExpectation {
	if mmSave.mock.funcSave != nil {
		mmSave.mock.t.Fatalf("OrderRepositoryMock.Save mock is already set by Set")
	}

	expectation := &OrderRepositoryMockSaveExpectation{
		mock:               mmSave.mock,
		params:             &OrderRepositoryMockSaveParams{ctx, order},
		expectationOrigins: OrderRepositoryMockSaveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSave.expectations = append(mmSave.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.Save return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockSaveExpectation) Then(err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockSaveResults{err}
	return e.mock
}

// Times sets number of times OrderRepository.Save should be invoked
func (mmSave *mOrderRepositoryMockSave) Times(n uint64) *mOrderRepositoryMockSave {
	if n == 0 {
		mmSave.mock.t.Fatalf("Times of OrderRepositoryMock.Save mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSave.expectedInvocations, n)
	mmSave.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSave
}

func (mmSave *mOrderRepositoryMockSave) invocationsDone() bool {
	if len(mmSave.expectations) == 0 && mmSave.defaultExpectation == nil && mmSave.mock.funcSave == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSave.mock.afterSaveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSave.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Save implements mm_app.OrderRepository
func (mmSave *OrderRepositoryMock) Save(ctx context.Context, order domain.Order) (err error) {
	mm_atomic.AddUint64(&mmSave.beforeSaveCounter, 1)
	defer mm_atomic.AddUint64(&mmSave.afterSaveCounter, 1)

	mmSave.t.Helper()

	if mmSave.inspectFuncSave != nil {
		mmSave.inspectFuncSave(ctx, order)
	}

	mm_params := OrderRepositoryMockSaveParams{ctx, order}

	// Record call args
	mmSave.SaveMock.mutex.Lock()
	mmSave.SaveMock.callArgs = append(mmSave.SaveMock.callArgs, &mm_params)
	mmSave.SaveMock.mutex.Unlock()

	for _, e := range mmSave.SaveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSave.SaveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSave.SaveMock.defaultExpectation.Counter, 1)
		mm_want := mmSave.SaveMock.defaultExpectation.params
		mm_want_ptrs := mmSave.SaveMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockSaveParams{ctx, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSave.t.Errorf("OrderRepositoryMock.Save got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSave.SaveMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmSave.t.Errorf("OrderRepositoryMock.Save got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSave.SaveMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSave.t.Errorf("OrderRepositoryMock.Save got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSave.SaveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSave.SaveMock.defaultExpectation.results
		if mm_results == nil {
			mmSave.t.Fatal("No results are set for the OrderRepositoryMock.Save")
		}
		return (*mm_results).err
	}
	if mmSave.funcSave != nil {
		return mmSave.funcSave(ctx, order)
	}
	mmSave.t.Fatalf("Unexpected call to OrderRepositoryMock.Save. %v %v", ctx, order)
	return
}

// SaveAfterCounter returns a count of finished OrderRepositoryMock.Save invocations
func (mmSave *OrderRepositoryMock) SaveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSave.afterSaveCounter)
}

// SaveBeforeCounter returns a count of OrderRepositoryMock.Save invocations
func (mmSave *OrderRepositoryMock) SaveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSave.beforeSaveCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.Save.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSave *mOrderRepositoryMockSave) Calls() []*OrderRepositoryMockSaveParams {
	mmSave.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockSaveParams, len(mmSave.callArgs))
	copy(argCopy, mmSave.callArgs)

	mmSave.mutex.RUnlock()

	return argCopy
}

// MinimockSaveDone returns true if the count of the Save invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockSaveDone() bool {
	if m.SaveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SaveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SaveMock.invocationsDone()
}

// MinimockSaveInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockSaveInspect() {
	for _, e := range m.SaveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.Save at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSaveCounter := mm_atomic.LoadUint64(&m.afterSaveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SaveMock.defaultExpectation != nil && afterSaveCounter < 1 {
		if m.SaveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepositoryMock.Save at\n%s", m.SaveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.Save at\n%s with params: %#v", m.SaveMock.defaultExpectation.expectationOrigins.origin, *m.SaveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSave != nil && afterSaveCounter < 1 {
		m.t.Errorf("Expected call to OrderRepositoryMock.Save at\n%s", m.funcSaveOrigin)
	}

	if !m.SaveMock.invocationsDone() && afterSaveCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.Save at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SaveMock.expectedInvocations), m.SaveMock.expectedInvocationsOrigin, afterSaveCounter)
	}
}

type mOrderRepositoryMockSaveHistory struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockSaveHistoryExpectation
	expectations       []*OrderRepositoryMockSaveHistoryExpectation

	callArgs []*OrderRepositoryMockSaveHistoryParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepositoryMockSaveHistoryExpectation specifies expectation struct of the OrderRepository.SaveHistory
type OrderRepositoryMockSaveHistoryExpectation struct {
	mock               *OrderRepositoryMock
	params             *OrderRepositoryMockSaveHistoryParams
	paramPtrs          *OrderRepositoryMockSaveHistoryParamPtrs
	expectationOrigins OrderRepositoryMockSaveHistoryExpectationOrigins
	results            *OrderRepositoryMockSaveHistoryResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepositoryMockSaveHistoryParams contains parameters of the OrderRepository.SaveHistory
type OrderRepositoryMockSaveHistoryParams struct {
	ctx     context.Context
	history domain.OrderHistory
}

// OrderRepositoryMockSaveHistoryParamPtrs contains pointers to parameters of the OrderRepository.SaveHistory
type OrderRepositoryMockSaveHistoryParamPtrs struct {
	ctx     *context.Context
	history *domain.OrderHistory
}

// OrderRepositoryMockSaveHistoryResults contains results of the OrderRepository.SaveHistory
type OrderRepositoryMockSaveHistoryResults struct {
	err error
}

// OrderRepositoryMockSaveHistoryOrigins contains origins of expectations of the OrderRepository.SaveHistory
type OrderRepositoryMockSaveHistoryExpectationOrigins struct {
	origin        string
	originCtx     string
	originHistory string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSaveHistory *mOrderRepositoryMockSaveHistory) Optional() *mOrderRepositoryMockSaveHistory {
	mmSaveHistory.optional = true
	return mmSaveHistory
}

// Expect sets up expected params for OrderRepository.SaveHistory
func (mmSaveHistory *mOrderRepositoryMockSaveHistory) Expect(ctx context.Context, history domain.OrderHistory) *mOrderRepositoryMockSaveHistory {
	if mmSaveHistory.mock.funcSaveHistory != nil {
		mmSaveHistory.mock.t.Fatalf("OrderRepositoryMock.SaveHistory mock is already set by Set")
	}

	if mmSaveHistory.defaultExpectation == nil {
		mmSaveHistory.defaultExpectation = &OrderRepositoryMockSaveHistoryExpectation{}
	}

	if mmSaveHistory.defaultExpectation.paramPtrs != nil {
		mmSaveHistory.mock.t.Fatalf("OrderRepositoryMock.SaveHistory mock is already set by ExpectParams functions")
	}

	mmSaveHistory.defaultExpectation.params = &OrderRepositoryMockSaveHistoryParams{ctx, history}
	mmSaveHistory.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSaveHistory.expectations {
		if minimock.Equal(e.params, mmSaveHistory.defaultExpectation.params) {
			mmSaveHistory.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveHistory.defaultExpectation.params)
		}
	}

	return mmSaveHistory
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepository.SaveHistory
func (mmSaveHistory *mOrderRepositoryMockSaveHistory) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockSaveHistory {
	if mmSaveHistory.mock.funcSaveHistory != nil {
		mmSaveHistory.mock.t.Fatalf("OrderRepositoryMock.SaveHistory mock is already set by Set")
	}

	if mmSaveHistory.defaultExpectation == nil {
		mmSaveHistory.defaultExpectation = &OrderRepositoryMockSaveHistoryExpectation{}
	}

	if mmSaveHistory.defaultExpectation.params != nil {
		mmSaveHistory.mock.t.Fatalf("OrderRepositoryMock.SaveHistory mock is already set by Expect")
	}

	if mmSaveHistory.defaultExpectation.paramPtrs == nil {
		mmSaveHistory.defaultExpectation.paramPtrs = &OrderRepositoryMockSaveHistoryParamPtrs{}
	}
	mmSaveHistory.defaultExpectation.paramPtrs.ctx = &ctx
	mmSaveHistory.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSaveHistory
}

// ExpectHistoryParam2 sets up expected param history for OrderRepository.SaveHistory
func (mmSaveHistory *mOrderRepositoryMockSaveHistory) ExpectHistoryParam2(history domain.OrderHistory) *mOrderRepositoryMockSaveHistory {
	if mmSaveHistory.mock.funcSaveHistory != nil {
		mmSaveHistory.mock.t.Fatalf("OrderRepositoryMock.SaveHistory mock is already set by Set")
	}

	if mmSaveHistory.defaultExpectation == nil {
		mmSaveHistory.defaultExpectation = &OrderRepositoryMockSaveHistoryExpectation{}
	}

	if mmSaveHistory.defaultExpectation.params != nil {
		mmSaveHistory.mock.t.Fatalf("OrderRepositoryMock.SaveHistory mock is already set by Expect")
	}

	if mmSaveHistory.defaultExpectation.paramPtrs == nil {
		mmSaveHistory.defaultExpectation.paramPtrs = &OrderRepositoryMockSaveHistoryParamPtrs{}
	}
	mmSaveHistory.defaultExpectation.paramPtrs.history = &history
	mmSaveHistory.defaultExpectation.expectationOrigins.originHistory = minimock.CallerInfo(1)

	return mmSaveHistory
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.SaveHistory
func (mmSaveHistory *mOrderRepositoryMockSaveHistory) Inspect(f func(ctx context.Context, history domain.OrderHistory)) *mOrderRepositoryMockSaveHistory {
	if mmSaveHistory.mock.inspectFuncSaveHistory != nil {
		mmSaveHistory.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.SaveHistory")
	}

	mmSaveHistory.mock.inspectFuncSaveHistory = f

	return mmSaveHistory
}

// Return sets up results that will be returned by OrderRepository.SaveHistory
func (mmSaveHistory *mOrderRepositoryMockSaveHistory) Return(err error) *OrderRepositoryMock {
	if mmSaveHistory.mock.funcSaveHistory != nil {
		mmSaveHistory.mock.t.Fatalf("OrderRepositoryMock.SaveHistory mock is already set by Set")
	}

	if mmSaveHistory.defaultExpectation == nil {
		mmSaveHistory.defaultExpectation = &OrderRepositoryMockSaveHistoryExpectation{mock: mmSaveHistory.mock}
	}
	mmSaveHistory.defaultExpectation.results = &OrderRepositoryMockSaveHistoryResults{err}
	mmSaveHistory.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSaveHistory.mock
}

// Set uses given function f to mock the OrderRepository.SaveHistory method
func (mmSaveHistory *mOrderRepositoryMockSaveHistory) Set(f func(ctx context.Context, history domain.OrderHistory) (err error)) *OrderRepositoryMock {
	if mmSaveHistory.defaultExpectation != nil {
		mmSaveHistory.mock.t.Fatalf("Default expectation is already set for the OrderRepository.SaveHistory method")
	}

	if len(mmSaveHistory.expectations) > 0 {
		mmSaveHistory.mock.t.Fatalf("Some expectations are already set for the OrderRepository.SaveHistory method")
	}

	mmSaveHistory.mock.funcSaveHistory = f
	mmSaveHistory.mock.funcSaveHistoryOrigin = minimock.CallerInfo(1)
	return mmSaveHistory.mock
}

// When sets expectation for the OrderRepository.SaveHistory which will trigger the result defined by the following
// Then helper
func (mmSaveHistory *mOrderRepositoryMockSaveHistory) When(ctx context.Context, history domain.OrderHistory) *OrderRepositoryMockSaveHistoryExpectation {
	if mmSaveHistory.mock.funcSaveHistory != nil {
		mmSaveHistory.mock.t.Fatalf("OrderRepositoryMock.SaveHistory mock is already set by Set")
	}

	expectation := &OrderRepositoryMockSaveHistoryExpectation{
		mock:               mmSaveHistory.mock,
		params:             &OrderRepositoryMockSaveHistoryParams{ctx, history},
		expectationOrigins: OrderRepositoryMockSaveHistoryExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSaveHistory.expectations = append(mmSaveHistory.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.SaveHistory return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockSaveHistoryExpectation) Then(err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockSaveHistoryResults{err}
	return e.mock
}

// Times sets number of times OrderRepository.SaveHistory should be invoked
func (mmSaveHistory *mOrderRepositoryMockSaveHistory) Times(n uint64) *mOrderRepositoryMockSaveHistory {
	if n == 0 {
		mmSaveHistory.mock.t.Fatalf("Times of OrderRepositoryMock.SaveHistory mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSaveHistory.expectedInvocations, n)
	mmSaveHistory.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSaveHistory
}

func (mmSaveHistory *mOrderRepositoryMockSaveHistory) invocationsDone() bool {
	if len(mmSaveHistory.expectations) == 0 && mmSaveHistory.defaultExpectation == nil && mmSaveHistory.mock.funcSaveHistory == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSaveHistory.mock.afterSaveHistoryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSaveHistory.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SaveHistory implements mm_app.OrderRepository
func (mmSaveHistory *OrderRepositoryMock) SaveHistory(ctx context.Context, history domain.OrderHistory) (err error) {
	mm_atomic.AddUint64(&mmSaveHistory.beforeSaveHistoryCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveHistory.afterSaveHistoryCounter, 1)

	mmSaveHistory.t.Helper()

	if mmSaveHistory.inspectFuncSaveHistory != nil {
		mmSaveHistory.inspectFuncSaveHistory(ctx, history)
	}

	mm_params := OrderRepositoryMockSaveHistoryParams{ctx, history}

	// Record call args
	mmSaveHistory.SaveHistoryMock.mutex.Lock()
	mmSaveHistory.SaveHistoryMock.callArgs = append(mmSaveHistory.SaveHistoryMock.callArgs, &mm_params)
	mmSaveHistory.SaveHistoryMock.mutex.Unlock()

	for _, e := range mmSaveHistory.SaveHistoryMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSaveHistory.SaveHistoryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveHistory.SaveHistoryMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveHistory.SaveHistoryMock.defaultExpectation.params
		mm_want_ptrs := mmSaveHistory.SaveHistoryMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockSaveHistoryParams{ctx, history}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSaveHistory.t.Errorf("OrderRepositoryMock.SaveHistory got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveHistory.SaveHistoryMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.history != nil && !minimock.Equal(*mm_want_ptrs.history, mm_got.history) {
				mmSaveHistory.t.Errorf("OrderRepositoryMock.SaveHistory got unexpected parameter history, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveHistory.SaveHistoryMock.defaultExpectation.expectationOrigins.originHistory, *mm_want_ptrs.history, mm_got.history, minimock.Diff(*mm_want_ptrs.history, mm_got.history))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveHistory.t.Errorf("OrderRepositoryMock.SaveHistory got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSaveHistory.SaveHistoryMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveHistory.SaveHistoryMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveHistory.t.Fatal("No results are set for the OrderRepositoryMock.SaveHistory")
		}
		return (*mm_results).err
	}
	if mmSaveHistory.funcSaveHistory != nil {
		return mmSaveHistory.funcSaveHistory(ctx, history)
	}
	mmSaveHistory.t.Fatalf("Unexpected call to OrderRepositoryMock.SaveHistory. %v %v", ctx, history)
	return
}

// SaveHistoryAfterCounter returns a count of finished OrderRepositoryMock.SaveHistory invocations
func (mmSaveHistory *OrderRepositoryMock) SaveHistoryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveHistory.afterSaveHistoryCounter)
}

// SaveHistoryBeforeCounter returns a count of OrderRepositoryMock.SaveHistory invocations
func (mmSaveHistory *OrderRepositoryMock) SaveHistoryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveHistory.beforeSaveHistoryCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.SaveHistory.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveHistory *mOrderRepositoryMockSaveHistory) Calls() []*OrderRepositoryMockSaveHistoryParams {
	mmSaveHistory.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockSaveHistoryParams, len(mmSaveHistory.callArgs))
	copy(argCopy, mmSaveHistory.callArgs)

	mmSaveHistory.mutex.RUnlock()

	return argCopy
}

// MinimockSaveHistoryDone returns true if the count of the SaveHistory invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockSaveHistoryDone() bool {
	if m.SaveHistoryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SaveHistoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SaveHistoryMock.invocationsDone()
}

// MinimockSaveHistoryInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockSaveHistoryInspect() {
	for _, e := range m.SaveHistoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.SaveHistory at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSaveHistoryCounter := mm_atomic.LoadUint64(&m.afterSaveHistoryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SaveHistoryMock.defaultExpectation != nil && afterSaveHistoryCounter < 1 {
		if m.SaveHistoryMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepositoryMock.SaveHistory at\n%s", m.SaveHistoryMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.SaveHistory at\n%s with params: %#v", m.SaveHistoryMock.defaultExpectation.expectationOrigins.origin, *m.SaveHistoryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveHistory != nil && afterSaveHistoryCounter < 1 {
		m.t.Errorf("Expected call to OrderRepositoryMock.SaveHistory at\n%s", m.funcSaveHistoryOrigin)
	}

	if !m.SaveHistoryMock.invocationsDone() && afterSaveHistoryCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.SaveHistory at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SaveHistoryMock.expectedInvocations), m.SaveHistoryMock.expectedInvocationsOrigin, afterSaveHistoryCounter)
	}
}

type mOrderRepositoryMockUpdate struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockUpdateExpectation
	expectations       []*OrderRepositoryMockUpdateExpectation

	callArgs []*OrderRepositoryMockUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepositoryMockUpdateExpectation specifies expectation struct of the OrderRepository.Update
type OrderRepositoryMockUpdateExpectation struct {
	mock               *OrderRepositoryMock
	params             *OrderRepositoryMockUpdateParams
	paramPtrs          *OrderRepositoryMockUpdateParamPtrs
	expectationOrigins OrderRepositoryMockUpdateExpectationOrigins
	results            *OrderRepositoryMockUpdateResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepositoryMockUpdateParams contains parameters of the OrderRepository.Update
type OrderRepositoryMockUpdateParams struct {
	ctx   context.Context
	order domain.Order
}

// OrderRepositoryMockUpdateParamPtrs contains pointers to parameters of the OrderRepository.Update
type OrderRepositoryMockUpdateParamPtrs struct {
	ctx   *context.Context
	order *domain.Order
}

// OrderRepositoryMockUpdateResults contains results of the OrderRepository.Update
type OrderRepositoryMockUpdateResults struct {
	err error
}

// OrderRepositoryMockUpdateOrigins contains origins of expectations of the OrderRepository.Update
type OrderRepositoryMockUpdateExpectationOrigins struct {
	origin      string
	originCtx   string
	originOrder string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mOrderRepositoryMockUpdate) Optional() *mOrderRepositoryMockUpdate {
	mmUpdate.optional = true
	return mmUpdate
}

// Expect sets up expected params for OrderRepository.Update
func (mmUpdate *mOrderRepositoryMockUpdate) Expect(ctx context.Context, order domain.Order) *mOrderRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("OrderRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &OrderRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.paramPtrs != nil {
		mmUpdate.mock.t.Fatalf("OrderRepositoryMock.Update mock is already set by ExpectParams functions")
	}

	mmUpdate.defaultExpectation.params = &OrderRepositoryMockUpdateParams{ctx, order}
	mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepository.Update
func (mmUpdate *mOrderRepositoryMockUpdate) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("OrderRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &OrderRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("OrderRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &OrderRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectOrderParam2 sets up expected param order for OrderRepository.Update
func (mmUpdate *mOrderRepositoryMockUpdate) ExpectOrderParam2(order domain.Order) *mOrderRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("OrderRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &OrderRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("OrderRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &OrderRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.order = &order
	mmUpdate.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.Update
func (mmUpdate *mOrderRepositoryMockUpdate) Inspect(f func(ctx context.Context, order domain.Order)) *mOrderRepositoryMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by OrderRepository.Update
func (mmUpdate *mOrderRepositoryMockUpdate) Return(err error) *OrderRepositoryMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("OrderRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &OrderRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &OrderRepositoryMockUpdateResults{err}
	mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// Set uses given function f to mock the OrderRepository.Update method
func (mmUpdate *mOrderRepositoryMockUpdate) Set(f func(ctx context.Context, order domain.Order) (err error)) *OrderRepositoryMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the OrderRepository.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the OrderRepository.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// When sets expectation for the OrderRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mOrderRepositoryMockUpdate) When(ctx context.Context, order domain.Order) *OrderRepositoryMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("OrderRepositoryMock.Update mock is already set by Set")
	}

	expectation := &OrderRepositoryMockUpdateExpectation{
		mock:               mmUpdate.mock,
		params:             &OrderRepositoryMockUpdateParams{ctx, order},
		expectationOrigins: OrderRepositoryMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.Update return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockUpdateExpectation) Then(err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockUpdateResults{err}
	return e.mock
}

// Times sets number of times OrderRepository.Update should be invoked
func (mmUpdate *mOrderRepositoryMockUpdate) Times(n uint64) *mOrderRepositoryMockUpdate {
	if n == 0 {
		mmUpdate.mock.t.Fatalf("Times of OrderRepositoryMock.Update mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdate.expectedInvocations, n)
	mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdate
}

func (mmUpdate *mOrderRepositoryMockUpdate) invocationsDone() bool {
	if len(mmUpdate.expectations) == 0 && mmUpdate.defaultExpectation == nil && mmUpdate.mock.funcUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdate.mock.afterUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Update implements mm_app.OrderRepository
func (mmUpdate *OrderRepositoryMock) Update(ctx context.Context, order domain.Order) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	mmUpdate.t.Helper()

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, order)
	}

	mm_params := OrderRepositoryMockUpdateParams{ctx, order}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockUpdateParams{ctx, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdate.t.Errorf("OrderRepositoryMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmUpdate.t.Errorf("OrderRepositoryMock.Update got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("OrderRepositoryMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the OrderRepositoryMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, order)
	}
	mmUpdate.t.Fatalf("Unexpected call to OrderRepositoryMock.Update. %v %v", ctx, order)
	return
}

// UpdateAfterCounter returns a count of finished OrderRepositoryMock.Update invocations
func (mmUpdate *OrderRepositoryMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of OrderRepositoryMock.Update invocations
func (mmUpdate *OrderRepositoryMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mOrderRepositoryMockUpdate) Calls() []*OrderRepositoryMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockUpdateDone() bool {
	if m.UpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMock.invocationsDone()
}

// MinimockUpdateInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCounter := mm_atomic.LoadUint64(&m.afterUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && afterUpdateCounter < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepositoryMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && afterUpdateCounter < 1 {
		m.t.Errorf("Expected call to OrderRepositoryMock.Update at\n%s", m.funcUpdateOrigin)
	}

	if !m.UpdateMock.invocationsDone() && afterUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.Update at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OrderRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetAllOrdersInspect()

			m.MinimockGetByIDInspect()

			m.MinimockGetByReceiverIDInspect()

			m.MinimockGetHistoryByOrderIDInspect()

			m.MinimockGetPackageRulesInspect()

			m.MinimockGetReturnedOrdersInspect()

			m.MinimockSaveInspect()

			m.MinimockSaveHistoryInspect()

			m.MinimockUpdateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OrderRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OrderRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetAllOrdersDone() &&
		m.MinimockGetByIDDone() &&
		m.MinimockGetByReceiverIDDone() &&
		m.MinimockGetHistoryByOrderIDDone() &&
		m.MinimockGetPackageRulesDone() &&
		m.MinimockGetReturnedOrdersDone() &&
		m.MinimockSaveDone() &&
		m.MinimockSaveHistoryDone() &&
		m.MinimockUpdateDone()
}
