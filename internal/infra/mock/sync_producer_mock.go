// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

//go:generate minimock -i github.com/IBM/sarama.SyncProducer -o sync_producer_mock_test.go -n SyncProducerMock -p mock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	mm_sarama "github.com/IBM/sarama"
	"github.com/gojuno/minimock/v3"
)

// SyncProducerMock implements mm_sarama.SyncProducer
type SyncProducerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAbortTxn          func() (err error)
	funcAbortTxnOrigin    string
	inspectFuncAbortTxn   func()
	afterAbortTxnCounter  uint64
	beforeAbortTxnCounter uint64
	AbortTxnMock          mSyncProducerMockAbortTxn

	funcAddMessageToTxn          func(msg *mm_sarama.ConsumerMessage, groupId string, metadata *string) (err error)
	funcAddMessageToTxnOrigin    string
	inspectFuncAddMessageToTxn   func(msg *mm_sarama.ConsumerMessage, groupId string, metadata *string)
	afterAddMessageToTxnCounter  uint64
	beforeAddMessageToTxnCounter uint64
	AddMessageToTxnMock          mSyncProducerMockAddMessageToTxn

	funcAddOffsetsToTxn          func(offsets map[string][]*mm_sarama.PartitionOffsetMetadata, groupId string) (err error)
	funcAddOffsetsToTxnOrigin    string
	inspectFuncAddOffsetsToTxn   func(offsets map[string][]*mm_sarama.PartitionOffsetMetadata, groupId string)
	afterAddOffsetsToTxnCounter  uint64
	beforeAddOffsetsToTxnCounter uint64
	AddOffsetsToTxnMock          mSyncProducerMockAddOffsetsToTxn

	funcBeginTxn          func() (err error)
	funcBeginTxnOrigin    string
	inspectFuncBeginTxn   func()
	afterBeginTxnCounter  uint64
	beforeBeginTxnCounter uint64
	BeginTxnMock          mSyncProducerMockBeginTxn

	funcClose          func() (err error)
	funcCloseOrigin    string
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mSyncProducerMockClose

	funcCommitTxn          func() (err error)
	funcCommitTxnOrigin    string
	inspectFuncCommitTxn   func()
	afterCommitTxnCounter  uint64
	beforeCommitTxnCounter uint64
	CommitTxnMock          mSyncProducerMockCommitTxn

	funcIsTransactional          func() (b1 bool)
	funcIsTransactionalOrigin    string
	inspectFuncIsTransactional   func()
	afterIsTransactionalCounter  uint64
	beforeIsTransactionalCounter uint64
	IsTransactionalMock          mSyncProducerMockIsTransactional

	funcSendMessage          func(msg *mm_sarama.ProducerMessage) (partition int32, offset int64, err error)
	funcSendMessageOrigin    string
	inspectFuncSendMessage   func(msg *mm_sarama.ProducerMessage)
	afterSendMessageCounter  uint64
	beforeSendMessageCounter uint64
	SendMessageMock          mSyncProducerMockSendMessage

	funcSendMessages          func(msgs []*mm_sarama.ProducerMessage) (err error)
	funcSendMessagesOrigin    string
	inspectFuncSendMessages   func(msgs []*mm_sarama.ProducerMessage)
	afterSendMessagesCounter  uint64
	beforeSendMessagesCounter uint64
	SendMessagesMock          mSyncProducerMockSendMessages

	funcTxnStatus          func() (p1 mm_sarama.ProducerTxnStatusFlag)
	funcTxnStatusOrigin    string
	inspectFuncTxnStatus   func()
	afterTxnStatusCounter  uint64
	beforeTxnStatusCounter uint64
	TxnStatusMock          mSyncProducerMockTxnStatus
}

// NewSyncProducerMock returns a mock for mm_sarama.SyncProducer
func NewSyncProducerMock(t minimock.Tester) *SyncProducerMock {
	m := &SyncProducerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AbortTxnMock = mSyncProducerMockAbortTxn{mock: m}

	m.AddMessageToTxnMock = mSyncProducerMockAddMessageToTxn{mock: m}
	m.AddMessageToTxnMock.callArgs = []*SyncProducerMockAddMessageToTxnParams{}

	m.AddOffsetsToTxnMock = mSyncProducerMockAddOffsetsToTxn{mock: m}
	m.AddOffsetsToTxnMock.callArgs = []*SyncProducerMockAddOffsetsToTxnParams{}

	m.BeginTxnMock = mSyncProducerMockBeginTxn{mock: m}

	m.CloseMock = mSyncProducerMockClose{mock: m}

	m.CommitTxnMock = mSyncProducerMockCommitTxn{mock: m}

	m.IsTransactionalMock = mSyncProducerMockIsTransactional{mock: m}

	m.SendMessageMock = mSyncProducerMockSendMessage{mock: m}
	m.SendMessageMock.callArgs = []*SyncProducerMockSendMessageParams{}

	m.SendMessagesMock = mSyncProducerMockSendMessages{mock: m}
	m.SendMessagesMock.callArgs = []*SyncProducerMockSendMessagesParams{}

	m.TxnStatusMock = mSyncProducerMockTxnStatus{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mSyncProducerMockAbortTxn struct {
	optional           bool
	mock               *SyncProducerMock
	defaultExpectation *SyncProducerMockAbortTxnExpectation
	expectations       []*SyncProducerMockAbortTxnExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SyncProducerMockAbortTxnExpectation specifies expectation struct of the SyncProducer.AbortTxn
type SyncProducerMockAbortTxnExpectation struct {
	mock *SyncProducerMock

	results      *SyncProducerMockAbortTxnResults
	returnOrigin string
	Counter      uint64
}

// SyncProducerMockAbortTxnResults contains results of the SyncProducer.AbortTxn
type SyncProducerMockAbortTxnResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAbortTxn *mSyncProducerMockAbortTxn) Optional() *mSyncProducerMockAbortTxn {
	mmAbortTxn.optional = true
	return mmAbortTxn
}

// Expect sets up expected params for SyncProducer.AbortTxn
func (mmAbortTxn *mSyncProducerMockAbortTxn) Expect() *mSyncProducerMockAbortTxn {
	if mmAbortTxn.mock.funcAbortTxn != nil {
		mmAbortTxn.mock.t.Fatalf("SyncProducerMock.AbortTxn mock is already set by Set")
	}

	if mmAbortTxn.defaultExpectation == nil {
		mmAbortTxn.defaultExpectation = &SyncProducerMockAbortTxnExpectation{}
	}

	return mmAbortTxn
}

// Inspect accepts an inspector function that has same arguments as the SyncProducer.AbortTxn
func (mmAbortTxn *mSyncProducerMockAbortTxn) Inspect(f func()) *mSyncProducerMockAbortTxn {
	if mmAbortTxn.mock.inspectFuncAbortTxn != nil {
		mmAbortTxn.mock.t.Fatalf("Inspect function is already set for SyncProducerMock.AbortTxn")
	}

	mmAbortTxn.mock.inspectFuncAbortTxn = f

	return mmAbortTxn
}

// Return sets up results that will be returned by SyncProducer.AbortTxn
func (mmAbortTxn *mSyncProducerMockAbortTxn) Return(err error) *SyncProducerMock {
	if mmAbortTxn.mock.funcAbortTxn != nil {
		mmAbortTxn.mock.t.Fatalf("SyncProducerMock.AbortTxn mock is already set by Set")
	}

	if mmAbortTxn.defaultExpectation == nil {
		mmAbortTxn.defaultExpectation = &SyncProducerMockAbortTxnExpectation{mock: mmAbortTxn.mock}
	}
	mmAbortTxn.defaultExpectation.results = &SyncProducerMockAbortTxnResults{err}
	mmAbortTxn.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAbortTxn.mock
}

// Set uses given function f to mock the SyncProducer.AbortTxn method
func (mmAbortTxn *mSyncProducerMockAbortTxn) Set(f func() (err error)) *SyncProducerMock {
	if mmAbortTxn.defaultExpectation != nil {
		mmAbortTxn.mock.t.Fatalf("Default expectation is already set for the SyncProducer.AbortTxn method")
	}

	if len(mmAbortTxn.expectations) > 0 {
		mmAbortTxn.mock.t.Fatalf("Some expectations are already set for the SyncProducer.AbortTxn method")
	}

	mmAbortTxn.mock.funcAbortTxn = f
	mmAbortTxn.mock.funcAbortTxnOrigin = minimock.CallerInfo(1)
	return mmAbortTxn.mock
}

// Times sets number of times SyncProducer.AbortTxn should be invoked
func (mmAbortTxn *mSyncProducerMockAbortTxn) Times(n uint64) *mSyncProducerMockAbortTxn {
	if n == 0 {
		mmAbortTxn.mock.t.Fatalf("Times of SyncProducerMock.AbortTxn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAbortTxn.expectedInvocations, n)
	mmAbortTxn.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAbortTxn
}

func (mmAbortTxn *mSyncProducerMockAbortTxn) invocationsDone() bool {
	if len(mmAbortTxn.expectations) == 0 && mmAbortTxn.defaultExpectation == nil && mmAbortTxn.mock.funcAbortTxn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAbortTxn.mock.afterAbortTxnCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAbortTxn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AbortTxn implements mm_sarama.SyncProducer
func (mmAbortTxn *SyncProducerMock) AbortTxn() (err error) {
	mm_atomic.AddUint64(&mmAbortTxn.beforeAbortTxnCounter, 1)
	defer mm_atomic.AddUint64(&mmAbortTxn.afterAbortTxnCounter, 1)

	mmAbortTxn.t.Helper()

	if mmAbortTxn.inspectFuncAbortTxn != nil {
		mmAbortTxn.inspectFuncAbortTxn()
	}

	if mmAbortTxn.AbortTxnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAbortTxn.AbortTxnMock.defaultExpectation.Counter, 1)

		mm_results := mmAbortTxn.AbortTxnMock.defaultExpectation.results
		if mm_results == nil {
			mmAbortTxn.t.Fatal("No results are set for the SyncProducerMock.AbortTxn")
		}
		return (*mm_results).err
	}
	if mmAbortTxn.funcAbortTxn != nil {
		return mmAbortTxn.funcAbortTxn()
	}
	mmAbortTxn.t.Fatalf("Unexpected call to SyncProducerMock.AbortTxn.")
	return
}

// AbortTxnAfterCounter returns a count of finished SyncProducerMock.AbortTxn invocations
func (mmAbortTxn *SyncProducerMock) AbortTxnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAbortTxn.afterAbortTxnCounter)
}

// AbortTxnBeforeCounter returns a count of SyncProducerMock.AbortTxn invocations
func (mmAbortTxn *SyncProducerMock) AbortTxnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAbortTxn.beforeAbortTxnCounter)
}

// MinimockAbortTxnDone returns true if the count of the AbortTxn invocations corresponds
// the number of defined expectations
func (m *SyncProducerMock) MinimockAbortTxnDone() bool {
	if m.AbortTxnMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AbortTxnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AbortTxnMock.invocationsDone()
}

// MinimockAbortTxnInspect logs each unmet expectation
func (m *SyncProducerMock) MinimockAbortTxnInspect() {
	for _, e := range m.AbortTxnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SyncProducerMock.AbortTxn")
		}
	}

	afterAbortTxnCounter := mm_atomic.LoadUint64(&m.afterAbortTxnCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AbortTxnMock.defaultExpectation != nil && afterAbortTxnCounter < 1 {
		m.t.Errorf("Expected call to SyncProducerMock.AbortTxn at\n%s", m.AbortTxnMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAbortTxn != nil && afterAbortTxnCounter < 1 {
		m.t.Errorf("Expected call to SyncProducerMock.AbortTxn at\n%s", m.funcAbortTxnOrigin)
	}

	if !m.AbortTxnMock.invocationsDone() && afterAbortTxnCounter > 0 {
		m.t.Errorf("Expected %d calls to SyncProducerMock.AbortTxn at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AbortTxnMock.expectedInvocations), m.AbortTxnMock.expectedInvocationsOrigin, afterAbortTxnCounter)
	}
}

type mSyncProducerMockAddMessageToTxn struct {
	optional           bool
	mock               *SyncProducerMock
	defaultExpectation *SyncProducerMockAddMessageToTxnExpectation
	expectations       []*SyncProducerMockAddMessageToTxnExpectation

	callArgs []*SyncProducerMockAddMessageToTxnParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SyncProducerMockAddMessageToTxnExpectation specifies expectation struct of the SyncProducer.AddMessageToTxn
type SyncProducerMockAddMessageToTxnExpectation struct {
	mock               *SyncProducerMock
	params             *SyncProducerMockAddMessageToTxnParams
	paramPtrs          *SyncProducerMockAddMessageToTxnParamPtrs
	expectationOrigins SyncProducerMockAddMessageToTxnExpectationOrigins
	results            *SyncProducerMockAddMessageToTxnResults
	returnOrigin       string
	Counter            uint64
}

// SyncProducerMockAddMessageToTxnParams contains parameters of the SyncProducer.AddMessageToTxn
type SyncProducerMockAddMessageToTxnParams struct {
	msg      *mm_sarama.ConsumerMessage
	groupId  string
	metadata *string
}

// SyncProducerMockAddMessageToTxnParamPtrs contains pointers to parameters of the SyncProducer.AddMessageToTxn
type SyncProducerMockAddMessageToTxnParamPtrs struct {
	msg      **mm_sarama.ConsumerMessage
	groupId  *string
	metadata **string
}

// SyncProducerMockAddMessageToTxnResults contains results of the SyncProducer.AddMessageToTxn
type SyncProducerMockAddMessageToTxnResults struct {
	err error
}

// SyncProducerMockAddMessageToTxnOrigins contains origins of expectations of the SyncProducer.AddMessageToTxn
type SyncProducerMockAddMessageToTxnExpectationOrigins struct {
	origin         string
	originMsg      string
	originGroupId  string
	originMetadata string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddMessageToTxn *mSyncProducerMockAddMessageToTxn) Optional() *mSyncProducerMockAddMessageToTxn {
	mmAddMessageToTxn.optional = true
	return mmAddMessageToTxn
}

// Expect sets up expected params for SyncProducer.AddMessageToTxn
func (mmAddMessageToTxn *mSyncProducerMockAddMessageToTxn) Expect(msg *mm_sarama.ConsumerMessage, groupId string, metadata *string) *mSyncProducerMockAddMessageToTxn {
	if mmAddMessageToTxn.mock.funcAddMessageToTxn != nil {
		mmAddMessageToTxn.mock.t.Fatalf("SyncProducerMock.AddMessageToTxn mock is already set by Set")
	}

	if mmAddMessageToTxn.defaultExpectation == nil {
		mmAddMessageToTxn.defaultExpectation = &SyncProducerMockAddMessageToTxnExpectation{}
	}

	if mmAddMessageToTxn.defaultExpectation.paramPtrs != nil {
		mmAddMessageToTxn.mock.t.Fatalf("SyncProducerMock.AddMessageToTxn mock is already set by ExpectParams functions")
	}

	mmAddMessageToTxn.defaultExpectation.params = &SyncProducerMockAddMessageToTxnParams{msg, groupId, metadata}
	mmAddMessageToTxn.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddMessageToTxn.expectations {
		if minimock.Equal(e.params, mmAddMessageToTxn.defaultExpectation.params) {
			mmAddMessageToTxn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddMessageToTxn.defaultExpectation.params)
		}
	}

	return mmAddMessageToTxn
}

// ExpectMsgParam1 sets up expected param msg for SyncProducer.AddMessageToTxn
func (mmAddMessageToTxn *mSyncProducerMockAddMessageToTxn) ExpectMsgParam1(msg *mm_sarama.ConsumerMessage) *mSyncProducerMockAddMessageToTxn {
	if mmAddMessageToTxn.mock.funcAddMessageToTxn != nil {
		mmAddMessageToTxn.mock.t.Fatalf("SyncProducerMock.AddMessageToTxn mock is already set by Set")
	}

	if mmAddMessageToTxn.defaultExpectation == nil {
		mmAddMessageToTxn.defaultExpectation = &SyncProducerMockAddMessageToTxnExpectation{}
	}

	if mmAddMessageToTxn.defaultExpectation.params != nil {
		mmAddMessageToTxn.mock.t.Fatalf("SyncProducerMock.AddMessageToTxn mock is already set by Expect")
	}

	if mmAddMessageToTxn.defaultExpectation.paramPtrs == nil {
		mmAddMessageToTxn.defaultExpectation.paramPtrs = &SyncProducerMockAddMessageToTxnParamPtrs{}
	}
	mmAddMessageToTxn.defaultExpectation.paramPtrs.msg = &msg
	mmAddMessageToTxn.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmAddMessageToTxn
}

// ExpectGroupIdParam2 sets up expected param groupId for SyncProducer.AddMessageToTxn
func (mmAddMessageToTxn *mSyncProducerMockAddMessageToTxn) ExpectGroupIdParam2(groupId string) *mSyncProducerMockAddMessageToTxn {
	if mmAddMessageToTxn.mock.funcAddMessageToTxn != nil {
		mmAddMessageToTxn.mock.t.Fatalf("SyncProducerMock.AddMessageToTxn mock is already set by Set")
	}

	if mmAddMessageToTxn.defaultExpectation == nil {
		mmAddMessageToTxn.defaultExpectation = &SyncProducerMockAddMessageToTxnExpectation{}
	}

	if mmAddMessageToTxn.defaultExpectation.params != nil {
		mmAddMessageToTxn.mock.t.Fatalf("SyncProducerMock.AddMessageToTxn mock is already set by Expect")
	}

	if mmAddMessageToTxn.defaultExpectation.paramPtrs == nil {
		mmAddMessageToTxn.defaultExpectation.paramPtrs = &SyncProducerMockAddMessageToTxnParamPtrs{}
	}
	mmAddMessageToTxn.defaultExpectation.paramPtrs.groupId = &groupId
	mmAddMessageToTxn.defaultExpectation.expectationOrigins.originGroupId = minimock.CallerInfo(1)

	return mmAddMessageToTxn
}

// ExpectMetadataParam3 sets up expected param metadata for SyncProducer.AddMessageToTxn
func (mmAddMessageToTxn *mSyncProducerMockAddMessageToTxn) ExpectMetadataParam3(metadata *string) *mSyncProducerMockAddMessageToTxn {
	if mmAddMessageToTxn.mock.funcAddMessageToTxn != nil {
		mmAddMessageToTxn.mock.t.Fatalf("SyncProducerMock.AddMessageToTxn mock is already set by Set")
	}

	if mmAddMessageToTxn.defaultExpectation == nil {
		mmAddMessageToTxn.defaultExpectation = &SyncProducerMockAddMessageToTxnExpectation{}
	}

	if mmAddMessageToTxn.defaultExpectation.params != nil {
		mmAddMessageToTxn.mock.t.Fatalf("SyncProducerMock.AddMessageToTxn mock is already set by Expect")
	}

	if mmAddMessageToTxn.defaultExpectation.paramPtrs == nil {
		mmAddMessageToTxn.defaultExpectation.paramPtrs = &SyncProducerMockAddMessageToTxnParamPtrs{}
	}
	mmAddMessageToTxn.defaultExpectation.paramPtrs.metadata = &metadata
	mmAddMessageToTxn.defaultExpectation.expectationOrigins.originMetadata = minimock.CallerInfo(1)

	return mmAddMessageToTxn
}

// Inspect accepts an inspector function that has same arguments as the SyncProducer.AddMessageToTxn
func (mmAddMessageToTxn *mSyncProducerMockAddMessageToTxn) Inspect(f func(msg *mm_sarama.ConsumerMessage, groupId string, metadata *string)) *mSyncProducerMockAddMessageToTxn {
	if mmAddMessageToTxn.mock.inspectFuncAddMessageToTxn != nil {
		mmAddMessageToTxn.mock.t.Fatalf("Inspect function is already set for SyncProducerMock.AddMessageToTxn")
	}

	mmAddMessageToTxn.mock.inspectFuncAddMessageToTxn = f

	return mmAddMessageToTxn
}

// Return sets up results that will be returned by SyncProducer.AddMessageToTxn
func (mmAddMessageToTxn *mSyncProducerMockAddMessageToTxn) Return(err error) *SyncProducerMock {
	if mmAddMessageToTxn.mock.funcAddMessageToTxn != nil {
		mmAddMessageToTxn.mock.t.Fatalf("SyncProducerMock.AddMessageToTxn mock is already set by Set")
	}

	if mmAddMessageToTxn.defaultExpectation == nil {
		mmAddMessageToTxn.defaultExpectation = &SyncProducerMockAddMessageToTxnExpectation{mock: mmAddMessageToTxn.mock}
	}
	mmAddMessageToTxn.defaultExpectation.results = &SyncProducerMockAddMessageToTxnResults{err}
	mmAddMessageToTxn.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddMessageToTxn.mock
}

// Set uses given function f to mock the SyncProducer.AddMessageToTxn method
func (mmAddMessageToTxn *mSyncProducerMockAddMessageToTxn) Set(f func(msg *mm_sarama.ConsumerMessage, groupId string, metadata *string) (err error)) *SyncProducerMock {
	if mmAddMessageToTxn.defaultExpectation != nil {
		mmAddMessageToTxn.mock.t.Fatalf("Default expectation is already set for the SyncProducer.AddMessageToTxn method")
	}

	if len(mmAddMessageToTxn.expectations) > 0 {
		mmAddMessageToTxn.mock.t.Fatalf("Some expectations are already set for the SyncProducer.AddMessageToTxn method")
	}

	mmAddMessageToTxn.mock.funcAddMessageToTxn = f
	mmAddMessageToTxn.mock.funcAddMessageToTxnOrigin = minimock.CallerInfo(1)
	return mmAddMessageToTxn.mock
}

// When sets expectation for the SyncProducer.AddMessageToTxn which will trigger the result defined by the following
// Then helper
func (mmAddMessageToTxn *mSyncProducerMockAddMessageToTxn) When(msg *mm_sarama.ConsumerMessage, groupId string, metadata *string) *SyncProducerMockAddMessageToTxnExpectation {
	if mmAddMessageToTxn.mock.funcAddMessageToTxn != nil {
		mmAddMessageToTxn.mock.t.Fatalf("SyncProducerMock.AddMessageToTxn mock is already set by Set")
	}

	expectation := &SyncProducerMockAddMessageToTxnExpectation{
		mock:               mmAddMessageToTxn.mock,
		params:             &SyncProducerMockAddMessageToTxnParams{msg, groupId, metadata},
		expectationOrigins: SyncProducerMockAddMessageToTxnExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddMessageToTxn.expectations = append(mmAddMessageToTxn.expectations, expectation)
	return expectation
}

// Then sets up SyncProducer.AddMessageToTxn return parameters for the expectation previously defined by the When method
func (e *SyncProducerMockAddMessageToTxnExpectation) Then(err error) *SyncProducerMock {
	e.results = &SyncProducerMockAddMessageToTxnResults{err}
	return e.mock
}

// Times sets number of times SyncProducer.AddMessageToTxn should be invoked
func (mmAddMessageToTxn *mSyncProducerMockAddMessageToTxn) Times(n uint64) *mSyncProducerMockAddMessageToTxn {
	if n == 0 {
		mmAddMessageToTxn.mock.t.Fatalf("Times of SyncProducerMock.AddMessageToTxn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddMessageToTxn.expectedInvocations, n)
	mmAddMessageToTxn.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddMessageToTxn
}

func (mmAddMessageToTxn *mSyncProducerMockAddMessageToTxn) invocationsDone() bool {
	if len(mmAddMessageToTxn.expectations) == 0 && mmAddMessageToTxn.defaultExpectation == nil && mmAddMessageToTxn.mock.funcAddMessageToTxn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddMessageToTxn.mock.afterAddMessageToTxnCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddMessageToTxn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddMessageToTxn implements mm_sarama.SyncProducer
func (mmAddMessageToTxn *SyncProducerMock) AddMessageToTxn(msg *mm_sarama.ConsumerMessage, groupId string, metadata *string) (err error) {
	mm_atomic.AddUint64(&mmAddMessageToTxn.beforeAddMessageToTxnCounter, 1)
	defer mm_atomic.AddUint64(&mmAddMessageToTxn.afterAddMessageToTxnCounter, 1)

	mmAddMessageToTxn.t.Helper()

	if mmAddMessageToTxn.inspectFuncAddMessageToTxn != nil {
		mmAddMessageToTxn.inspectFuncAddMessageToTxn(msg, groupId, metadata)
	}

	mm_params := SyncProducerMockAddMessageToTxnParams{msg, groupId, metadata}

	// Record call args
	mmAddMessageToTxn.AddMessageToTxnMock.mutex.Lock()
	mmAddMessageToTxn.AddMessageToTxnMock.callArgs = append(mmAddMessageToTxn.AddMessageToTxnMock.callArgs, &mm_params)
	mmAddMessageToTxn.AddMessageToTxnMock.mutex.Unlock()

	for _, e := range mmAddMessageToTxn.AddMessageToTxnMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddMessageToTxn.AddMessageToTxnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddMessageToTxn.AddMessageToTxnMock.defaultExpectation.Counter, 1)
		mm_want := mmAddMessageToTxn.AddMessageToTxnMock.defaultExpectation.params
		mm_want_ptrs := mmAddMessageToTxn.AddMessageToTxnMock.defaultExpectation.paramPtrs

		mm_got := SyncProducerMockAddMessageToTxnParams{msg, groupId, metadata}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmAddMessageToTxn.t.Errorf("SyncProducerMock.AddMessageToTxn got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddMessageToTxn.AddMessageToTxnMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.groupId != nil && !minimock.Equal(*mm_want_ptrs.groupId, mm_got.groupId) {
				mmAddMessageToTxn.t.Errorf("SyncProducerMock.AddMessageToTxn got unexpected parameter groupId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddMessageToTxn.AddMessageToTxnMock.defaultExpectation.expectationOrigins.originGroupId, *mm_want_ptrs.groupId, mm_got.groupId, minimock.Diff(*mm_want_ptrs.groupId, mm_got.groupId))
			}

			if mm_want_ptrs.metadata != nil && !minimock.Equal(*mm_want_ptrs.metadata, mm_got.metadata) {
				mmAddMessageToTxn.t.Errorf("SyncProducerMock.AddMessageToTxn got unexpected parameter metadata, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddMessageToTxn.AddMessageToTxnMock.defaultExpectation.expectationOrigins.originMetadata, *mm_want_ptrs.metadata, mm_got.metadata, minimock.Diff(*mm_want_ptrs.metadata, mm_got.metadata))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddMessageToTxn.t.Errorf("SyncProducerMock.AddMessageToTxn got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddMessageToTxn.AddMessageToTxnMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddMessageToTxn.AddMessageToTxnMock.defaultExpectation.results
		if mm_results == nil {
			mmAddMessageToTxn.t.Fatal("No results are set for the SyncProducerMock.AddMessageToTxn")
		}
		return (*mm_results).err
	}
	if mmAddMessageToTxn.funcAddMessageToTxn != nil {
		return mmAddMessageToTxn.funcAddMessageToTxn(msg, groupId, metadata)
	}
	mmAddMessageToTxn.t.Fatalf("Unexpected call to SyncProducerMock.AddMessageToTxn. %v %v %v", msg, groupId, metadata)
	return
}

// AddMessageToTxnAfterCounter returns a count of finished SyncProducerMock.AddMessageToTxn invocations
func (mmAddMessageToTxn *SyncProducerMock) AddMessageToTxnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddMessageToTxn.afterAddMessageToTxnCounter)
}

// AddMessageToTxnBeforeCounter returns a count of SyncProducerMock.AddMessageToTxn invocations
func (mmAddMessageToTxn *SyncProducerMock) AddMessageToTxnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddMessageToTxn.beforeAddMessageToTxnCounter)
}

// Calls returns a list of arguments used in each call to SyncProducerMock.AddMessageToTxn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddMessageToTxn *mSyncProducerMockAddMessageToTxn) Calls() []*SyncProducerMockAddMessageToTxnParams {
	mmAddMessageToTxn.mutex.RLock()

	argCopy := make([]*SyncProducerMockAddMessageToTxnParams, len(mmAddMessageToTxn.callArgs))
	copy(argCopy, mmAddMessageToTxn.callArgs)

	mmAddMessageToTxn.mutex.RUnlock()

	return argCopy
}

// MinimockAddMessageToTxnDone returns true if the count of the AddMessageToTxn invocations corresponds
// the number of defined expectations
func (m *SyncProducerMock) MinimockAddMessageToTxnDone() bool {
	if m.AddMessageToTxnMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddMessageToTxnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddMessageToTxnMock.invocationsDone()
}

// MinimockAddMessageToTxnInspect logs each unmet expectation
func (m *SyncProducerMock) MinimockAddMessageToTxnInspect() {
	for _, e := range m.AddMessageToTxnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SyncProducerMock.AddMessageToTxn at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddMessageToTxnCounter := mm_atomic.LoadUint64(&m.afterAddMessageToTxnCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddMessageToTxnMock.defaultExpectation != nil && afterAddMessageToTxnCounter < 1 {
		if m.AddMessageToTxnMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SyncProducerMock.AddMessageToTxn at\n%s", m.AddMessageToTxnMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SyncProducerMock.AddMessageToTxn at\n%s with params: %#v", m.AddMessageToTxnMock.defaultExpectation.expectationOrigins.origin, *m.AddMessageToTxnMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddMessageToTxn != nil && afterAddMessageToTxnCounter < 1 {
		m.t.Errorf("Expected call to SyncProducerMock.AddMessageToTxn at\n%s", m.funcAddMessageToTxnOrigin)
	}

	if !m.AddMessageToTxnMock.invocationsDone() && afterAddMessageToTxnCounter > 0 {
		m.t.Errorf("Expected %d calls to SyncProducerMock.AddMessageToTxn at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddMessageToTxnMock.expectedInvocations), m.AddMessageToTxnMock.expectedInvocationsOrigin, afterAddMessageToTxnCounter)
	}
}

type mSyncProducerMockAddOffsetsToTxn struct {
	optional           bool
	mock               *SyncProducerMock
	defaultExpectation *SyncProducerMockAddOffsetsToTxnExpectation
	expectations       []*SyncProducerMockAddOffsetsToTxnExpectation

	callArgs []*SyncProducerMockAddOffsetsToTxnParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SyncProducerMockAddOffsetsToTxnExpectation specifies expectation struct of the SyncProducer.AddOffsetsToTxn
type SyncProducerMockAddOffsetsToTxnExpectation struct {
	mock               *SyncProducerMock
	params             *SyncProducerMockAddOffsetsToTxnParams
	paramPtrs          *SyncProducerMockAddOffsetsToTxnParamPtrs
	expectationOrigins SyncProducerMockAddOffsetsToTxnExpectationOrigins
	results            *SyncProducerMockAddOffsetsToTxnResults
	returnOrigin       string
	Counter            uint64
}

// SyncProducerMockAddOffsetsToTxnParams contains parameters of the SyncProducer.AddOffsetsToTxn
type SyncProducerMockAddOffsetsToTxnParams struct {
	offsets map[string][]*mm_sarama.PartitionOffsetMetadata
	groupId string
}

// SyncProducerMockAddOffsetsToTxnParamPtrs contains pointers to parameters of the SyncProducer.AddOffsetsToTxn
type SyncProducerMockAddOffsetsToTxnParamPtrs struct {
	offsets *map[string][]*mm_sarama.PartitionOffsetMetadata
	groupId *string
}

// SyncProducerMockAddOffsetsToTxnResults contains results of the SyncProducer.AddOffsetsToTxn
type SyncProducerMockAddOffsetsToTxnResults struct {
	err error
}

// SyncProducerMockAddOffsetsToTxnOrigins contains origins of expectations of the SyncProducer.AddOffsetsToTxn
type SyncProducerMockAddOffsetsToTxnExpectationOrigins struct {
	origin        string
	originOffsets string
	originGroupId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddOffsetsToTxn *mSyncProducerMockAddOffsetsToTxn) Optional() *mSyncProducerMockAddOffsetsToTxn {
	mmAddOffsetsToTxn.optional = true
	return mmAddOffsetsToTxn
}

// Expect sets up expected params for SyncProducer.AddOffsetsToTxn
func (mmAddOffsetsToTxn *mSyncProducerMockAddOffsetsToTxn) Expect(offsets map[string][]*mm_sarama.PartitionOffsetMetadata, groupId string) *mSyncProducerMockAddOffsetsToTxn {
	if mmAddOffsetsToTxn.mock.funcAddOffsetsToTxn != nil {
		mmAddOffsetsToTxn.mock.t.Fatalf("SyncProducerMock.AddOffsetsToTxn mock is already set by Set")
	}

	if mmAddOffsetsToTxn.defaultExpectation == nil {
		mmAddOffsetsToTxn.defaultExpectation = &SyncProducerMockAddOffsetsToTxnExpectation{}
	}

	if mmAddOffsetsToTxn.defaultExpectation.paramPtrs != nil {
		mmAddOffsetsToTxn.mock.t.Fatalf("SyncProducerMock.AddOffsetsToTxn mock is already set by ExpectParams functions")
	}

	mmAddOffsetsToTxn.defaultExpectation.params = &SyncProducerMockAddOffsetsToTxnParams{offsets, groupId}
	mmAddOffsetsToTxn.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddOffsetsToTxn.expectations {
		if minimock.Equal(e.params, mmAddOffsetsToTxn.defaultExpectation.params) {
			mmAddOffsetsToTxn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddOffsetsToTxn.defaultExpectation.params)
		}
	}

	return mmAddOffsetsToTxn
}

// ExpectOffsetsParam1 sets up expected param offsets for SyncProducer.AddOffsetsToTxn
func (mmAddOffsetsToTxn *mSyncProducerMockAddOffsetsToTxn) ExpectOffsetsParam1(offsets map[string][]*mm_sarama.PartitionOffsetMetadata) *mSyncProducerMockAddOffsetsToTxn {
	if mmAddOffsetsToTxn.mock.funcAddOffsetsToTxn != nil {
		mmAddOffsetsToTxn.mock.t.Fatalf("SyncProducerMock.AddOffsetsToTxn mock is already set by Set")
	}

	if mmAddOffsetsToTxn.defaultExpectation == nil {
		mmAddOffsetsToTxn.defaultExpectation = &SyncProducerMockAddOffsetsToTxnExpectation{}
	}

	if mmAddOffsetsToTxn.defaultExpectation.params != nil {
		mmAddOffsetsToTxn.mock.t.Fatalf("SyncProducerMock.AddOffsetsToTxn mock is already set by Expect")
	}

	if mmAddOffsetsToTxn.defaultExpectation.paramPtrs == nil {
		mmAddOffsetsToTxn.defaultExpectation.paramPtrs = &SyncProducerMockAddOffsetsToTxnParamPtrs{}
	}
	mmAddOffsetsToTxn.defaultExpectation.paramPtrs.offsets = &offsets
	mmAddOffsetsToTxn.defaultExpectation.expectationOrigins.originOffsets = minimock.CallerInfo(1)

	return mmAddOffsetsToTxn
}

// ExpectGroupIdParam2 sets up expected param groupId for SyncProducer.AddOffsetsToTxn
func (mmAddOffsetsToTxn *mSyncProducerMockAddOffsetsToTxn) ExpectGroupIdParam2(groupId string) *mSyncProducerMockAddOffsetsToTxn {
	if mmAddOffsetsToTxn.mock.funcAddOffsetsToTxn != nil {
		mmAddOffsetsToTxn.mock.t.Fatalf("SyncProducerMock.AddOffsetsToTxn mock is already set by Set")
	}

	if mmAddOffsetsToTxn.defaultExpectation == nil {
		mmAddOffsetsToTxn.defaultExpectation = &SyncProducerMockAddOffsetsToTxnExpectation{}
	}

	if mmAddOffsetsToTxn.defaultExpectation.params != nil {
		mmAddOffsetsToTxn.mock.t.Fatalf("SyncProducerMock.AddOffsetsToTxn mock is already set by Expect")
	}

	if mmAddOffsetsToTxn.defaultExpectation.paramPtrs == nil {
		mmAddOffsetsToTxn.defaultExpectation.paramPtrs = &SyncProducerMockAddOffsetsToTxnParamPtrs{}
	}
	mmAddOffsetsToTxn.defaultExpectation.paramPtrs.groupId = &groupId
	mmAddOffsetsToTxn.defaultExpectation.expectationOrigins.originGroupId = minimock.CallerInfo(1)

	return mmAddOffsetsToTxn
}

// Inspect accepts an inspector function that has same arguments as the SyncProducer.AddOffsetsToTxn
func (mmAddOffsetsToTxn *mSyncProducerMockAddOffsetsToTxn) Inspect(f func(offsets map[string][]*mm_sarama.PartitionOffsetMetadata, groupId string)) *mSyncProducerMockAddOffsetsToTxn {
	if mmAddOffsetsToTxn.mock.inspectFuncAddOffsetsToTxn != nil {
		mmAddOffsetsToTxn.mock.t.Fatalf("Inspect function is already set for SyncProducerMock.AddOffsetsToTxn")
	}

	mmAddOffsetsToTxn.mock.inspectFuncAddOffsetsToTxn = f

	return mmAddOffsetsToTxn
}

// Return sets up results that will be returned by SyncProducer.AddOffsetsToTxn
func (mmAddOffsetsToTxn *mSyncProducerMockAddOffsetsToTxn) Return(err error) *SyncProducerMock {
	if mmAddOffsetsToTxn.mock.funcAddOffsetsToTxn != nil {
		mmAddOffsetsToTxn.mock.t.Fatalf("SyncProducerMock.AddOffsetsToTxn mock is already set by Set")
	}

	if mmAddOffsetsToTxn.defaultExpectation == nil {
		mmAddOffsetsToTxn.defaultExpectation = &SyncProducerMockAddOffsetsToTxnExpectation{mock: mmAddOffsetsToTxn.mock}
	}
	mmAddOffsetsToTxn.defaultExpectation.results = &SyncProducerMockAddOffsetsToTxnResults{err}
	mmAddOffsetsToTxn.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddOffsetsToTxn.mock
}

// Set uses given function f to mock the SyncProducer.AddOffsetsToTxn method
func (mmAddOffsetsToTxn *mSyncProducerMockAddOffsetsToTxn) Set(f func(offsets map[string][]*mm_sarama.PartitionOffsetMetadata, groupId string) (err error)) *SyncProducerMock {
	if mmAddOffsetsToTxn.defaultExpectation != nil {
		mmAddOffsetsToTxn.mock.t.Fatalf("Default expectation is already set for the SyncProducer.AddOffsetsToTxn method")
	}

	if len(mmAddOffsetsToTxn.expectations) > 0 {
		mmAddOffsetsToTxn.mock.t.Fatalf("Some expectations are already set for the SyncProducer.AddOffsetsToTxn method")
	}

	mmAddOffsetsToTxn.mock.funcAddOffsetsToTxn = f
	mmAddOffsetsToTxn.mock.funcAddOffsetsToTxnOrigin = minimock.CallerInfo(1)
	return mmAddOffsetsToTxn.mock
}

// When sets expectation for the SyncProducer.AddOffsetsToTxn which will trigger the result defined by the following
// Then helper
func (mmAddOffsetsToTxn *mSyncProducerMockAddOffsetsToTxn) When(offsets map[string][]*mm_sarama.PartitionOffsetMetadata, groupId string) *SyncProducerMockAddOffsetsToTxnExpectation {
	if mmAddOffsetsToTxn.mock.funcAddOffsetsToTxn != nil {
		mmAddOffsetsToTxn.mock.t.Fatalf("SyncProducerMock.AddOffsetsToTxn mock is already set by Set")
	}

	expectation := &SyncProducerMockAddOffsetsToTxnExpectation{
		mock:               mmAddOffsetsToTxn.mock,
		params:             &SyncProducerMockAddOffsetsToTxnParams{offsets, groupId},
		expectationOrigins: SyncProducerMockAddOffsetsToTxnExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddOffsetsToTxn.expectations = append(mmAddOffsetsToTxn.expectations, expectation)
	return expectation
}

// Then sets up SyncProducer.AddOffsetsToTxn return parameters for the expectation previously defined by the When method
func (e *SyncProducerMockAddOffsetsToTxnExpectation) Then(err error) *SyncProducerMock {
	e.results = &SyncProducerMockAddOffsetsToTxnResults{err}
	return e.mock
}

// Times sets number of times SyncProducer.AddOffsetsToTxn should be invoked
func (mmAddOffsetsToTxn *mSyncProducerMockAddOffsetsToTxn) Times(n uint64) *mSyncProducerMockAddOffsetsToTxn {
	if n == 0 {
		mmAddOffsetsToTxn.mock.t.Fatalf("Times of SyncProducerMock.AddOffsetsToTxn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddOffsetsToTxn.expectedInvocations, n)
	mmAddOffsetsToTxn.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddOffsetsToTxn
}

func (mmAddOffsetsToTxn *mSyncProducerMockAddOffsetsToTxn) invocationsDone() bool {
	if len(mmAddOffsetsToTxn.expectations) == 0 && mmAddOffsetsToTxn.defaultExpectation == nil && mmAddOffsetsToTxn.mock.funcAddOffsetsToTxn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddOffsetsToTxn.mock.afterAddOffsetsToTxnCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddOffsetsToTxn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddOffsetsToTxn implements mm_sarama.SyncProducer
func (mmAddOffsetsToTxn *SyncProducerMock) AddOffsetsToTxn(offsets map[string][]*mm_sarama.PartitionOffsetMetadata, groupId string) (err error) {
	mm_atomic.AddUint64(&mmAddOffsetsToTxn.beforeAddOffsetsToTxnCounter, 1)
	defer mm_atomic.AddUint64(&mmAddOffsetsToTxn.afterAddOffsetsToTxnCounter, 1)

	mmAddOffsetsToTxn.t.Helper()

	if mmAddOffsetsToTxn.inspectFuncAddOffsetsToTxn != nil {
		mmAddOffsetsToTxn.inspectFuncAddOffsetsToTxn(offsets, groupId)
	}

	mm_params := SyncProducerMockAddOffsetsToTxnParams{offsets, groupId}

	// Record call args
	mmAddOffsetsToTxn.AddOffsetsToTxnMock.mutex.Lock()
	mmAddOffsetsToTxn.AddOffsetsToTxnMock.callArgs = append(mmAddOffsetsToTxn.AddOffsetsToTxnMock.callArgs, &mm_params)
	mmAddOffsetsToTxn.AddOffsetsToTxnMock.mutex.Unlock()

	for _, e := range mmAddOffsetsToTxn.AddOffsetsToTxnMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddOffsetsToTxn.AddOffsetsToTxnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddOffsetsToTxn.AddOffsetsToTxnMock.defaultExpectation.Counter, 1)
		mm_want := mmAddOffsetsToTxn.AddOffsetsToTxnMock.defaultExpectation.params
		mm_want_ptrs := mmAddOffsetsToTxn.AddOffsetsToTxnMock.defaultExpectation.paramPtrs

		mm_got := SyncProducerMockAddOffsetsToTxnParams{offsets, groupId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.offsets != nil && !minimock.Equal(*mm_want_ptrs.offsets, mm_got.offsets) {
				mmAddOffsetsToTxn.t.Errorf("SyncProducerMock.AddOffsetsToTxn got unexpected parameter offsets, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOffsetsToTxn.AddOffsetsToTxnMock.defaultExpectation.expectationOrigins.originOffsets, *mm_want_ptrs.offsets, mm_got.offsets, minimock.Diff(*mm_want_ptrs.offsets, mm_got.offsets))
			}

			if mm_want_ptrs.groupId != nil && !minimock.Equal(*mm_want_ptrs.groupId, mm_got.groupId) {
				mmAddOffsetsToTxn.t.Errorf("SyncProducerMock.AddOffsetsToTxn got unexpected parameter groupId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOffsetsToTxn.AddOffsetsToTxnMock.defaultExpectation.expectationOrigins.originGroupId, *mm_want_ptrs.groupId, mm_got.groupId, minimock.Diff(*mm_want_ptrs.groupId, mm_got.groupId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddOffsetsToTxn.t.Errorf("SyncProducerMock.AddOffsetsToTxn got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddOffsetsToTxn.AddOffsetsToTxnMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddOffsetsToTxn.AddOffsetsToTxnMock.defaultExpectation.results
		if mm_results == nil {
			mmAddOffsetsToTxn.t.Fatal("No results are set for the SyncProducerMock.AddOffsetsToTxn")
		}
		return (*mm_results).err
	}
	if mmAddOffsetsToTxn.funcAddOffsetsToTxn != nil {
		return mmAddOffsetsToTxn.funcAddOffsetsToTxn(offsets, groupId)
	}
	mmAddOffsetsToTxn.t.Fatalf("Unexpected call to SyncProducerMock.AddOffsetsToTxn. %v %v", offsets, groupId)
	return
}

// AddOffsetsToTxnAfterCounter returns a count of finished SyncProducerMock.AddOffsetsToTxn invocations
func (mmAddOffsetsToTxn *SyncProducerMock) AddOffsetsToTxnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOffsetsToTxn.afterAddOffsetsToTxnCounter)
}

// AddOffsetsToTxnBeforeCounter returns a count of SyncProducerMock.AddOffsetsToTxn invocations
func (mmAddOffsetsToTxn *SyncProducerMock) AddOffsetsToTxnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOffsetsToTxn.beforeAddOffsetsToTxnCounter)
}

// Calls returns a list of arguments used in each call to SyncProducerMock.AddOffsetsToTxn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddOffsetsToTxn *mSyncProducerMockAddOffsetsToTxn) Calls() []*SyncProducerMockAddOffsetsToTxnParams {
	mmAddOffsetsToTxn.mutex.RLock()

	argCopy := make([]*SyncProducerMockAddOffsetsToTxnParams, len(mmAddOffsetsToTxn.callArgs))
	copy(argCopy, mmAddOffsetsToTxn.callArgs)

	mmAddOffsetsToTxn.mutex.RUnlock()

	return argCopy
}

// MinimockAddOffsetsToTxnDone returns true if the count of the AddOffsetsToTxn invocations corresponds
// the number of defined expectations
func (m *SyncProducerMock) MinimockAddOffsetsToTxnDone() bool {
	if m.AddOffsetsToTxnMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddOffsetsToTxnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddOffsetsToTxnMock.invocationsDone()
}

// MinimockAddOffsetsToTxnInspect logs each unmet expectation
func (m *SyncProducerMock) MinimockAddOffsetsToTxnInspect() {
	for _, e := range m.AddOffsetsToTxnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SyncProducerMock.AddOffsetsToTxn at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddOffsetsToTxnCounter := mm_atomic.LoadUint64(&m.afterAddOffsetsToTxnCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddOffsetsToTxnMock.defaultExpectation != nil && afterAddOffsetsToTxnCounter < 1 {
		if m.AddOffsetsToTxnMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SyncProducerMock.AddOffsetsToTxn at\n%s", m.AddOffsetsToTxnMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SyncProducerMock.AddOffsetsToTxn at\n%s with params: %#v", m.AddOffsetsToTxnMock.defaultExpectation.expectationOrigins.origin, *m.AddOffsetsToTxnMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddOffsetsToTxn != nil && afterAddOffsetsToTxnCounter < 1 {
		m.t.Errorf("Expected call to SyncProducerMock.AddOffsetsToTxn at\n%s", m.funcAddOffsetsToTxnOrigin)
	}

	if !m.AddOffsetsToTxnMock.invocationsDone() && afterAddOffsetsToTxnCounter > 0 {
		m.t.Errorf("Expected %d calls to SyncProducerMock.AddOffsetsToTxn at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddOffsetsToTxnMock.expectedInvocations), m.AddOffsetsToTxnMock.expectedInvocationsOrigin, afterAddOffsetsToTxnCounter)
	}
}

type mSyncProducerMockBeginTxn struct {
	optional           bool
	mock               *SyncProducerMock
	defaultExpectation *SyncProducerMockBeginTxnExpectation
	expectations       []*SyncProducerMockBeginTxnExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SyncProducerMockBeginTxnExpectation specifies expectation struct of the SyncProducer.BeginTxn
type SyncProducerMockBeginTxnExpectation struct {
	mock *SyncProducerMock

	results      *SyncProducerMockBeginTxnResults
	returnOrigin string
	Counter      uint64
}

// SyncProducerMockBeginTxnResults contains results of the SyncProducer.BeginTxn
type SyncProducerMockBeginTxnResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmBeginTxn *mSyncProducerMockBeginTxn) Optional() *mSyncProducerMockBeginTxn {
	mmBeginTxn.optional = true
	return mmBeginTxn
}

// Expect sets up expected params for SyncProducer.BeginTxn
func (mmBeginTxn *mSyncProducerMockBeginTxn) Expect() *mSyncProducerMockBeginTxn {
	if mmBeginTxn.mock.funcBeginTxn != nil {
		mmBeginTxn.mock.t.Fatalf("SyncProducerMock.BeginTxn mock is already set by Set")
	}

	if mmBeginTxn.defaultExpectation == nil {
		mmBeginTxn.defaultExpectation = &SyncProducerMockBeginTxnExpectation{}
	}

	return mmBeginTxn
}

// Inspect accepts an inspector function that has same arguments as the SyncProducer.BeginTxn
func (mmBeginTxn *mSyncProducerMockBeginTxn) Inspect(f func()) *mSyncProducerMockBeginTxn {
	if mmBeginTxn.mock.inspectFuncBeginTxn != nil {
		mmBeginTxn.mock.t.Fatalf("Inspect function is already set for SyncProducerMock.BeginTxn")
	}

	mmBeginTxn.mock.inspectFuncBeginTxn = f

	return mmBeginTxn
}

// Return sets up results that will be returned by SyncProducer.BeginTxn
func (mmBeginTxn *mSyncProducerMockBeginTxn) Return(err error) *SyncProducerMock {
	if mmBeginTxn.mock.funcBeginTxn != nil {
		mmBeginTxn.mock.t.Fatalf("SyncProducerMock.BeginTxn mock is already set by Set")
	}

	if mmBeginTxn.defaultExpectation == nil {
		mmBeginTxn.defaultExpectation = &SyncProducerMockBeginTxnExpectation{mock: mmBeginTxn.mock}
	}
	mmBeginTxn.defaultExpectation.results = &SyncProducerMockBeginTxnResults{err}
	mmBeginTxn.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmBeginTxn.mock
}

// Set uses given function f to mock the SyncProducer.BeginTxn method
func (mmBeginTxn *mSyncProducerMockBeginTxn) Set(f func() (err error)) *SyncProducerMock {
	if mmBeginTxn.defaultExpectation != nil {
		mmBeginTxn.mock.t.Fatalf("Default expectation is already set for the SyncProducer.BeginTxn method")
	}

	if len(mmBeginTxn.expectations) > 0 {
		mmBeginTxn.mock.t.Fatalf("Some expectations are already set for the SyncProducer.BeginTxn method")
	}

	mmBeginTxn.mock.funcBeginTxn = f
	mmBeginTxn.mock.funcBeginTxnOrigin = minimock.CallerInfo(1)
	return mmBeginTxn.mock
}

// Times sets number of times SyncProducer.BeginTxn should be invoked
func (mmBeginTxn *mSyncProducerMockBeginTxn) Times(n uint64) *mSyncProducerMockBeginTxn {
	if n == 0 {
		mmBeginTxn.mock.t.Fatalf("Times of SyncProducerMock.BeginTxn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmBeginTxn.expectedInvocations, n)
	mmBeginTxn.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmBeginTxn
}

func (mmBeginTxn *mSyncProducerMockBeginTxn) invocationsDone() bool {
	if len(mmBeginTxn.expectations) == 0 && mmBeginTxn.defaultExpectation == nil && mmBeginTxn.mock.funcBeginTxn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmBeginTxn.mock.afterBeginTxnCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmBeginTxn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// BeginTxn implements mm_sarama.SyncProducer
func (mmBeginTxn *SyncProducerMock) BeginTxn() (err error) {
	mm_atomic.AddUint64(&mmBeginTxn.beforeBeginTxnCounter, 1)
	defer mm_atomic.AddUint64(&mmBeginTxn.afterBeginTxnCounter, 1)

	mmBeginTxn.t.Helper()

	if mmBeginTxn.inspectFuncBeginTxn != nil {
		mmBeginTxn.inspectFuncBeginTxn()
	}

	if mmBeginTxn.BeginTxnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBeginTxn.BeginTxnMock.defaultExpectation.Counter, 1)

		mm_results := mmBeginTxn.BeginTxnMock.defaultExpectation.results
		if mm_results == nil {
			mmBeginTxn.t.Fatal("No results are set for the SyncProducerMock.BeginTxn")
		}
		return (*mm_results).err
	}
	if mmBeginTxn.funcBeginTxn != nil {
		return mmBeginTxn.funcBeginTxn()
	}
	mmBeginTxn.t.Fatalf("Unexpected call to SyncProducerMock.BeginTxn.")
	return
}

// BeginTxnAfterCounter returns a count of finished SyncProducerMock.BeginTxn invocations
func (mmBeginTxn *SyncProducerMock) BeginTxnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBeginTxn.afterBeginTxnCounter)
}

// BeginTxnBeforeCounter returns a count of SyncProducerMock.BeginTxn invocations
func (mmBeginTxn *SyncProducerMock) BeginTxnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBeginTxn.beforeBeginTxnCounter)
}

// MinimockBeginTxnDone returns true if the count of the BeginTxn invocations corresponds
// the number of defined expectations
func (m *SyncProducerMock) MinimockBeginTxnDone() bool {
	if m.BeginTxnMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.BeginTxnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.BeginTxnMock.invocationsDone()
}

// MinimockBeginTxnInspect logs each unmet expectation
func (m *SyncProducerMock) MinimockBeginTxnInspect() {
	for _, e := range m.BeginTxnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SyncProducerMock.BeginTxn")
		}
	}

	afterBeginTxnCounter := mm_atomic.LoadUint64(&m.afterBeginTxnCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.BeginTxnMock.defaultExpectation != nil && afterBeginTxnCounter < 1 {
		m.t.Errorf("Expected call to SyncProducerMock.BeginTxn at\n%s", m.BeginTxnMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBeginTxn != nil && afterBeginTxnCounter < 1 {
		m.t.Errorf("Expected call to SyncProducerMock.BeginTxn at\n%s", m.funcBeginTxnOrigin)
	}

	if !m.BeginTxnMock.invocationsDone() && afterBeginTxnCounter > 0 {
		m.t.Errorf("Expected %d calls to SyncProducerMock.BeginTxn at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.BeginTxnMock.expectedInvocations), m.BeginTxnMock.expectedInvocationsOrigin, afterBeginTxnCounter)
	}
}

type mSyncProducerMockClose struct {
	optional           bool
	mock               *SyncProducerMock
	defaultExpectation *SyncProducerMockCloseExpectation
	expectations       []*SyncProducerMockCloseExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SyncProducerMockCloseExpectation specifies expectation struct of the SyncProducer.Close
type SyncProducerMockCloseExpectation struct {
	mock *SyncProducerMock

	results      *SyncProducerMockCloseResults
	returnOrigin string
	Counter      uint64
}

// SyncProducerMockCloseResults contains results of the SyncProducer.Close
type SyncProducerMockCloseResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClose *mSyncProducerMockClose) Optional() *mSyncProducerMockClose {
	mmClose.optional = true
	return mmClose
}

// Expect sets up expected params for SyncProducer.Close
func (mmClose *mSyncProducerMockClose) Expect() *mSyncProducerMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("SyncProducerMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &SyncProducerMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the SyncProducer.Close
func (mmClose *mSyncProducerMockClose) Inspect(f func()) *mSyncProducerMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for SyncProducerMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by SyncProducer.Close
func (mmClose *mSyncProducerMockClose) Return(err error) *SyncProducerMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("SyncProducerMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &SyncProducerMockCloseExpectation{mock: mmClose.mock}
	}
	mmClose.defaultExpectation.results = &SyncProducerMockCloseResults{err}
	mmClose.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Set uses given function f to mock the SyncProducer.Close method
func (mmClose *mSyncProducerMockClose) Set(f func() (err error)) *SyncProducerMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the SyncProducer.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the SyncProducer.Close method")
	}

	mmClose.mock.funcClose = f
	mmClose.mock.funcCloseOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Times sets number of times SyncProducer.Close should be invoked
func (mmClose *mSyncProducerMockClose) Times(n uint64) *mSyncProducerMockClose {
	if n == 0 {
		mmClose.mock.t.Fatalf("Times of SyncProducerMock.Close mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClose.expectedInvocations, n)
	mmClose.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClose
}

func (mmClose *mSyncProducerMockClose) invocationsDone() bool {
	if len(mmClose.expectations) == 0 && mmClose.defaultExpectation == nil && mmClose.mock.funcClose == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClose.mock.afterCloseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClose.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Close implements mm_sarama.SyncProducer
func (mmClose *SyncProducerMock) Close() (err error) {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	mmClose.t.Helper()

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		mm_results := mmClose.CloseMock.defaultExpectation.results
		if mm_results == nil {
			mmClose.t.Fatal("No results are set for the SyncProducerMock.Close")
		}
		return (*mm_results).err
	}
	if mmClose.funcClose != nil {
		return mmClose.funcClose()
	}
	mmClose.t.Fatalf("Unexpected call to SyncProducerMock.Close.")
	return
}

// CloseAfterCounter returns a count of finished SyncProducerMock.Close invocations
func (mmClose *SyncProducerMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of SyncProducerMock.Close invocations
func (mmClose *SyncProducerMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *SyncProducerMock) MinimockCloseDone() bool {
	if m.CloseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CloseMock.invocationsDone()
}

// MinimockCloseInspect logs each unmet expectation
func (m *SyncProducerMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SyncProducerMock.Close")
		}
	}

	afterCloseCounter := mm_atomic.LoadUint64(&m.afterCloseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to SyncProducerMock.Close at\n%s", m.CloseMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to SyncProducerMock.Close at\n%s", m.funcCloseOrigin)
	}

	if !m.CloseMock.invocationsDone() && afterCloseCounter > 0 {
		m.t.Errorf("Expected %d calls to SyncProducerMock.Close at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CloseMock.expectedInvocations), m.CloseMock.expectedInvocationsOrigin, afterCloseCounter)
	}
}

type mSyncProducerMockCommitTxn struct {
	optional           bool
	mock               *SyncProducerMock
	defaultExpectation *SyncProducerMockCommitTxnExpectation
	expectations       []*SyncProducerMockCommitTxnExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SyncProducerMockCommitTxnExpectation specifies expectation struct of the SyncProducer.CommitTxn
type SyncProducerMockCommitTxnExpectation struct {
	mock *SyncProducerMock

	results      *SyncProducerMockCommitTxnResults
	returnOrigin string
	Counter      uint64
}

// SyncProducerMockCommitTxnResults contains results of the SyncProducer.CommitTxn
type SyncProducerMockCommitTxnResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCommitTxn *mSyncProducerMockCommitTxn) Optional() *mSyncProducerMockCommitTxn {
	mmCommitTxn.optional = true
	return mmCommitTxn
}

// Expect sets up expected params for SyncProducer.CommitTxn
func (mmCommitTxn *mSyncProducerMockCommitTxn) Expect() *mSyncProducerMockCommitTxn {
	if mmCommitTxn.mock.funcCommitTxn != nil {
		mmCommitTxn.mock.t.Fatalf("SyncProducerMock.CommitTxn mock is already set by Set")
	}

	if mmCommitTxn.defaultExpectation == nil {
		mmCommitTxn.defaultExpectation = &SyncProducerMockCommitTxnExpectation{}
	}

	return mmCommitTxn
}

// Inspect accepts an inspector function that has same arguments as the SyncProducer.CommitTxn
func (mmCommitTxn *mSyncProducerMockCommitTxn) Inspect(f func()) *mSyncProducerMockCommitTxn {
	if mmCommitTxn.mock.inspectFuncCommitTxn != nil {
		mmCommitTxn.mock.t.Fatalf("Inspect function is already set for SyncProducerMock.CommitTxn")
	}

	mmCommitTxn.mock.inspectFuncCommitTxn = f

	return mmCommitTxn
}

// Return sets up results that will be returned by SyncProducer.CommitTxn
func (mmCommitTxn *mSyncProducerMockCommitTxn) Return(err error) *SyncProducerMock {
	if mmCommitTxn.mock.funcCommitTxn != nil {
		mmCommitTxn.mock.t.Fatalf("SyncProducerMock.CommitTxn mock is already set by Set")
	}

	if mmCommitTxn.defaultExpectation == nil {
		mmCommitTxn.defaultExpectation = &SyncProducerMockCommitTxnExpectation{mock: mmCommitTxn.mock}
	}
	mmCommitTxn.defaultExpectation.results = &SyncProducerMockCommitTxnResults{err}
	mmCommitTxn.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCommitTxn.mock
}

// Set uses given function f to mock the SyncProducer.CommitTxn method
func (mmCommitTxn *mSyncProducerMockCommitTxn) Set(f func() (err error)) *SyncProducerMock {
	if mmCommitTxn.defaultExpectation != nil {
		mmCommitTxn.mock.t.Fatalf("Default expectation is already set for the SyncProducer.CommitTxn method")
	}

	if len(mmCommitTxn.expectations) > 0 {
		mmCommitTxn.mock.t.Fatalf("Some expectations are already set for the SyncProducer.CommitTxn method")
	}

	mmCommitTxn.mock.funcCommitTxn = f
	mmCommitTxn.mock.funcCommitTxnOrigin = minimock.CallerInfo(1)
	return mmCommitTxn.mock
}

// Times sets number of times SyncProducer.CommitTxn should be invoked
func (mmCommitTxn *mSyncProducerMockCommitTxn) Times(n uint64) *mSyncProducerMockCommitTxn {
	if n == 0 {
		mmCommitTxn.mock.t.Fatalf("Times of SyncProducerMock.CommitTxn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCommitTxn.expectedInvocations, n)
	mmCommitTxn.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCommitTxn
}

func (mmCommitTxn *mSyncProducerMockCommitTxn) invocationsDone() bool {
	if len(mmCommitTxn.expectations) == 0 && mmCommitTxn.defaultExpectation == nil && mmCommitTxn.mock.funcCommitTxn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCommitTxn.mock.afterCommitTxnCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCommitTxn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CommitTxn implements mm_sarama.SyncProducer
func (mmCommitTxn *SyncProducerMock) CommitTxn() (err error) {
	mm_atomic.AddUint64(&mmCommitTxn.beforeCommitTxnCounter, 1)
	defer mm_atomic.AddUint64(&mmCommitTxn.afterCommitTxnCounter, 1)

	mmCommitTxn.t.Helper()

	if mmCommitTxn.inspectFuncCommitTxn != nil {
		mmCommitTxn.inspectFuncCommitTxn()
	}

	if mmCommitTxn.CommitTxnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCommitTxn.CommitTxnMock.defaultExpectation.Counter, 1)

		mm_results := mmCommitTxn.CommitTxnMock.defaultExpectation.results
		if mm_results == nil {
			mmCommitTxn.t.Fatal("No results are set for the SyncProducerMock.CommitTxn")
		}
		return (*mm_results).err
	}
	if mmCommitTxn.funcCommitTxn != nil {
		return mmCommitTxn.funcCommitTxn()
	}
	mmCommitTxn.t.Fatalf("Unexpected call to SyncProducerMock.CommitTxn.")
	return
}

// CommitTxnAfterCounter returns a count of finished SyncProducerMock.CommitTxn invocations
func (mmCommitTxn *SyncProducerMock) CommitTxnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommitTxn.afterCommitTxnCounter)
}

// CommitTxnBeforeCounter returns a count of SyncProducerMock.CommitTxn invocations
func (mmCommitTxn *SyncProducerMock) CommitTxnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommitTxn.beforeCommitTxnCounter)
}

// MinimockCommitTxnDone returns true if the count of the CommitTxn invocations corresponds
// the number of defined expectations
func (m *SyncProducerMock) MinimockCommitTxnDone() bool {
	if m.CommitTxnMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CommitTxnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CommitTxnMock.invocationsDone()
}

// MinimockCommitTxnInspect logs each unmet expectation
func (m *SyncProducerMock) MinimockCommitTxnInspect() {
	for _, e := range m.CommitTxnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SyncProducerMock.CommitTxn")
		}
	}

	afterCommitTxnCounter := mm_atomic.LoadUint64(&m.afterCommitTxnCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CommitTxnMock.defaultExpectation != nil && afterCommitTxnCounter < 1 {
		m.t.Errorf("Expected call to SyncProducerMock.CommitTxn at\n%s", m.CommitTxnMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommitTxn != nil && afterCommitTxnCounter < 1 {
		m.t.Errorf("Expected call to SyncProducerMock.CommitTxn at\n%s", m.funcCommitTxnOrigin)
	}

	if !m.CommitTxnMock.invocationsDone() && afterCommitTxnCounter > 0 {
		m.t.Errorf("Expected %d calls to SyncProducerMock.CommitTxn at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CommitTxnMock.expectedInvocations), m.CommitTxnMock.expectedInvocationsOrigin, afterCommitTxnCounter)
	}
}

type mSyncProducerMockIsTransactional struct {
	optional           bool
	mock               *SyncProducerMock
	defaultExpectation *SyncProducerMockIsTransactionalExpectation
	expectations       []*SyncProducerMockIsTransactionalExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SyncProducerMockIsTransactionalExpectation specifies expectation struct of the SyncProducer.IsTransactional
type SyncProducerMockIsTransactionalExpectation struct {
	mock *SyncProducerMock

	results      *SyncProducerMockIsTransactionalResults
	returnOrigin string
	Counter      uint64
}

// SyncProducerMockIsTransactionalResults contains results of the SyncProducer.IsTransactional
type SyncProducerMockIsTransactionalResults struct {
	b1 bool
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsTransactional *mSyncProducerMockIsTransactional) Optional() *mSyncProducerMockIsTransactional {
	mmIsTransactional.optional = true
	return mmIsTransactional
}

// Expect sets up expected params for SyncProducer.IsTransactional
func (mmIsTransactional *mSyncProducerMockIsTransactional) Expect() *mSyncProducerMockIsTransactional {
	if mmIsTransactional.mock.funcIsTransactional != nil {
		mmIsTransactional.mock.t.Fatalf("SyncProducerMock.IsTransactional mock is already set by Set")
	}

	if mmIsTransactional.defaultExpectation == nil {
		mmIsTransactional.defaultExpectation = &SyncProducerMockIsTransactionalExpectation{}
	}

	return mmIsTransactional
}

// Inspect accepts an inspector function that has same arguments as the SyncProducer.IsTransactional
func (mmIsTransactional *mSyncProducerMockIsTransactional) Inspect(f func()) *mSyncProducerMockIsTransactional {
	if mmIsTransactional.mock.inspectFuncIsTransactional != nil {
		mmIsTransactional.mock.t.Fatalf("Inspect function is already set for SyncProducerMock.IsTransactional")
	}

	mmIsTransactional.mock.inspectFuncIsTransactional = f

	return mmIsTransactional
}

// Return sets up results that will be returned by SyncProducer.IsTransactional
func (mmIsTransactional *mSyncProducerMockIsTransactional) Return(b1 bool) *SyncProducerMock {
	if mmIsTransactional.mock.funcIsTransactional != nil {
		mmIsTransactional.mock.t.Fatalf("SyncProducerMock.IsTransactional mock is already set by Set")
	}

	if mmIsTransactional.defaultExpectation == nil {
		mmIsTransactional.defaultExpectation = &SyncProducerMockIsTransactionalExpectation{mock: mmIsTransactional.mock}
	}
	mmIsTransactional.defaultExpectation.results = &SyncProducerMockIsTransactionalResults{b1}
	mmIsTransactional.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIsTransactional.mock
}

// Set uses given function f to mock the SyncProducer.IsTransactional method
func (mmIsTransactional *mSyncProducerMockIsTransactional) Set(f func() (b1 bool)) *SyncProducerMock {
	if mmIsTransactional.defaultExpectation != nil {
		mmIsTransactional.mock.t.Fatalf("Default expectation is already set for the SyncProducer.IsTransactional method")
	}

	if len(mmIsTransactional.expectations) > 0 {
		mmIsTransactional.mock.t.Fatalf("Some expectations are already set for the SyncProducer.IsTransactional method")
	}

	mmIsTransactional.mock.funcIsTransactional = f
	mmIsTransactional.mock.funcIsTransactionalOrigin = minimock.CallerInfo(1)
	return mmIsTransactional.mock
}

// Times sets number of times SyncProducer.IsTransactional should be invoked
func (mmIsTransactional *mSyncProducerMockIsTransactional) Times(n uint64) *mSyncProducerMockIsTransactional {
	if n == 0 {
		mmIsTransactional.mock.t.Fatalf("Times of SyncProducerMock.IsTransactional mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIsTransactional.expectedInvocations, n)
	mmIsTransactional.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIsTransactional
}

func (mmIsTransactional *mSyncProducerMockIsTransactional) invocationsDone() bool {
	if len(mmIsTransactional.expectations) == 0 && mmIsTransactional.defaultExpectation == nil && mmIsTransactional.mock.funcIsTransactional == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIsTransactional.mock.afterIsTransactionalCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIsTransactional.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IsTransactional implements mm_sarama.SyncProducer
func (mmIsTransactional *SyncProducerMock) IsTransactional() (b1 bool) {
	mm_atomic.AddUint64(&mmIsTransactional.beforeIsTransactionalCounter, 1)
	defer mm_atomic.AddUint64(&mmIsTransactional.afterIsTransactionalCounter, 1)

	mmIsTransactional.t.Helper()

	if mmIsTransactional.inspectFuncIsTransactional != nil {
		mmIsTransactional.inspectFuncIsTransactional()
	}

	if mmIsTransactional.IsTransactionalMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsTransactional.IsTransactionalMock.defaultExpectation.Counter, 1)

		mm_results := mmIsTransactional.IsTransactionalMock.defaultExpectation.results
		if mm_results == nil {
			mmIsTransactional.t.Fatal("No results are set for the SyncProducerMock.IsTransactional")
		}
		return (*mm_results).b1
	}
	if mmIsTransactional.funcIsTransactional != nil {
		return mmIsTransactional.funcIsTransactional()
	}
	mmIsTransactional.t.Fatalf("Unexpected call to SyncProducerMock.IsTransactional.")
	return
}

// IsTransactionalAfterCounter returns a count of finished SyncProducerMock.IsTransactional invocations
func (mmIsTransactional *SyncProducerMock) IsTransactionalAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsTransactional.afterIsTransactionalCounter)
}

// IsTransactionalBeforeCounter returns a count of SyncProducerMock.IsTransactional invocations
func (mmIsTransactional *SyncProducerMock) IsTransactionalBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsTransactional.beforeIsTransactionalCounter)
}

// MinimockIsTransactionalDone returns true if the count of the IsTransactional invocations corresponds
// the number of defined expectations
func (m *SyncProducerMock) MinimockIsTransactionalDone() bool {
	if m.IsTransactionalMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IsTransactionalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IsTransactionalMock.invocationsDone()
}

// MinimockIsTransactionalInspect logs each unmet expectation
func (m *SyncProducerMock) MinimockIsTransactionalInspect() {
	for _, e := range m.IsTransactionalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SyncProducerMock.IsTransactional")
		}
	}

	afterIsTransactionalCounter := mm_atomic.LoadUint64(&m.afterIsTransactionalCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IsTransactionalMock.defaultExpectation != nil && afterIsTransactionalCounter < 1 {
		m.t.Errorf("Expected call to SyncProducerMock.IsTransactional at\n%s", m.IsTransactionalMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsTransactional != nil && afterIsTransactionalCounter < 1 {
		m.t.Errorf("Expected call to SyncProducerMock.IsTransactional at\n%s", m.funcIsTransactionalOrigin)
	}

	if !m.IsTransactionalMock.invocationsDone() && afterIsTransactionalCounter > 0 {
		m.t.Errorf("Expected %d calls to SyncProducerMock.IsTransactional at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IsTransactionalMock.expectedInvocations), m.IsTransactionalMock.expectedInvocationsOrigin, afterIsTransactionalCounter)
	}
}

type mSyncProducerMockSendMessage struct {
	optional           bool
	mock               *SyncProducerMock
	defaultExpectation *SyncProducerMockSendMessageExpectation
	expectations       []*SyncProducerMockSendMessageExpectation

	callArgs []*SyncProducerMockSendMessageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SyncProducerMockSendMessageExpectation specifies expectation struct of the SyncProducer.SendMessage
type SyncProducerMockSendMessageExpectation struct {
	mock               *SyncProducerMock
	params             *SyncProducerMockSendMessageParams
	paramPtrs          *SyncProducerMockSendMessageParamPtrs
	expectationOrigins SyncProducerMockSendMessageExpectationOrigins
	results            *SyncProducerMockSendMessageResults
	returnOrigin       string
	Counter            uint64
}

// SyncProducerMockSendMessageParams contains parameters of the SyncProducer.SendMessage
type SyncProducerMockSendMessageParams struct {
	msg *mm_sarama.ProducerMessage
}

// SyncProducerMockSendMessageParamPtrs contains pointers to parameters of the SyncProducer.SendMessage
type SyncProducerMockSendMessageParamPtrs struct {
	msg **mm_sarama.ProducerMessage
}

// SyncProducerMockSendMessageResults contains results of the SyncProducer.SendMessage
type SyncProducerMockSendMessageResults struct {
	partition int32
	offset    int64
	err       error
}

// SyncProducerMockSendMessageOrigins contains origins of expectations of the SyncProducer.SendMessage
type SyncProducerMockSendMessageExpectationOrigins struct {
	origin    string
	originMsg string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSendMessage *mSyncProducerMockSendMessage) Optional() *mSyncProducerMockSendMessage {
	mmSendMessage.optional = true
	return mmSendMessage
}

// Expect sets up expected params for SyncProducer.SendMessage
func (mmSendMessage *mSyncProducerMockSendMessage) Expect(msg *mm_sarama.ProducerMessage) *mSyncProducerMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("SyncProducerMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &SyncProducerMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.paramPtrs != nil {
		mmSendMessage.mock.t.Fatalf("SyncProducerMock.SendMessage mock is already set by ExpectParams functions")
	}

	mmSendMessage.defaultExpectation.params = &SyncProducerMockSendMessageParams{msg}
	mmSendMessage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSendMessage.expectations {
		if minimock.Equal(e.params, mmSendMessage.defaultExpectation.params) {
			mmSendMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendMessage.defaultExpectation.params)
		}
	}

	return mmSendMessage
}

// ExpectMsgParam1 sets up expected param msg for SyncProducer.SendMessage
func (mmSendMessage *mSyncProducerMockSendMessage) ExpectMsgParam1(msg *mm_sarama.ProducerMessage) *mSyncProducerMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("SyncProducerMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &SyncProducerMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.params != nil {
		mmSendMessage.mock.t.Fatalf("SyncProducerMock.SendMessage mock is already set by Expect")
	}

	if mmSendMessage.defaultExpectation.paramPtrs == nil {
		mmSendMessage.defaultExpectation.paramPtrs = &SyncProducerMockSendMessageParamPtrs{}
	}
	mmSendMessage.defaultExpectation.paramPtrs.msg = &msg
	mmSendMessage.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmSendMessage
}

// Inspect accepts an inspector function that has same arguments as the SyncProducer.SendMessage
func (mmSendMessage *mSyncProducerMockSendMessage) Inspect(f func(msg *mm_sarama.ProducerMessage)) *mSyncProducerMockSendMessage {
	if mmSendMessage.mock.inspectFuncSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("Inspect function is already set for SyncProducerMock.SendMessage")
	}

	mmSendMessage.mock.inspectFuncSendMessage = f

	return mmSendMessage
}

// Return sets up results that will be returned by SyncProducer.SendMessage
func (mmSendMessage *mSyncProducerMockSendMessage) Return(partition int32, offset int64, err error) *SyncProducerMock {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("SyncProducerMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &SyncProducerMockSendMessageExpectation{mock: mmSendMessage.mock}
	}
	mmSendMessage.defaultExpectation.results = &SyncProducerMockSendMessageResults{partition, offset, err}
	mmSendMessage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSendMessage.mock
}

// Set uses given function f to mock the SyncProducer.SendMessage method
func (mmSendMessage *mSyncProducerMockSendMessage) Set(f func(msg *mm_sarama.ProducerMessage) (partition int32, offset int64, err error)) *SyncProducerMock {
	if mmSendMessage.defaultExpectation != nil {
		mmSendMessage.mock.t.Fatalf("Default expectation is already set for the SyncProducer.SendMessage method")
	}

	if len(mmSendMessage.expectations) > 0 {
		mmSendMessage.mock.t.Fatalf("Some expectations are already set for the SyncProducer.SendMessage method")
	}

	mmSendMessage.mock.funcSendMessage = f
	mmSendMessage.mock.funcSendMessageOrigin = minimock.CallerInfo(1)
	return mmSendMessage.mock
}

// When sets expectation for the SyncProducer.SendMessage which will trigger the result defined by the following
// Then helper
func (mmSendMessage *mSyncProducerMockSendMessage) When(msg *mm_sarama.ProducerMessage) *SyncProducerMockSendMessageExpectation {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("SyncProducerMock.SendMessage mock is already set by Set")
	}

	expectation := &SyncProducerMockSendMessageExpectation{
		mock:               mmSendMessage.mock,
		params:             &SyncProducerMockSendMessageParams{msg},
		expectationOrigins: SyncProducerMockSendMessageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSendMessage.expectations = append(mmSendMessage.expectations, expectation)
	return expectation
}

// Then sets up SyncProducer.SendMessage return parameters for the expectation previously defined by the When method
func (e *SyncProducerMockSendMessageExpectation) Then(partition int32, offset int64, err error) *SyncProducerMock {
	e.results = &SyncProducerMockSendMessageResults{partition, offset, err}
	return e.mock
}

// Times sets number of times SyncProducer.SendMessage should be invoked
func (mmSendMessage *mSyncProducerMockSendMessage) Times(n uint64) *mSyncProducerMockSendMessage {
	if n == 0 {
		mmSendMessage.mock.t.Fatalf("Times of SyncProducerMock.SendMessage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSendMessage.expectedInvocations, n)
	mmSendMessage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSendMessage
}

func (mmSendMessage *mSyncProducerMockSendMessage) invocationsDone() bool {
	if len(mmSendMessage.expectations) == 0 && mmSendMessage.defaultExpectation == nil && mmSendMessage.mock.funcSendMessage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSendMessage.mock.afterSendMessageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSendMessage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SendMessage implements mm_sarama.SyncProducer
func (mmSendMessage *SyncProducerMock) SendMessage(msg *mm_sarama.ProducerMessage) (partition int32, offset int64, err error) {
	mm_atomic.AddUint64(&mmSendMessage.beforeSendMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmSendMessage.afterSendMessageCounter, 1)

	mmSendMessage.t.Helper()

	if mmSendMessage.inspectFuncSendMessage != nil {
		mmSendMessage.inspectFuncSendMessage(msg)
	}

	mm_params := SyncProducerMockSendMessageParams{msg}

	// Record call args
	mmSendMessage.SendMessageMock.mutex.Lock()
	mmSendMessage.SendMessageMock.callArgs = append(mmSendMessage.SendMessageMock.callArgs, &mm_params)
	mmSendMessage.SendMessageMock.mutex.Unlock()

	for _, e := range mmSendMessage.SendMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.partition, e.results.offset, e.results.err
		}
	}

	if mmSendMessage.SendMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendMessage.SendMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmSendMessage.SendMessageMock.defaultExpectation.params
		mm_want_ptrs := mmSendMessage.SendMessageMock.defaultExpectation.paramPtrs

		mm_got := SyncProducerMockSendMessageParams{msg}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmSendMessage.t.Errorf("SyncProducerMock.SendMessage got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendMessage.SendMessageMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendMessage.t.Errorf("SyncProducerMock.SendMessage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSendMessage.SendMessageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendMessage.SendMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmSendMessage.t.Fatal("No results are set for the SyncProducerMock.SendMessage")
		}
		return (*mm_results).partition, (*mm_results).offset, (*mm_results).err
	}
	if mmSendMessage.funcSendMessage != nil {
		return mmSendMessage.funcSendMessage(msg)
	}
	mmSendMessage.t.Fatalf("Unexpected call to SyncProducerMock.SendMessage. %v", msg)
	return
}

// SendMessageAfterCounter returns a count of finished SyncProducerMock.SendMessage invocations
func (mmSendMessage *SyncProducerMock) SendMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.afterSendMessageCounter)
}

// SendMessageBeforeCounter returns a count of SyncProducerMock.SendMessage invocations
func (mmSendMessage *SyncProducerMock) SendMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.beforeSendMessageCounter)
}

// Calls returns a list of arguments used in each call to SyncProducerMock.SendMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendMessage *mSyncProducerMockSendMessage) Calls() []*SyncProducerMockSendMessageParams {
	mmSendMessage.mutex.RLock()

	argCopy := make([]*SyncProducerMockSendMessageParams, len(mmSendMessage.callArgs))
	copy(argCopy, mmSendMessage.callArgs)

	mmSendMessage.mutex.RUnlock()

	return argCopy
}

// MinimockSendMessageDone returns true if the count of the SendMessage invocations corresponds
// the number of defined expectations
func (m *SyncProducerMock) MinimockSendMessageDone() bool {
	if m.SendMessageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendMessageMock.invocationsDone()
}

// MinimockSendMessageInspect logs each unmet expectation
func (m *SyncProducerMock) MinimockSendMessageInspect() {
	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SyncProducerMock.SendMessage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSendMessageCounter := mm_atomic.LoadUint64(&m.afterSendMessageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageMock.defaultExpectation != nil && afterSendMessageCounter < 1 {
		if m.SendMessageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SyncProducerMock.SendMessage at\n%s", m.SendMessageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SyncProducerMock.SendMessage at\n%s with params: %#v", m.SendMessageMock.defaultExpectation.expectationOrigins.origin, *m.SendMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessage != nil && afterSendMessageCounter < 1 {
		m.t.Errorf("Expected call to SyncProducerMock.SendMessage at\n%s", m.funcSendMessageOrigin)
	}

	if !m.SendMessageMock.invocationsDone() && afterSendMessageCounter > 0 {
		m.t.Errorf("Expected %d calls to SyncProducerMock.SendMessage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SendMessageMock.expectedInvocations), m.SendMessageMock.expectedInvocationsOrigin, afterSendMessageCounter)
	}
}

type mSyncProducerMockSendMessages struct {
	optional           bool
	mock               *SyncProducerMock
	defaultExpectation *SyncProducerMockSendMessagesExpectation
	expectations       []*SyncProducerMockSendMessagesExpectation

	callArgs []*SyncProducerMockSendMessagesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SyncProducerMockSendMessagesExpectation specifies expectation struct of the SyncProducer.SendMessages
type SyncProducerMockSendMessagesExpectation struct {
	mock               *SyncProducerMock
	params             *SyncProducerMockSendMessagesParams
	paramPtrs          *SyncProducerMockSendMessagesParamPtrs
	expectationOrigins SyncProducerMockSendMessagesExpectationOrigins
	results            *SyncProducerMockSendMessagesResults
	returnOrigin       string
	Counter            uint64
}

// SyncProducerMockSendMessagesParams contains parameters of the SyncProducer.SendMessages
type SyncProducerMockSendMessagesParams struct {
	msgs []*mm_sarama.ProducerMessage
}

// SyncProducerMockSendMessagesParamPtrs contains pointers to parameters of the SyncProducer.SendMessages
type SyncProducerMockSendMessagesParamPtrs struct {
	msgs *[]*mm_sarama.ProducerMessage
}

// SyncProducerMockSendMessagesResults contains results of the SyncProducer.SendMessages
type SyncProducerMockSendMessagesResults struct {
	err error
}

// SyncProducerMockSendMessagesOrigins contains origins of expectations of the SyncProducer.SendMessages
type SyncProducerMockSendMessagesExpectationOrigins struct {
	origin     string
	originMsgs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSendMessages *mSyncProducerMockSendMessages) Optional() *mSyncProducerMockSendMessages {
	mmSendMessages.optional = true
	return mmSendMessages
}

// Expect sets up expected params for SyncProducer.SendMessages
func (mmSendMessages *mSyncProducerMockSendMessages) Expect(msgs []*mm_sarama.ProducerMessage) *mSyncProducerMockSendMessages {
	if mmSendMessages.mock.funcSendMessages != nil {
		mmSendMessages.mock.t.Fatalf("SyncProducerMock.SendMessages mock is already set by Set")
	}

	if mmSendMessages.defaultExpectation == nil {
		mmSendMessages.defaultExpectation = &SyncProducerMockSendMessagesExpectation{}
	}

	if mmSendMessages.defaultExpectation.paramPtrs != nil {
		mmSendMessages.mock.t.Fatalf("SyncProducerMock.SendMessages mock is already set by ExpectParams functions")
	}

	mmSendMessages.defaultExpectation.params = &SyncProducerMockSendMessagesParams{msgs}
	mmSendMessages.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSendMessages.expectations {
		if minimock.Equal(e.params, mmSendMessages.defaultExpectation.params) {
			mmSendMessages.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendMessages.defaultExpectation.params)
		}
	}

	return mmSendMessages
}

// ExpectMsgsParam1 sets up expected param msgs for SyncProducer.SendMessages
func (mmSendMessages *mSyncProducerMockSendMessages) ExpectMsgsParam1(msgs []*mm_sarama.ProducerMessage) *mSyncProducerMockSendMessages {
	if mmSendMessages.mock.funcSendMessages != nil {
		mmSendMessages.mock.t.Fatalf("SyncProducerMock.SendMessages mock is already set by Set")
	}

	if mmSendMessages.defaultExpectation == nil {
		mmSendMessages.defaultExpectation = &SyncProducerMockSendMessagesExpectation{}
	}

	if mmSendMessages.defaultExpectation.params != nil {
		mmSendMessages.mock.t.Fatalf("SyncProducerMock.SendMessages mock is already set by Expect")
	}

	if mmSendMessages.defaultExpectation.paramPtrs == nil {
		mmSendMessages.defaultExpectation.paramPtrs = &SyncProducerMockSendMessagesParamPtrs{}
	}
	mmSendMessages.defaultExpectation.paramPtrs.msgs = &msgs
	mmSendMessages.defaultExpectation.expectationOrigins.originMsgs = minimock.CallerInfo(1)

	return mmSendMessages
}

// Inspect accepts an inspector function that has same arguments as the SyncProducer.SendMessages
func (mmSendMessages *mSyncProducerMockSendMessages) Inspect(f func(msgs []*mm_sarama.ProducerMessage)) *mSyncProducerMockSendMessages {
	if mmSendMessages.mock.inspectFuncSendMessages != nil {
		mmSendMessages.mock.t.Fatalf("Inspect function is already set for SyncProducerMock.SendMessages")
	}

	mmSendMessages.mock.inspectFuncSendMessages = f

	return mmSendMessages
}

// Return sets up results that will be returned by SyncProducer.SendMessages
func (mmSendMessages *mSyncProducerMockSendMessages) Return(err error) *SyncProducerMock {
	if mmSendMessages.mock.funcSendMessages != nil {
		mmSendMessages.mock.t.Fatalf("SyncProducerMock.SendMessages mock is already set by Set")
	}

	if mmSendMessages.defaultExpectation == nil {
		mmSendMessages.defaultExpectation = &SyncProducerMockSendMessagesExpectation{mock: mmSendMessages.mock}
	}
	mmSendMessages.defaultExpectation.results = &SyncProducerMockSendMessagesResults{err}
	mmSendMessages.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSendMessages.mock
}

// Set uses given function f to mock the SyncProducer.SendMessages method
func (mmSendMessages *mSyncProducerMockSendMessages) Set(f func(msgs []*mm_sarama.ProducerMessage) (err error)) *SyncProducerMock {
	if mmSendMessages.defaultExpectation != nil {
		mmSendMessages.mock.t.Fatalf("Default expectation is already set for the SyncProducer.SendMessages method")
	}

	if len(mmSendMessages.expectations) > 0 {
		mmSendMessages.mock.t.Fatalf("Some expectations are already set for the SyncProducer.SendMessages method")
	}

	mmSendMessages.mock.funcSendMessages = f
	mmSendMessages.mock.funcSendMessagesOrigin = minimock.CallerInfo(1)
	return mmSendMessages.mock
}

// When sets expectation for the SyncProducer.SendMessages which will trigger the result defined by the following
// Then helper
func (mmSendMessages *mSyncProducerMockSendMessages) When(msgs []*mm_sarama.ProducerMessage) *SyncProducerMockSendMessagesExpectation {
	if mmSendMessages.mock.funcSendMessages != nil {
		mmSendMessages.mock.t.Fatalf("SyncProducerMock.SendMessages mock is already set by Set")
	}

	expectation := &SyncProducerMockSendMessagesExpectation{
		mock:               mmSendMessages.mock,
		params:             &SyncProducerMockSendMessagesParams{msgs},
		expectationOrigins: SyncProducerMockSendMessagesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSendMessages.expectations = append(mmSendMessages.expectations, expectation)
	return expectation
}

// Then sets up SyncProducer.SendMessages return parameters for the expectation previously defined by the When method
func (e *SyncProducerMockSendMessagesExpectation) Then(err error) *SyncProducerMock {
	e.results = &SyncProducerMockSendMessagesResults{err}
	return e.mock
}

// Times sets number of times SyncProducer.SendMessages should be invoked
func (mmSendMessages *mSyncProducerMockSendMessages) Times(n uint64) *mSyncProducerMockSendMessages {
	if n == 0 {
		mmSendMessages.mock.t.Fatalf("Times of SyncProducerMock.SendMessages mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSendMessages.expectedInvocations, n)
	mmSendMessages.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSendMessages
}

func (mmSendMessages *mSyncProducerMockSendMessages) invocationsDone() bool {
	if len(mmSendMessages.expectations) == 0 && mmSendMessages.defaultExpectation == nil && mmSendMessages.mock.funcSendMessages == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSendMessages.mock.afterSendMessagesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSendMessages.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SendMessages implements mm_sarama.SyncProducer
func (mmSendMessages *SyncProducerMock) SendMessages(msgs []*mm_sarama.ProducerMessage) (err error) {
	mm_atomic.AddUint64(&mmSendMessages.beforeSendMessagesCounter, 1)
	defer mm_atomic.AddUint64(&mmSendMessages.afterSendMessagesCounter, 1)

	mmSendMessages.t.Helper()

	if mmSendMessages.inspectFuncSendMessages != nil {
		mmSendMessages.inspectFuncSendMessages(msgs)
	}

	mm_params := SyncProducerMockSendMessagesParams{msgs}

	// Record call args
	mmSendMessages.SendMessagesMock.mutex.Lock()
	mmSendMessages.SendMessagesMock.callArgs = append(mmSendMessages.SendMessagesMock.callArgs, &mm_params)
	mmSendMessages.SendMessagesMock.mutex.Unlock()

	for _, e := range mmSendMessages.SendMessagesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendMessages.SendMessagesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendMessages.SendMessagesMock.defaultExpectation.Counter, 1)
		mm_want := mmSendMessages.SendMessagesMock.defaultExpectation.params
		mm_want_ptrs := mmSendMessages.SendMessagesMock.defaultExpectation.paramPtrs

		mm_got := SyncProducerMockSendMessagesParams{msgs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msgs != nil && !minimock.Equal(*mm_want_ptrs.msgs, mm_got.msgs) {
				mmSendMessages.t.Errorf("SyncProducerMock.SendMessages got unexpected parameter msgs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendMessages.SendMessagesMock.defaultExpectation.expectationOrigins.originMsgs, *mm_want_ptrs.msgs, mm_got.msgs, minimock.Diff(*mm_want_ptrs.msgs, mm_got.msgs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendMessages.t.Errorf("SyncProducerMock.SendMessages got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSendMessages.SendMessagesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendMessages.SendMessagesMock.defaultExpectation.results
		if mm_results == nil {
			mmSendMessages.t.Fatal("No results are set for the SyncProducerMock.SendMessages")
		}
		return (*mm_results).err
	}
	if mmSendMessages.funcSendMessages != nil {
		return mmSendMessages.funcSendMessages(msgs)
	}
	mmSendMessages.t.Fatalf("Unexpected call to SyncProducerMock.SendMessages. %v", msgs)
	return
}

// SendMessagesAfterCounter returns a count of finished SyncProducerMock.SendMessages invocations
func (mmSendMessages *SyncProducerMock) SendMessagesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessages.afterSendMessagesCounter)
}

// SendMessagesBeforeCounter returns a count of SyncProducerMock.SendMessages invocations
func (mmSendMessages *SyncProducerMock) SendMessagesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessages.beforeSendMessagesCounter)
}

// Calls returns a list of arguments used in each call to SyncProducerMock.SendMessages.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendMessages *mSyncProducerMockSendMessages) Calls() []*SyncProducerMockSendMessagesParams {
	mmSendMessages.mutex.RLock()

	argCopy := make([]*SyncProducerMockSendMessagesParams, len(mmSendMessages.callArgs))
	copy(argCopy, mmSendMessages.callArgs)

	mmSendMessages.mutex.RUnlock()

	return argCopy
}

// MinimockSendMessagesDone returns true if the count of the SendMessages invocations corresponds
// the number of defined expectations
func (m *SyncProducerMock) MinimockSendMessagesDone() bool {
	if m.SendMessagesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendMessagesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendMessagesMock.invocationsDone()
}

// MinimockSendMessagesInspect logs each unmet expectation
func (m *SyncProducerMock) MinimockSendMessagesInspect() {
	for _, e := range m.SendMessagesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SyncProducerMock.SendMessages at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSendMessagesCounter := mm_atomic.LoadUint64(&m.afterSendMessagesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessagesMock.defaultExpectation != nil && afterSendMessagesCounter < 1 {
		if m.SendMessagesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SyncProducerMock.SendMessages at\n%s", m.SendMessagesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SyncProducerMock.SendMessages at\n%s with params: %#v", m.SendMessagesMock.defaultExpectation.expectationOrigins.origin, *m.SendMessagesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessages != nil && afterSendMessagesCounter < 1 {
		m.t.Errorf("Expected call to SyncProducerMock.SendMessages at\n%s", m.funcSendMessagesOrigin)
	}

	if !m.SendMessagesMock.invocationsDone() && afterSendMessagesCounter > 0 {
		m.t.Errorf("Expected %d calls to SyncProducerMock.SendMessages at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SendMessagesMock.expectedInvocations), m.SendMessagesMock.expectedInvocationsOrigin, afterSendMessagesCounter)
	}
}

type mSyncProducerMockTxnStatus struct {
	optional           bool
	mock               *SyncProducerMock
	defaultExpectation *SyncProducerMockTxnStatusExpectation
	expectations       []*SyncProducerMockTxnStatusExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SyncProducerMockTxnStatusExpectation specifies expectation struct of the SyncProducer.TxnStatus
type SyncProducerMockTxnStatusExpectation struct {
	mock *SyncProducerMock

	results      *SyncProducerMockTxnStatusResults
	returnOrigin string
	Counter      uint64
}

// SyncProducerMockTxnStatusResults contains results of the SyncProducer.TxnStatus
type SyncProducerMockTxnStatusResults struct {
	p1 mm_sarama.ProducerTxnStatusFlag
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTxnStatus *mSyncProducerMockTxnStatus) Optional() *mSyncProducerMockTxnStatus {
	mmTxnStatus.optional = true
	return mmTxnStatus
}

// Expect sets up expected params for SyncProducer.TxnStatus
func (mmTxnStatus *mSyncProducerMockTxnStatus) Expect() *mSyncProducerMockTxnStatus {
	if mmTxnStatus.mock.funcTxnStatus != nil {
		mmTxnStatus.mock.t.Fatalf("SyncProducerMock.TxnStatus mock is already set by Set")
	}

	if mmTxnStatus.defaultExpectation == nil {
		mmTxnStatus.defaultExpectation = &SyncProducerMockTxnStatusExpectation{}
	}

	return mmTxnStatus
}

// Inspect accepts an inspector function that has same arguments as the SyncProducer.TxnStatus
func (mmTxnStatus *mSyncProducerMockTxnStatus) Inspect(f func()) *mSyncProducerMockTxnStatus {
	if mmTxnStatus.mock.inspectFuncTxnStatus != nil {
		mmTxnStatus.mock.t.Fatalf("Inspect function is already set for SyncProducerMock.TxnStatus")
	}

	mmTxnStatus.mock.inspectFuncTxnStatus = f

	return mmTxnStatus
}

// Return sets up results that will be returned by SyncProducer.TxnStatus
func (mmTxnStatus *mSyncProducerMockTxnStatus) Return(p1 mm_sarama.ProducerTxnStatusFlag) *SyncProducerMock {
	if mmTxnStatus.mock.funcTxnStatus != nil {
		mmTxnStatus.mock.t.Fatalf("SyncProducerMock.TxnStatus mock is already set by Set")
	}

	if mmTxnStatus.defaultExpectation == nil {
		mmTxnStatus.defaultExpectation = &SyncProducerMockTxnStatusExpectation{mock: mmTxnStatus.mock}
	}
	mmTxnStatus.defaultExpectation.results = &SyncProducerMockTxnStatusResults{p1}
	mmTxnStatus.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTxnStatus.mock
}

// Set uses given function f to mock the SyncProducer.TxnStatus method
func (mmTxnStatus *mSyncProducerMockTxnStatus) Set(f func() (p1 mm_sarama.ProducerTxnStatusFlag)) *SyncProducerMock {
	if mmTxnStatus.defaultExpectation != nil {
		mmTxnStatus.mock.t.Fatalf("Default expectation is already set for the SyncProducer.TxnStatus method")
	}

	if len(mmTxnStatus.expectations) > 0 {
		mmTxnStatus.mock.t.Fatalf("Some expectations are already set for the SyncProducer.TxnStatus method")
	}

	mmTxnStatus.mock.funcTxnStatus = f
	mmTxnStatus.mock.funcTxnStatusOrigin = minimock.CallerInfo(1)
	return mmTxnStatus.mock
}

// Times sets number of times SyncProducer.TxnStatus should be invoked
func (mmTxnStatus *mSyncProducerMockTxnStatus) Times(n uint64) *mSyncProducerMockTxnStatus {
	if n == 0 {
		mmTxnStatus.mock.t.Fatalf("Times of SyncProducerMock.TxnStatus mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTxnStatus.expectedInvocations, n)
	mmTxnStatus.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTxnStatus
}

func (mmTxnStatus *mSyncProducerMockTxnStatus) invocationsDone() bool {
	if len(mmTxnStatus.expectations) == 0 && mmTxnStatus.defaultExpectation == nil && mmTxnStatus.mock.funcTxnStatus == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTxnStatus.mock.afterTxnStatusCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTxnStatus.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TxnStatus implements mm_sarama.SyncProducer
func (mmTxnStatus *SyncProducerMock) TxnStatus() (p1 mm_sarama.ProducerTxnStatusFlag) {
	mm_atomic.AddUint64(&mmTxnStatus.beforeTxnStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmTxnStatus.afterTxnStatusCounter, 1)

	mmTxnStatus.t.Helper()

	if mmTxnStatus.inspectFuncTxnStatus != nil {
		mmTxnStatus.inspectFuncTxnStatus()
	}

	if mmTxnStatus.TxnStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTxnStatus.TxnStatusMock.defaultExpectation.Counter, 1)

		mm_results := mmTxnStatus.TxnStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmTxnStatus.t.Fatal("No results are set for the SyncProducerMock.TxnStatus")
		}
		return (*mm_results).p1
	}
	if mmTxnStatus.funcTxnStatus != nil {
		return mmTxnStatus.funcTxnStatus()
	}
	mmTxnStatus.t.Fatalf("Unexpected call to SyncProducerMock.TxnStatus.")
	return
}

// TxnStatusAfterCounter returns a count of finished SyncProducerMock.TxnStatus invocations
func (mmTxnStatus *SyncProducerMock) TxnStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTxnStatus.afterTxnStatusCounter)
}

// TxnStatusBeforeCounter returns a count of SyncProducerMock.TxnStatus invocations
func (mmTxnStatus *SyncProducerMock) TxnStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTxnStatus.beforeTxnStatusCounter)
}

// MinimockTxnStatusDone returns true if the count of the TxnStatus invocations corresponds
// the number of defined expectations
func (m *SyncProducerMock) MinimockTxnStatusDone() bool {
	if m.TxnStatusMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TxnStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TxnStatusMock.invocationsDone()
}

// MinimockTxnStatusInspect logs each unmet expectation
func (m *SyncProducerMock) MinimockTxnStatusInspect() {
	for _, e := range m.TxnStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SyncProducerMock.TxnStatus")
		}
	}

	afterTxnStatusCounter := mm_atomic.LoadUint64(&m.afterTxnStatusCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TxnStatusMock.defaultExpectation != nil && afterTxnStatusCounter < 1 {
		m.t.Errorf("Expected call to SyncProducerMock.TxnStatus at\n%s", m.TxnStatusMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTxnStatus != nil && afterTxnStatusCounter < 1 {
		m.t.Errorf("Expected call to SyncProducerMock.TxnStatus at\n%s", m.funcTxnStatusOrigin)
	}

	if !m.TxnStatusMock.invocationsDone() && afterTxnStatusCounter > 0 {
		m.t.Errorf("Expected %d calls to SyncProducerMock.TxnStatus at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TxnStatusMock.expectedInvocations), m.TxnStatusMock.expectedInvocationsOrigin, afterTxnStatusCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SyncProducerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAbortTxnInspect()

			m.MinimockAddMessageToTxnInspect()

			m.MinimockAddOffsetsToTxnInspect()

			m.MinimockBeginTxnInspect()

			m.MinimockCloseInspect()

			m.MinimockCommitTxnInspect()

			m.MinimockIsTransactionalInspect()

			m.MinimockSendMessageInspect()

			m.MinimockSendMessagesInspect()

			m.MinimockTxnStatusInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SyncProducerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SyncProducerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAbortTxnDone() &&
		m.MinimockAddMessageToTxnDone() &&
		m.MinimockAddOffsetsToTxnDone() &&
		m.MinimockBeginTxnDone() &&
		m.MinimockCloseDone() &&
		m.MinimockCommitTxnDone() &&
		m.MinimockIsTransactionalDone() &&
		m.MinimockSendMessageDone() &&
		m.MinimockSendMessagesDone() &&
		m.MinimockTxnStatusDone()
}
