##### .gitignore #####
bin/
tutor_makefile.mk
/vendor.protogen
.idea/
config/.env
config/config.yaml

##### Makefile #####
ifneq ("$(wildcard tutor_makefile.mk)","")
include tutor_makefile.mk
endif
# пожалуйста, не удаляйте и не перемещайте этот импорт, он помогает вашему верному тьютору быстрее смотреть ваше дз
# вы можете описать ваш собственный makefile ниже

APP_NAME := pvz
BUILD_DIR := bin
MAIN_PATH := cmd/pvz/main.go

.PHONY: update linter build start run clean gateway swagger test test-coverage clean-coverage
clean:
	rm -rf $(BUILD_DIR)
	rm -rf vendor.protogen
	
update:
	go mod tidy
	go mod download

linter:
	go vet ./...
	go fmt ./...
	golangci-lint run; 

build:
	@mkdir -p $(BUILD_DIR)
	go build -o $(BUILD_DIR)/$(APP_NAME) $(MAIN_PATH)

start:
	@if [ ! -f $(BUILD_DIR)/$(APP_NAME) ]; then \
		echo "Бинарный файл не найден. Сначала выполните 'make build'"; \
		exit 1; \
	fi
	./$(BUILD_DIR)/$(APP_NAME)

run: update linter build start


generate-data:
	go run data/generate_test_data.go

LOCAL_BIN := $(CURDIR)/bin
OUT_PATH := $(CURDIR)/pkg

bin-deps: export GOBIN := $(LOCAL_BIN)
bin-deps: export PROTOC_VERSION := protoc-31.1-linux-x86_64
bin-deps:
	curl -LO https://github.com/protocolbuffers/protobuf/releases/download/v31.1/$(PROTOC_VERSION).zip
	unzip -o $(PROTOC_VERSION).zip -d $(LOCAL_BIN)
	rm $(PROTOC_VERSION).zip

	go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
	go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest
	go install github.com/envoyproxy/protoc-gen-validate@latest
	go install github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-grpc-gateway@latest
	go install github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2@latest

generate: export GOBIN := $(LOCAL_BIN)
generate:
	mkdir -p $(OUT_PATH)
	$(LOCAL_BIN)/bin/protoc --proto_path=api --proto_path=vendor.protogen \
		--go_out=$(OUT_PATH) --go_opt=paths=source_relative --plugin protoc-gen-go="${GOBIN}/protoc-gen-go" \
		--go-grpc_out=$(OUT_PATH) --go-grpc_opt=paths=source_relative --plugin protoc-gen-go-grpc="${GOBIN}/protoc-gen-go-grpc" \
		--validate_out="lang=go,paths=source_relative:$(OUT_PATH)" --plugin protoc-gen-validate=$(LOCAL_BIN)/protoc-gen-validate \
		--grpc-gateway_out=$(OUT_PATH) --grpc-gateway_opt=paths=source_relative --plugin protoc-gen-grpc-gateway=$(LOCAL_BIN)/protoc-gen-grpc-gateway \
		--openapiv2_out=$(OUT_PATH) --plugin=protoc-gen-openapiv2=$(LOCAL_BIN)/protoc-gen-openapiv2 \
		api/orders/contract.proto 
	go mod tidy

.vendor-proto/validate:
	git clone -b main --single-branch --depth=2 --filter=tree:0 \
	https://github.com/bufbuild/protoc-gen-validate vendor.protogen/tmp && \
	cd vendor.protogen/tmp && \
	git sparse-checkout set --no-cone validate && \
	git checkout
	mkdir -p vendor.protogen/validate
	mv vendor.protogen/tmp/validate vendor.protogen/
	rm -rf vendor.protogen/tmp

.vendor-proto/google/api:
	git clone -b master --single-branch -n --depth=1 --filter=tree:0 \
 		https://github.com/googleapis/googleapis vendor.protogen/googleapis && \
 		cd vendor.protogen/googleapis && \
		git sparse-checkout set --no-cone google/api && \
		git checkout
		mkdir -p vendor.protogen/google
		mv vendor.protogen/googleapis/google/api vendor.protogen/google
		rm -rf vendor.protogen/googleapis

.vendor-proto/protoc-gen-openapiv2/options:
	git clone -b main --single-branch -n --depth=1 --filter=tree:0 \
 		https://github.com/grpc-ecosystem/grpc-gateway vendor.protogen/grpc-ecosystem && \
 		cd vendor.protogen/grpc-ecosystem && \
		git sparse-checkout set --no-cone protoc-gen-openapiv2/options && \
		git checkout
		mkdir -p vendor.protogen/protoc-gen-openapiv2
		mv vendor.protogen/grpc-ecosystem/protoc-gen-openapiv2/options vendor.protogen/protoc-gen-openapiv2
		rm -rf vendor.protogen/grpc-ecosystem

gateway:
	go run cmd/gateway/main.go
swagger:
	go run cmd/swagger/main.go

GOOSE_BIN   ?= $(LOCAL_BIN)/goose      
MIGRATIONS  ?= migrations
DB_DSN      ?= postgres://pvz:pvz@localhost:5433/pvz?sslmode=disable

migrate-up: 
	$(GOOSE_BIN) -dir $(MIGRATIONS) postgres "$(DB_DSN)" up

migrate-down:
	$(GOOSE_BIN) -dir $(MIGRATIONS) postgres "$(DB_DSN)" down

migrate-status:
	$(GOOSE_BIN) -dir $(MIGRATIONS) postgres "$(DB_DSN)" status

compose-up:
	@docker-compose --env-file ./config/.env up -d

	
test-coverage:
	go test -v -race -coverprofile=cover.out ./...
	go tool cover -html=cover.out -o cover.html

clean-coverage:
	rm -f cover.out cover.html

test:
	go test -v -race ./...


##### api/orders/contract.proto #####
syntax = "proto3";

package orders;

option go_package = "gitlab.ozon.dev/safariproxd/homework/pkg/api";

import "google/protobuf/timestamp.proto";
import "validate/validate.proto";
import "google/api/annotations.proto";
import "protoc-gen-openapiv2/options/annotations.proto";

option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
  info: {
    title: "PVZ Orders Service";
    version: "1.0.0";
    description: "API для управления заказами в системе пункта выдачи заказов.";
  };
  host: "localhost:8081";
  schemes: HTTP;
  consumes: "application/json";
  produces: "application/json";
};

service OrdersService {
    rpc AcceptOrder (AcceptOrderRequest) returns (OrderResponse) {
        option (google.api.http) = {
            post: "/v1/orders/accept",
            body: "*"
        };
        option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
            summary: "Принять заказ от курьера";
            description: "Принимает заказ с указанным ID, ID получателя и сроком хранения. Заказ нельзя принять дважды. Если срок хранения в прошлом, выдается ошибка.";
        };
    };
    rpc ReturnOrder (OrderIdRequest) returns (OrderResponse) {
        option (google.api.http) = {
            post: "/v1/orders/return",
            body: "*"
        };
        option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
            summary: "Вернуть заказ курьеру";
            description: "Возвращает заказ курьеру по указанному ID. Можно вернуть только заказы, которые не находятся у клиентов или у которых истек срок хранения. Заказ помечается как удаленный.";
        };
    };
    rpc ProcessOrders (ProcessOrdersRequest) returns (ProcessResult) {
        option (google.api.http) = {
            post: "/v1/orders/process",
            body: "*"
        };
        option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
            summary: "Выдать заказы или принять возвраты клиента";
            description: "Обрабатывает выдачу заказов или прием возвратов для указанного пользователя и списка заказов. Выдача возможна только для принятых заказов с неистекшим сроком хранения. Возврат возможен в течение двух суток с момента выдачи. Все заказы должны принадлежать одному клиенту.";
        };
    };
    rpc ListOrders (ListOrdersRequest) returns (OrdersList) {
        option (google.api.http) = {
            get: "/v1/orders/list/{user_id}"
        };
        option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
            summary: "Получить список заказов";
            description: "Возвращает список заказов для указанного пользователя. Поддерживает получение последних N заказов или заказов, находящихся в ПВЗ, с опциональной пагинацией.";
        };
    };
    rpc ListReturns (ListReturnsRequest) returns (ReturnsList) {
        option (google.api.http) = {
            get: "/v1/orders/returns"
        };
        option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
            summary: "Получить список возвратов клиентов";
            description: "Возвращает список возвращенных заказов с постраничной пагинацией, отсортированный от свежих возвратов к старым.";
        };
    };
    rpc GetHistory (GetHistoryRequest) returns (OrderHistoryList) {
        option (google.api.http) = {
            get: "/v1/orders/history"
        };
        option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
            summary: "Получить историю заказов";
            description: "Возвращает историю изменений статуса всех заказов, отсортированную по времени последнего обновления.";
        };
    };
    rpc ImportOrders (ImportOrdersRequest) returns (ImportResult) {
        option (google.api.http) = {
            post: "/v1/orders/import",
            body: "*"
        };
        option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
            summary: "Импортировать заказы";
            description: "Импортирует несколько заказов из предоставленного списка, валидируя каждый заказ.";
        };
    };
    rpc GetOrderHistory (OrderHistoryRequest) returns (OrderHistoryResponse) {
        option (google.api.http) = {
            get: "/v1/orders/{order_id}/history"
        };
        option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
            summary: "Получить историю статусов по заказу";
            description: "Возвращает историю изменений статуса для указанного заказа, отсортированную по убыванию времени изменения. Если заказ не найден, возвращается ошибка.";
        };
    };
}

message AcceptOrderRequest {
    uint64 order_id = 1 [(validate.rules).uint64.gt = 0];
    uint64 user_id = 2 [(validate.rules).uint64.gt = 0];
    google.protobuf.Timestamp expires_at = 3 [(validate.rules).timestamp.required = true, (validate.rules).timestamp.gt_now = true];
    optional PackageType package = 4;
    float weight = 5 [(validate.rules).float.gt = 0];
    float price = 6 [(validate.rules).float.gt = 0];
}

message OrderIdRequest {
    uint64 order_id = 1 [(validate.rules).uint64.gt = 0];
}

message ProcessOrdersRequest {
    uint64 user_id = 1 [(validate.rules).uint64.gt = 0];
    ActionType action = 2 [(validate.rules).enum = { defined_only: true, not_in: [0] }];
    repeated uint64 order_ids = 3 [(validate.rules).repeated.min_items = 1, (validate.rules).repeated.items.uint64.gt = 0];
}

enum ActionType {
    ACTION_TYPE_UNSPECIFIED = 0;
    ACTION_TYPE_ISSUE = 1;
    ACTION_TYPE_RETURN = 2;
}

message ListOrdersRequest {
    uint64 user_id = 1 [(validate.rules).uint64.gt = 0];
    bool in_pvz = 2;
    optional uint32 last_n = 3 [(validate.rules).uint32.gt = 0];
    optional Pagination pagination = 4;
}

message Pagination {
    uint32 page = 1 [(validate.rules).uint32.gte = 0];
    uint32 count_on_page = 2 [(validate.rules).uint32.gt = 0];
}

message ListReturnsRequest {
    Pagination pagination = 1;
}

message ImportOrdersRequest {
    repeated AcceptOrderRequest orders = 1 [(validate.rules).repeated.min_items = 1];
}

message GetHistoryRequest {
    Pagination pagination = 1;
}

message OrderHistoryRequest {
    uint64 order_id = 1 [(validate.rules).uint64.gt = 0];
}

message OrderHistoryResponse {
    repeated OrderHistory history = 1;
}

message OrderResponse {
    OrderStatus status = 1;
    uint64 order_id = 2;
}

message ProcessResult {
    repeated uint64 processed = 1;
    repeated uint64 errors = 2;
}

message OrdersList {
    repeated Order orders = 1;
    int32 total = 2;
}

message ReturnsList {
    repeated Order returns = 1;
}

message OrderHistoryList {
    repeated OrderHistory history = 1;
}

message ImportResult {
    int32 imported = 1;
    repeated uint64 errors = 2;
}

message Order {
    uint64 order_id = 1;
    uint64 user_id = 2;
    OrderStatus status = 3;
    google.protobuf.Timestamp expires_at = 4;
    float weight = 5;
    float total_price = 6;
    optional PackageType package = 7;
}

enum PackageType {
    PACKAGE_TYPE_UNSPECIFIED = 0;
    PACKAGE_TYPE_BAG = 1;
    PACKAGE_TYPE_BOX = 2;
    PACKAGE_TYPE_TAPE = 3;
    PACKAGE_TYPE_BAG_TAPE = 4;
    PACKAGE_TYPE_BOX_TAPE = 5;
}

enum OrderStatus {
    ORDER_STATUS_UNSPECIFIED = 0;
    ORDER_STATUS_EXPECTS = 1;
    ORDER_STATUS_ACCEPTED = 2;
    ORDER_STATUS_RETURNED = 3;
    ORDER_STATUS_DELETED = 4;
}

message OrderHistory {
    uint64 order_id = 1;
    OrderStatus status = 2;
    google.protobuf.Timestamp created_at = 3;
}

##### cmd/gateway/main.go #####
package main

import (
	"context"
	"log"
	"net/http"

	"github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
	"gitlab.ozon.dev/safariproxd/homework/internal/config"
	"gitlab.ozon.dev/safariproxd/homework/pkg/api"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
)

func main() {
	cfg, err := config.Load("config/config.yaml")
	if err != nil {
		log.Fatalf("config: %v", err)
	}
	ctx := context.Background()
	mux := runtime.NewServeMux()
	err = api.RegisterOrdersServiceHandlerFromEndpoint(ctx, mux, cfg.Service.GRPCAddress, []grpc.DialOption{
		grpc.WithTransportCredentials(insecure.NewCredentials()),
	})
	if err != nil {
		log.Fatalf("RegisterOrdersServiceHandlerFromEndpoint err: %v", err)
	}

	log.Printf("http server running on %v", cfg.Service.HTTPAddress)
	if err := http.ListenAndServe(cfg.Service.HTTPAddress, mux); err != nil {
		log.Fatalf("http server running err: %v", err)
	}
}


##### cmd/outbox/main.go #####
package main

import (
	"context"
	"log/slog"
	"os"
	"time"

	"gitlab.ozon.dev/safariproxd/homework/internal/config"
	"gitlab.ozon.dev/safariproxd/homework/internal/domain"
	"gitlab.ozon.dev/safariproxd/homework/internal/infra"
	"gitlab.ozon.dev/safariproxd/homework/internal/repository/postgres"
	"gitlab.ozon.dev/safariproxd/homework/pkg/db"
)

func main() {
	cfg, err := config.Load("config/config.yaml")
	if err != nil {
		slog.Error("Config load failed", "error", err)
		os.Exit(1)
	}

	dbCfg := db.Config{
		ReadDSN:  cfg.ReadDSN(),
		WriteDSN: cfg.WriteDSN(),
		MaxOpen:  cfg.DB.Pool.MaxOpen,
		MaxIdle:  cfg.DB.Pool.MaxIdle,
	}
	dbClient, err := db.NewClient(dbCfg)
	if err != nil {
		slog.Error("DB client creation failed", "error", err)
		os.Exit(1)
	}
	defer dbClient.Close()

	outboxRepo := postgres.NewOutboxRepository(dbClient)
	kafkaProducer, err := infra.NewKafkaProducer(cfg.Kafka.Brokers, cfg.Kafka.Topic)
	if err != nil {
		slog.Error("Kafka producer creation failed", "error", err)
		os.Exit(1)
	}
	defer kafkaProducer.Close()

	slog.Info("Outbox worker started",
		"interval", cfg.Outbox.WorkerInterval,
		"batch_size", cfg.Outbox.BatchSize,
		"kafka_topic", cfg.Kafka.Topic)

	ctx := context.Background()
	ticker := time.NewTicker(cfg.Outbox.WorkerInterval)
	defer ticker.Stop()

	processOutboxMessages(ctx, outboxRepo, kafkaProducer, cfg.Outbox.BatchSize)

	for range ticker.C {
		processOutboxMessages(ctx, outboxRepo, kafkaProducer, cfg.Outbox.BatchSize)
	}
}

func processOutboxMessages(ctx context.Context, repo *postgres.OutboxRepository, producer *infra.KafkaProducer, batchSize int) {
	messages, err := repo.GetPendingMessages(ctx, batchSize)
	if err != nil {
		slog.Error("Failed to get pending messages", "error", err)
		return
	}
	if len(messages) == 0 {
		slog.Debug("No pending messages found")
		return
	}

	slog.Info("Processing outbox messages", "count", len(messages))
	for _, msg := range messages {
		if err := repo.UpdateStatus(ctx, msg.ID, domain.OutboxStatusProcessing, nil); err != nil {
			slog.Error("Failed to update status to processing", "id", msg.ID, "error", err)
			continue
		}

		if err := producer.Send(ctx, msg.Payload); err != nil {
			errMsg := err.Error()
			if err := repo.UpdateStatus(ctx, msg.ID, domain.OutboxStatusFailed, &errMsg); err != nil {
				slog.Error("Failed to update status to failed", "id", msg.ID, "error", err)
			}
			slog.Error("Failed to send message to Kafka", "id", msg.ID, "error", err)
			continue
		}

		if err := repo.UpdateStatus(ctx, msg.ID, domain.OutboxStatusCompleted, nil); err != nil {
			slog.Error("Failed to update status to completed", "id", msg.ID, "error", err)
			continue
		}
		slog.Info("Message processed successfully", "id", msg.ID)
	}
}


##### cmd/pvz/main.go #####
package main

import (
	"context"
	"log/slog"
	"net"
	"os"
	"time"

	"github.com/ulule/limiter/v3"
	"github.com/ulule/limiter/v3/drivers/store/memory"
	server "gitlab.ozon.dev/safariproxd/homework/internal/adapter/grpc"
	"gitlab.ozon.dev/safariproxd/homework/internal/adapter/grpc/mw"
	"gitlab.ozon.dev/safariproxd/homework/internal/app"
	"gitlab.ozon.dev/safariproxd/homework/internal/config"
	"gitlab.ozon.dev/safariproxd/homework/internal/infra"
	"gitlab.ozon.dev/safariproxd/homework/internal/repository/postgres"
	"gitlab.ozon.dev/safariproxd/homework/internal/workerpool"
	"gitlab.ozon.dev/safariproxd/homework/pkg/db"
	"google.golang.org/grpc"
	"google.golang.org/grpc/reflection"
)

func main() {
	cfg, err := config.Load("config/config.yaml")
	if err != nil {
		slog.Error("Config load failed", "error", err)
		os.Exit(1)
	}

	dbCfg := db.Config{
		ReadDSN:  cfg.ReadDSN(),
		WriteDSN: cfg.WriteDSN(),
		MaxOpen:  cfg.DB.Pool.MaxOpen,
		MaxIdle:  cfg.DB.Pool.MaxIdle,
	}
	client, err := db.NewClient(dbCfg)
	if err != nil {
		slog.Error("DB client creation failed", "error", err)
		os.Exit(1)
	}
	defer client.Close()
	orderRepo := postgres.NewOrderRepository(client)
	outboxRepo := postgres.NewOutboxRepository(client)
	pvzService := app.NewPVZService(orderRepo, outboxRepo, client, time.Now, cfg.Service.WorkerLimit)

	pool := workerpool.New(cfg.Service.WorkerLimit, cfg.Service.QueueSize)

	limiterInstance := limiter.New(memory.NewStore(), limiter.Rate{Period: cfg.Service.Timeout, Limit: 5})

	grpcServer := grpc.NewServer(
		grpc.ChainUnaryInterceptor(
			mw.RateLimiterInterceptor(limiterInstance),
			mw.TimeoutInterceptor(2*time.Second),
			mw.LoggingInterceptor(),
			mw.ValidationInterceptor(),
			mw.ErrorMappingInterceptor(),
			mw.PoolInterceptor(pool),
		),
	)

	ordersServer := server.NewOrdersServer(pvzService)
	reflection.Register(grpcServer)
	ordersServer.Register(grpcServer)

	lis, err := net.Listen("tcp", cfg.Service.GRPCAddress)
	if err != nil {
		slog.Error("failed to listen", "error", err)
		os.Exit(1)
	}
	go func() {
		slog.Info("gRPC listening", "addr", cfg.Service.GRPCAddress)
		if err := grpcServer.Serve(lis); err != nil {
			slog.Error("gRPC serve error", "error", err)
			os.Exit(1)
		}
	}()

	admin := infra.NewAdmin(cfg.Service.AdminAddress, pool)
	admin.Start()
	slog.Info("admin HTTP listening", "addr", cfg.Service.AdminAddress)
	// curl -XPOST 'http://localhost:6060/resize?workers=11'
	// реализовал через http запросы, возможно надо было добавлять grpc ручку
	infra.Graceful(
		func(ctx context.Context) { grpcServer.GracefulStop() },
		admin.Shutdown,
		func(ctx context.Context) { pool.Close() },
	)
}


##### cmd/swagger/main.go #####
package main

import (
	"log"
	"net/http"
	"os"

	"github.com/go-chi/chi/v5"
	httpSwagger "github.com/swaggo/http-swagger"
	"gitlab.ozon.dev/safariproxd/homework/internal/config"
)

func main() {
	cfg, err := config.Load("config/config.yaml")
	if err != nil {
		log.Fatalf("config: %v", err)
	}
	mux := chi.NewMux()
	mux.HandleFunc("/swagger.json", func(w http.ResponseWriter, r *http.Request) {
		b, err := os.ReadFile("./pkg/api/contract.swagger.json")
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			log.Printf("failed to read swagger.json: %v", err)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		if _, err := w.Write(b); err != nil {
			log.Printf("failed to write swagger.json response: %v", err)
		}
	})

	mux.HandleFunc("/swagger/*", httpSwagger.Handler(
		httpSwagger.URL("/swagger.json"),
	))

	log.Printf("Listening on %s", cfg.Service.SwaggerAddress)
	if err := http.ListenAndServe(cfg.Service.SwaggerAddress, mux); err != nil {
		log.Fatalf("failed to listen and serve: %v", err)
	}
}


##### config/.env.example #####
POSTGRES_USER=pvz
POSTGRES_PASSWORD=pvz
POSTGRES_DB=pvz
POSTGRES_READ_HOST=db
POSTGRES_WRITE_HOST=db
POSTGRES_PORT=5432

##### config/config.yaml.example #####
service:
  grpc_address: ":50051"
  http_address: ":8081"
  swagger_address: ":8082"
  admin_address: ":6060"
  timeout: 2s
  worker_limit: 16
  queue_size: 512

db:
  read_host: db
  write_host: db
  port: 5432
  name: pvz
  sslmode: disable
  pool:
    max_open: 20
    max_idle: 10
  migrations_dir: migrations

kafka:
  brokers:
    - kafka:29092
  topic: pvz.events-log
  producer:
    timeout: 10s
    retries: 3

outbox:
  worker_interval: 5s
  batch_size: 100

##### docker-compose.yml #####
version: "3.9"

services:
  db:
    image: postgres:16-alpine
    restart: unless-stopped
    env_file: ./config/.env
    environment:
      - POSTGRES_LOG_STATEMENT=all
      - POSTGRES_LOG_CONNECTIONS=on
      - POSTGRES_LOG_DISCONNECTIONS=on
    healthcheck:
      test: ["CMD", "sh", "-c", "pg_isready -U $$POSTGRES_USER -d $$POSTGRES_DB"]
      interval: 5s
      timeout: 10s
      retries: 10
    ports:
      - "5433:5432"
    volumes:
      - db-data:/var/lib/postgresql/data
    networks:
      - pvz-network

  zookeeper:
    image: confluentinc/cp-zookeeper:7.5.0
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181
      ZOOKEEPER_TICK_TIME: 2000
    ports:
      - "2181:2181"
    networks:
      - pvz-network

  kafka:
    image: confluentinc/cp-kafka:7.5.0
    depends_on:
      - zookeeper
    ports:
      - "9092:9092"
      - "29092:29092"
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:29092,PLAINTEXT_HOST://localhost:9092
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT
      KAFKA_INTER_BROKER_LISTENER_NAME: PLAINTEXT
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
    networks:
      - pvz-network

  kafka-init:
    image: confluentinc/cp-kafka:7.5.0
    depends_on:
      - kafka
    entrypoint: >
      bash -c "
        echo 'Waiting for Kafka to be ready...' &&
        cub kafka-ready -b kafka:29092 1 30 &&
        kafka-topics --create --if-not-exists --bootstrap-server kafka:29092 --partitions 1 --replication-factor 1 --topic pvz.events-log &&
        echo 'Kafka topic created successfully'
      "
    networks:
      - pvz-network

  kafka-ui:
    image: provectuslabs/kafka-ui:latest
    depends_on:
      - kafka
    ports:
      - "8080:8080"
    environment:
      KAFKA_CLUSTERS_0_NAME: local
      KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS: kafka:29092
      KAFKA_CLUSTERS_0_ZOOKEEPER: zookeeper:2181
    networks:
      - pvz-network

  migrate:
    image: golang:1.23-alpine
    working_dir: /src
    env_file: ./config/.env
    volumes:
      - .:/src
    entrypoint: >
      sh -c "
        apk add --no-cache git &&
        go install github.com/pressly/goose/v3/cmd/goose@latest &&
        goose -dir ./migrations postgres \"postgres://$$POSTGRES_USER:$$POSTGRES_PASSWORD@db:5432/$$POSTGRES_DB?sslmode=disable\" up
      "
    depends_on:
      db:
        condition: service_healthy
    networks:
      - pvz-network

  app:
    image: golang:1.23-alpine
    working_dir: /src
    env_file: ./config/.env
    volumes:
      - .:/src
    command: ["go", "run", "./cmd/pvz"]
    depends_on:
      migrate:
        condition: service_completed_successfully
      kafka-init:
        condition: service_completed_successfully
    ports:
      - "50051:50051"
      - "6060:6060"
    networks:
      - pvz-network

  gateway:
    image: golang:1.23-alpine
    working_dir: /src
    env_file: ./config/.env
    volumes:
      - .:/src
    command: ["go", "run", "./cmd/gateway"]
    depends_on:
      app:
        condition: service_started
    ports:
      - "8081:8081"
    networks:
      - pvz-network

  swagger:
    image: golang:1.23-alpine
    working_dir: /src
    volumes:
      - .:/src
    command: ["go", "run", "./cmd/swagger"]
    depends_on:
      app:
        condition: service_started
    ports:
      - "8082:8082"
    networks:
      - pvz-network

  outbox-worker:
    image: golang:1.23-alpine
    working_dir: /src
    env_file: ./config/.env
    volumes:
      - .:/src
    command: ["go", "run", "./cmd/outbox"]
    depends_on:
      migrate:
        condition: service_completed_successfully
      kafka-init:
        condition: service_completed_successfully
    networks:
      - pvz-network

volumes:
  db-data:

networks:
  pvz-network:
    driver: bridge

##### internal/adapter/grpc/errors.go #####
package server

import (
	"errors"
	"fmt"
	"strings"

	"gitlab.ozon.dev/safariproxd/homework/internal/domain"
	"gitlab.ozon.dev/safariproxd/homework/pkg/api"
	"go.uber.org/multierr"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

func MapErrorToGRPCStatus(err error) error {
	var domainErr domain.Error
	if errors.As(err, &domainErr) {
		switch domainErr.Code {
		case domain.ErrorCodeNotFound:
			return status.Error(codes.NotFound, domainErr.Message)
		case domain.ErrorCodeAlreadyExists:
			return status.Error(codes.AlreadyExists, domainErr.Message)
		case domain.ErrorCodeStorageExpired, domain.ErrorCodeStorageNotExpired:
			return status.Error(codes.FailedPrecondition, domainErr.Message)
		case domain.ErrorCodeValidationFailed, domain.ErrorCodeInvalidPackage, domain.ErrorCodeWeightTooHeavy:
			return status.Error(codes.InvalidArgument, domainErr.Message)
		default:
			return status.Error(codes.Internal, domainErr.Message)
		}
	}
	if multierr.Errors(err) != nil {
		return status.Error(codes.InvalidArgument, err.Error())
	}
	return status.Error(codes.Internal, err.Error())
}

func processErrors(err error, orderIDs []uint64) (*api.ProcessResult, error) {
	var processed, errors []uint64
	multiErrs := multierr.Errors(err)
	if len(multiErrs) == 0 {
		return &api.ProcessResult{Processed: orderIDs}, nil
	}
	for _, orderID := range orderIDs {
		found := false
		for _, e := range multiErrs {
			if strings.Contains(e.Error(), fmt.Sprintf("Order %d", orderID)) {
				errors = append(errors, orderID)
				found = true
				break
			}
		}
		if !found {
			processed = append(processed, orderID)
		}
	}
	return &api.ProcessResult{Processed: processed, Errors: errors}, status.Error(codes.InvalidArgument, err.Error())
}

func processImportErrors(err error, orders []domain.OrderToImport) *api.ImportResult {
	var errors []uint64
	multiErrs := multierr.Errors(err)
	for _, order := range orders {
		for _, e := range multiErrs {
			if strings.Contains(e.Error(), fmt.Sprintf("Order %d", order.OrderID)) {
				errors = append(errors, order.OrderID)
				break
			}
		}
	}
	return &api.ImportResult{Imported: int32(len(orders) - len(errors)), Errors: errors}
}


##### internal/adapter/grpc/handler.go #####
package server

import (
	"context"

	"gitlab.ozon.dev/safariproxd/homework/internal/adapter/cli"
	"gitlab.ozon.dev/safariproxd/homework/internal/app"
	"gitlab.ozon.dev/safariproxd/homework/internal/domain"
	"gitlab.ozon.dev/safariproxd/homework/pkg/api"
	"google.golang.org/protobuf/types/known/timestamppb"
)

func (s *OrdersServer) AcceptOrder(ctx context.Context, req *api.AcceptOrderRequest) (*api.OrderResponse, error) {
	var packageType string
	if req.Package != nil {
		packageType = mapPackageTypeToString(*req.Package)
	}
	acceptReq := domain.AcceptOrderRequest{
		OrderID:      req.OrderId,
		ReceiverID:   req.UserId,
		StorageUntil: req.ExpiresAt.AsTime(),
		Weight:       float64(req.Weight),
		Price:        float64(req.Price),
		PackageType:  packageType,
	}
	_, err := s.service.AcceptOrder(ctx, acceptReq)
	if err != nil {
		return nil, err
	}
	return &api.OrderResponse{
		Status:  api.OrderStatus_ORDER_STATUS_EXPECTS,
		OrderId: req.OrderId,
	}, nil
}

func (s *OrdersServer) ReturnOrder(ctx context.Context, req *api.OrderIdRequest) (*api.OrderResponse, error) {
	err := s.service.ReturnOrderToDelivery(ctx, req.OrderId)
	if err != nil {
		return nil, err
	}
	return &api.OrderResponse{
		Status:  api.OrderStatus_ORDER_STATUS_DELETED,
		OrderId: req.OrderId,
	}, nil
}

func (s *OrdersServer) ProcessOrders(ctx context.Context, req *api.ProcessOrdersRequest) (*api.ProcessResult, error) {
	var err error
	if req.Action == api.ActionType_ACTION_TYPE_ISSUE {
		err = s.service.IssueOrdersToClient(ctx, req.UserId, req.OrderIds)
	} else {
		err = s.service.ReturnOrdersFromClient(ctx, req.UserId, req.OrderIds)
	}
	if err != nil {
		return processErrors(err, req.OrderIds)
	}
	return &api.ProcessResult{Processed: req.OrderIds}, nil
}

func (s *OrdersServer) ListOrders(ctx context.Context, req *api.ListOrdersRequest) (*api.OrdersList, error) {
	var page, limit, lastN uint64
	if req.Pagination != nil {
		page = uint64(req.Pagination.Page)
		limit = uint64(req.Pagination.CountOnPage)
	}
	if req.LastN != nil {
		lastN = uint64(*req.LastN)
	}
	ordersReq := domain.ReceiverOrdersRequest{
		ReceiverID: req.UserId,
		InPVZ:      req.InPvz,
		LastN:      lastN,
		Page:       page,
		Limit:      limit,
	}
	orders, total, err := s.service.GetReceiverOrders(ctx, ordersReq)
	if err != nil {
		return nil, err
	}
	protoOrders := make([]*api.Order, len(orders))
	for i, order := range orders {
		protoOrders[i] = mapDomainOrderToProto(order)
	}
	return &api.OrdersList{
		Orders: protoOrders,
		Total:  int32(total),
	}, nil
}

func (s *OrdersServer) ListReturns(ctx context.Context, req *api.ListReturnsRequest) (*api.ReturnsList, error) {
	var page, limit uint64
	if req.Pagination != nil {
		page = uint64(req.Pagination.Page)
		limit = uint64(req.Pagination.CountOnPage)
	}
	orders, _, err := s.service.GetReturnedOrders(ctx, page, limit)
	if err != nil {
		return nil, err
	}
	protoOrders := make([]*api.Order, len(orders))
	for i, order := range orders {
		protoOrders[i] = mapDomainOrderToProto(order)
	}
	return &api.ReturnsList{Returns: protoOrders}, nil
}

func (s *OrdersServer) GetHistory(ctx context.Context, req *api.GetHistoryRequest) (*api.OrderHistoryList, error) {
	var page, limit uint64
	if req.Pagination != nil {
		page = uint64(req.Pagination.Page)
		limit = uint64(req.Pagination.CountOnPage)
	}
	orders, err := s.service.GetOrderHistory(ctx)
	if err != nil {
		return nil, err
	}
	paginated := app.Paginate(orders, page, limit)
	history := make([]*api.OrderHistory, len(paginated))
	for i, order := range paginated {
		history[i] = &api.OrderHistory{
			OrderId:   order.OrderID,
			Status:    mapDomainStatusToProto(order.Status),
			CreatedAt: timestamppb.New(order.LastUpdateTime),
		}
	}
	return &api.OrderHistoryList{History: history}, nil
}

func (s *OrdersServer) GetOrderHistory(ctx context.Context, req *api.OrderHistoryRequest) (*api.OrderHistoryResponse, error) {
	history, err := s.service.GetOrderHistoryByID(ctx, req.OrderId)
	if err != nil {
		return nil, err
	}
	protoHistory := make([]*api.OrderHistory, len(history))
	for i, record := range history {
		protoHistory[i] = &api.OrderHistory{
			OrderId:   record.OrderID,
			Status:    mapDomainStatusToProto(record.Status),
			CreatedAt: timestamppb.New(record.ChangedAt),
		}
	}
	return &api.OrderHistoryResponse{History: protoHistory}, nil
}

func (s *OrdersServer) ImportOrders(ctx context.Context, req *api.ImportOrdersRequest) (*api.ImportResult, error) {
	orders := make([]domain.OrderToImport, len(req.Orders))
	for i, order := range req.Orders {
		var packageType string
		if order.Package != nil {
			packageType = mapPackageTypeToString(*order.Package)
		}
		orders[i] = domain.OrderToImport{
			OrderID:      order.OrderId,
			ReceiverID:   order.UserId,
			StorageUntil: order.ExpiresAt.AsTime().Format(cli.TimeFormat),
			PackageType:  packageType,
			Weight:       float64(order.Weight),
			Price:        float64(order.Price),
		}
	}
	imported, err := s.service.ImportOrders(ctx, orders)
	if err != nil {
		return processImportErrors(err, orders), nil
	}
	return &api.ImportResult{Imported: int32(imported)}, nil
}


##### internal/adapter/grpc/mw/middleware.go #####
package mw

import (
	"context"
	"log/slog"
	"time"

	"github.com/ulule/limiter/v3"
	server "gitlab.ozon.dev/safariproxd/homework/internal/adapter/grpc"
	"gitlab.ozon.dev/safariproxd/homework/internal/workerpool"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/metadata"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
)

func LoggingInterceptor() grpc.UnaryServerInterceptor {
	return func(ctx context.Context, req any, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (any, error) {
		md, _ := metadata.FromIncomingContext(ctx)
		slog.Info("Request", "method", info.FullMethod, "metadata", md)
		resp, err := handler(ctx, req)
		if err != nil {
			slog.Error("Response", "method", info.FullMethod, "error", err)
		} else {
			slog.Info("Response", "method", info.FullMethod)
		}
		return resp, err
	}
}

func ErrorMappingInterceptor() grpc.UnaryServerInterceptor {
	return func(ctx context.Context, req any, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (any, error) {
		resp, err := handler(ctx, req)
		if err != nil {
			return resp, server.MapErrorToGRPCStatus(err)
		}
		return resp, nil
	}
}

func RateLimiterInterceptor(limiter *limiter.Limiter) grpc.UnaryServerInterceptor {
	return func(ctx context.Context, req any, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (any, error) {
		sender := "unknown"
		if md, ok := metadata.FromIncomingContext(ctx); ok {
			if s, ok := md["sender"]; ok {
				sender = s[0]
			}
		}

		limiterCtx, err := limiter.Get(ctx, sender)
		if err != nil {
			return nil, status.Error(codes.Internal, err.Error())
		}
		if limiterCtx.Reached {
			return nil, status.Error(codes.ResourceExhausted, "rate limited")
		}

		return handler(ctx, req)
	}
}

func ValidationInterceptor() grpc.UnaryServerInterceptor {
	return func(ctx context.Context, req any, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (any, error) {
		if v, ok := req.(proto.Message); ok {
			if validator, ok := v.(interface{ ValidateAll() error }); ok {
				if err := validator.ValidateAll(); err != nil {
					return nil, status.Errorf(codes.InvalidArgument, "validation failed: %v", err)
				}
			}
		}
		return handler(ctx, req)
	}
}

func TimeoutInterceptor(timeout time.Duration) grpc.UnaryServerInterceptor {
	return func(parent context.Context, req any,
		info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (any, error) {

		ctx, cancel := context.WithTimeout(parent, timeout)
		defer cancel()

		resp, err := handler(ctx, req)

		if ctx.Err() == context.DeadlineExceeded && err == nil {
			return nil, status.Error(codes.DeadlineExceeded, "service timeout")
		}
		return resp, err
	}
}

func PoolInterceptor(pool *workerpool.Pool) grpc.UnaryServerInterceptor {
	return func(ctx context.Context, req any, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (any, error) {
		respCh := make(chan workerpool.Response, 1)
		pool.Submit(workerpool.Job{
			Ctx:  ctx,
			Run:  func(c context.Context) (any, error) { return handler(c, req) },
			Resp: respCh,
		})
		select {
		case r := <-respCh:
			return r.Value, r.Err
		case <-ctx.Done():
			return nil, ctx.Err()
		}
	}
}


##### internal/adapter/grpc/server.go #####
package server

import (
	"context"

	"gitlab.ozon.dev/safariproxd/homework/internal/domain"
	"gitlab.ozon.dev/safariproxd/homework/pkg/api"
	"google.golang.org/grpc"
)

type IOrderService interface {
	AcceptOrder(ctx context.Context, req domain.AcceptOrderRequest) (float64, error)
	ReturnOrderToDelivery(ctx context.Context, orderID uint64) error
	IssueOrdersToClient(ctx context.Context, receiverID uint64, orderIDs []uint64) error
	ReturnOrdersFromClient(ctx context.Context, receiverID uint64, orderIDs []uint64) error
	GetReceiverOrders(ctx context.Context, req domain.ReceiverOrdersRequest) ([]domain.Order, uint64, error)
	GetReceiverOrdersScroll(ctx context.Context, receiverID uint64, lastID, limit uint64) ([]domain.Order, uint64, error)
	GetReturnedOrders(ctx context.Context, page, limit uint64) ([]domain.Order, uint64, error)
	GetOrderHistory(ctx context.Context) ([]domain.Order, error)
	GetOrderHistoryByID(ctx context.Context, orderID uint64) ([]domain.OrderHistory, error)
	ImportOrders(ctx context.Context, orders []domain.OrderToImport) (uint64, error)
}

type OrdersServer struct {
	api.UnimplementedOrdersServiceServer
	service IOrderService
}

func NewOrdersServer(service IOrderService) *OrdersServer {
	return &OrdersServer{
		service: service,
	}
}

func (s *OrdersServer) Register(grpcServer *grpc.Server) {
	api.RegisterOrdersServiceServer(grpcServer, s)
}


##### internal/adapter/grpc/util.go #####
package server

import (
	"gitlab.ozon.dev/safariproxd/homework/internal/domain"
	"gitlab.ozon.dev/safariproxd/homework/pkg/api"
	"google.golang.org/protobuf/types/known/timestamppb"
)

func mapPackageTypeToString(pt api.PackageType) string {
	switch pt {
	case api.PackageType_PACKAGE_TYPE_BAG:
		return "bag"
	case api.PackageType_PACKAGE_TYPE_BOX:
		return "box"
	case api.PackageType_PACKAGE_TYPE_TAPE:
		return "film"
	case api.PackageType_PACKAGE_TYPE_BAG_TAPE:
		return "bag+film"
	case api.PackageType_PACKAGE_TYPE_BOX_TAPE:
		return "box+film"
	default:
		return ""
	}
}

func mapDomainStatusToProto(status domain.OrderStatus) api.OrderStatus {
	switch status {
	case domain.StatusInStorage:
		return api.OrderStatus_ORDER_STATUS_EXPECTS
	case domain.StatusGivenToClient:
		return api.OrderStatus_ORDER_STATUS_ACCEPTED
	case domain.StatusReturnedFromClient:
		return api.OrderStatus_ORDER_STATUS_RETURNED
	case domain.StatusReturnedWithoutClient, domain.StatusGivenToCourier:
		return api.OrderStatus_ORDER_STATUS_DELETED
	default:
		return api.OrderStatus_ORDER_STATUS_UNSPECIFIED
	}
}

func mapDomainOrderToProto(order domain.Order) *api.Order {
	pkgType := mapStringToPackageType(order.PackageType)
	return &api.Order{
		OrderId:    order.OrderID,
		UserId:     order.ReceiverID,
		Status:     mapDomainStatusToProto(order.Status),
		ExpiresAt:  timestamppb.New(order.StorageUntil),
		Weight:     float32(order.Weight),
		TotalPrice: float32(order.Price),
		Package:    &pkgType,
	}
}

func mapStringToPackageType(pt string) api.PackageType {
	switch pt {
	case "bag":
		return api.PackageType_PACKAGE_TYPE_BAG
	case "box":
		return api.PackageType_PACKAGE_TYPE_BOX
	case "film":
		return api.PackageType_PACKAGE_TYPE_TAPE
	case "bag+film":
		return api.PackageType_PACKAGE_TYPE_BAG_TAPE
	case "box+film":
		return api.PackageType_PACKAGE_TYPE_BOX_TAPE
	default:
		return api.PackageType_PACKAGE_TYPE_UNSPECIFIED
	}
}


##### internal/app/accept_order.go #####
package app

import (
	"context"
	"fmt"

	"gitlab.ozon.dev/safariproxd/homework/internal/domain"
	"gitlab.ozon.dev/safariproxd/homework/pkg/db"
)

// удалил часть валидации из бизнес логики, ибо в protoc validate она уже встроена
func (s *PVZService) AcceptOrder(ctx context.Context, req domain.AcceptOrderRequest) (float64, error) {
	currentTime := s.nowFn()

	if _, err := s.orderRepo.GetByID(ctx, req.OrderID); err == nil {
		return 0, fmt.Errorf("repo.GetByID: %w",
			domain.OrderAlreadyExistsError(req.OrderID))
	}

	var rules []domain.PackageRules
	if req.PackageType != "" {
		var err error
		rules, err = s.orderRepo.GetPackageRules(ctx, req.PackageType)
		if err != nil {
			return 0, fmt.Errorf("validation: %w", err)
		}
	}

	totalPrice := req.Price
	for _, r := range rules {
		if r.MaxWeight > 0 && req.Weight > r.MaxWeight {
			return 0, fmt.Errorf("validation: %w",
				domain.WeightTooHeavyError(req.PackageType, req.Weight, r.MaxWeight))
		}
		totalPrice += r.Price
	}

	order := domain.Order{
		OrderID:        req.OrderID,
		ReceiverID:     req.ReceiverID,
		StorageUntil:   req.StorageUntil,
		Status:         domain.StatusInStorage,
		AcceptTime:     currentTime,
		LastUpdateTime: currentTime,
		PackageType:    req.PackageType,
		Weight:         req.Weight,
		Price:          totalPrice,
	}

	history := domain.OrderHistory{
		OrderID:   req.OrderID,
		Status:    domain.StatusInStorage,
		ChangedAt: currentTime,
	}
	event := domain.NewEvent(
		domain.EventTypeOrderAccepted,
		domain.Actor{
			Type: domain.ActorTypeCourier,
			ID:   1,
		},
		domain.OrderInfo{
			ID:     req.OrderID,
			UserID: req.ReceiverID,
			Status: "accepted",
		},
	)
	if s.dbClient == nil {
		if err := s.orderRepo.Save(ctx, order); err != nil {
			return 0, fmt.Errorf("repo.Save: %w", err)
		}

		history := domain.OrderHistory{
			OrderID:   req.OrderID,
			Status:    domain.StatusInStorage,
			ChangedAt: currentTime,
		}
		if err := s.orderRepo.SaveHistory(ctx, history); err != nil {
			return 0, fmt.Errorf("repo.SaveHistory: %w", err)
		}

		return totalPrice, nil

	}
	err := s.withTransaction(ctx, func(tx *db.Tx) error {
		if err := saveOrderInTx(ctx, tx, order); err != nil {
			return fmt.Errorf("save order: %w", err)
		}

		if err := saveHistoryInTx(ctx, tx, history); err != nil {
			return fmt.Errorf("save history: %w", err)
		}

		if err := saveEventInTx(ctx, tx, event); err != nil {
			return fmt.Errorf("save event: %w", err)
		}

		return nil
	})

	if err != nil {
		return 0, err
	}

	return totalPrice, nil
}


##### internal/app/get_orders.go #####
package app

import (
	"context"
	"fmt"
	"sort"

	"gitlab.ozon.dev/safariproxd/homework/internal/domain"
)

func (s *PVZService) GetReceiverOrders(ctx context.Context, req domain.ReceiverOrdersRequest) ([]domain.Order, uint64, error) {
	receiverOrders, err := s.orderRepo.GetByReceiverID(ctx, req.ReceiverID)
	if err != nil {
		return nil, 0, fmt.Errorf("repo.GetByReceiverID: %w", err)
	}

	var filteredOrders []domain.Order
	for _, order := range receiverOrders {
		if req.InPVZ && order.Status != domain.StatusInStorage {
			continue
		}
		filteredOrders = append(filteredOrders, order)
	}

	var paginatedOrders []domain.Order
	totalItems := uint64(len(filteredOrders))

	if req.LastN > 0 {
		if totalItems > req.LastN {
			paginatedOrders = filteredOrders[totalItems-req.LastN:]
		} else {
			paginatedOrders = filteredOrders
		}
	} else {
		paginatedOrders = Paginate(filteredOrders, req.Page, req.Limit)
	}

	return paginatedOrders, totalItems, nil
}

func (s *PVZService) GetReturnedOrders(ctx context.Context, page, limit uint64) ([]domain.Order, uint64, error) {
	returnOrders, err := s.orderRepo.GetReturnedOrders(ctx)
	if err != nil {
		return nil, 0, fmt.Errorf("repo.GetReturnedOrders: %w", err)
	}

	paginated := Paginate(returnOrders, page, limit)
	return paginated, uint64(len(returnOrders)), nil
}

func (s *PVZService) GetOrderHistory(ctx context.Context) ([]domain.Order, error) {
	orders, err := s.orderRepo.GetAllOrders(ctx)
	if err != nil {
		return nil, fmt.Errorf("repo.GetAllOrders: %w", err)
	}

	sort.Slice(orders, func(i, j int) bool {
		return orders[i].LastUpdateTime.After(orders[j].LastUpdateTime)
	})
	return orders, nil
}

func (s *PVZService) GetOrderHistoryByID(ctx context.Context, orderID uint64) ([]domain.OrderHistory, error) {
	history, err := s.orderRepo.GetHistoryByOrderID(ctx, orderID)
	if err != nil {
		return nil, fmt.Errorf("repo.GetHistoryByOrderID: %w", err)
	}

	if len(history) == 0 {
		return nil, fmt.Errorf("history: %w", domain.EntityNotFoundError("Order", fmt.Sprintf("%d", orderID)))
	}
	sort.Slice(history, func(i, j int) bool {
		return history[i].ChangedAt.After(history[j].ChangedAt)
	})

	return history, nil
}

// не используется в grpc (была как доп.задание в д/з 1)
func (s *PVZService) GetReceiverOrdersScroll(ctx context.Context, receiverID uint64, lastID, limit uint64) ([]domain.Order, uint64, error) {
	receiverOrders, err := s.orderRepo.GetByReceiverID(ctx, receiverID)
	if err != nil {
		return nil, 0, fmt.Errorf("repo.GetByReceiverID: %w", err)
	}

	sort.Slice(receiverOrders, func(i, j int) bool {
		return receiverOrders[i].OrderID < receiverOrders[j].OrderID
	})

	totalItems := uint64(len(receiverOrders))
	var resultOrders []domain.Order
	var nextLastID uint64

	startIndex := -1
	if lastID > 0 {
		for i, order := range receiverOrders {
			if order.OrderID == lastID {
				startIndex = i
				break
			}
		}
		if startIndex == -1 {
			return []domain.Order{}, totalItems, nil
		}
	}

	startOffset := startIndex + 1
	if startOffset >= len(receiverOrders) {
		return []domain.Order{}, totalItems, nil
	}

	endOffset := startOffset + int(limit)
	if endOffset > len(receiverOrders) {
		endOffset = len(receiverOrders)
	}
	resultOrders = receiverOrders[startOffset:endOffset]

	if len(resultOrders) > 0 && endOffset < len(receiverOrders) {
		nextLastID = resultOrders[len(resultOrders)-1].OrderID
	}

	return resultOrders, nextLastID, nil
}


##### internal/app/import_orders.go #####
package app

import (
	"context"
	"fmt"

	"gitlab.ozon.dev/safariproxd/homework/internal/adapter/cli"
	"gitlab.ozon.dev/safariproxd/homework/internal/domain"
)

func (s *PVZService) importSingle(ctx context.Context, raw domain.OrderToImport) error {
	storageUntil, err := cli.MapStringToTime(raw.StorageUntil)
	if err != nil {
		return fmt.Errorf("time.Parse: %w", err)
	}
	req := domain.AcceptOrderRequest{
		ReceiverID:   raw.ReceiverID,
		OrderID:      raw.OrderID,
		StorageUntil: storageUntil,
		Weight:       raw.Weight,
		Price:        raw.Price,
		PackageType:  raw.PackageType,
	}
	_, err = s.AcceptOrder(ctx, req)
	return err
}

func (s *PVZService) ImportOrders(
	ctx context.Context,
	orders []domain.OrderToImport,
) (uint64, error) {
	return processConcurrently(ctx, orders, s.workerLimit, s.importSingle)
}


##### internal/app/issue_orders.go #####
package app

import (
	"context"
	"fmt"
	"time"

	"gitlab.ozon.dev/safariproxd/homework/internal/adapter/cli"
	"gitlab.ozon.dev/safariproxd/homework/internal/domain"
	"gitlab.ozon.dev/safariproxd/homework/pkg/db"
)

func (s *PVZService) issueSingle(ctx context.Context, receiverID uint64, orderID uint64, now time.Time) error {
	order, err := s.orderRepo.GetByID(ctx, orderID)
	if err != nil {
		return fmt.Errorf("repo.GetByID: %w", err)
	}

	if order.ReceiverID != receiverID {
		return domain.BelongsToDifferentReceiverError(orderID, receiverID, order.ReceiverID)
	}
	if order.Status == domain.StatusGivenToClient {
		return domain.OrderAlreadyGivenError(orderID)
	}
	if order.Status == domain.StatusReturnedFromClient {
		return domain.UnavaliableReturnedOrderError(orderID)
	}
	if now.After(order.StorageUntil) {
		return domain.StorageExpiredError(orderID, cli.MapTimeToString(order.StorageUntil))
	}

	order.Status = domain.StatusGivenToClient
	order.LastUpdateTime = now

	hist := domain.OrderHistory{
		OrderID:   orderID,
		Status:    domain.StatusGivenToClient,
		ChangedAt: now,
	}

	event := domain.NewEvent(
		domain.EventTypeOrderIssued,
		domain.Actor{
			Type: domain.ActorTypeClient,
			ID:   receiverID,
		},
		domain.OrderInfo{
			ID:     orderID,
			UserID: receiverID,
			Status: "issued",
		},
	)
	if s.dbClient == nil {
		if err := s.orderRepo.Update(ctx, order); err != nil {
			return fmt.Errorf("failed to update order: %w", err)
		}
		history := domain.OrderHistory{
			OrderID:   order.OrderID,
			Status:    order.Status,
			ChangedAt: order.AcceptTime,
		}
		return s.orderRepo.SaveHistory(ctx, history)
	}
	return s.withTransaction(ctx, func(tx *db.Tx) error {
		if err := updateOrderInTx(ctx, tx, order); err != nil {
			return fmt.Errorf("update order: %w", err)
		}

		if err := saveHistoryInTx(ctx, tx, hist); err != nil {
			return fmt.Errorf("save history: %w", err)
		}

		if err := saveEventInTx(ctx, tx, event); err != nil {
			return fmt.Errorf("save event: %w", err)
		}

		return nil
	})
}

func (s *PVZService) IssueOrdersToClient(
	ctx context.Context,
	receiverID uint64,
	orderIDs []uint64,
) error {
	_, err := processConcurrently(ctx, orderIDs, s.workerLimit, func(c context.Context, id uint64) error {
		return s.issueSingle(c, receiverID, id, s.nowFn())
	})
	return err
}


##### internal/app/return_order_client.go #####
package app

import (
	"context"
	"fmt"
	"time"

	"gitlab.ozon.dev/safariproxd/homework/internal/domain"
	"gitlab.ozon.dev/safariproxd/homework/pkg/db"
)

func (s *PVZService) returnSingle(ctx context.Context, receiverID uint64, orderID uint64, now time.Time) error {
	order, err := s.orderRepo.GetByID(ctx, orderID)
	if err != nil {
		return fmt.Errorf("repo.GetByID: %w", err)
	}

	if order.ReceiverID != receiverID {
		return domain.BelongsToDifferentReceiverError(orderID, receiverID, order.ReceiverID)
	}
	if order.Status == domain.StatusInStorage {
		return domain.AlreadyInStorageError(orderID)
	}
	if now.Sub(order.LastUpdateTime) > 48*time.Hour {
		return domain.ReturnPeriodExpiredError(orderID, now.Sub(order.LastUpdateTime).Hours())
	}

	order.Status = domain.StatusReturnedFromClient
	order.LastUpdateTime = now

	hist := domain.OrderHistory{
		OrderID:   orderID,
		Status:    domain.StatusReturnedFromClient,
		ChangedAt: now,
	}

	event := domain.NewEvent(
		domain.EventTypeOrderReturnedByClient,
		domain.Actor{
			Type: domain.ActorTypeClient,
			ID:   receiverID,
		},
		domain.OrderInfo{
			ID:     orderID,
			UserID: receiverID,
			Status: "returned_by_client",
		},
	)
	if s.dbClient == nil {
		if err := s.orderRepo.Update(ctx, order); err != nil {
			return fmt.Errorf("failed to update order: %w", err)
		}
		history := domain.OrderHistory{
			OrderID:   order.OrderID,
			Status:    order.Status,
			ChangedAt: order.AcceptTime,
		}
		return s.orderRepo.SaveHistory(ctx, history)
	}
	return s.withTransaction(ctx, func(tx *db.Tx) error {
		if err := updateOrderInTx(ctx, tx, order); err != nil {
			return fmt.Errorf("update order: %w", err)
		}

		if err := saveHistoryInTx(ctx, tx, hist); err != nil {
			return fmt.Errorf("save history: %w", err)
		}

		if err := saveEventInTx(ctx, tx, event); err != nil {
			return fmt.Errorf("save event: %w", err)
		}

		return nil
	})
}

func (s *PVZService) ReturnOrdersFromClient(
	ctx context.Context,
	receiverID uint64,
	orderIDs []uint64,
) error {
	now := s.nowFn()
	_, err := processConcurrently(ctx, orderIDs, s.workerLimit, func(c context.Context, id uint64) error {
		return s.returnSingle(c, receiverID, id, now)
	})
	return err
}


##### internal/app/return_order_delivery.go #####
package app

import (
	"context"
	"fmt"

	"gitlab.ozon.dev/safariproxd/homework/internal/adapter/cli"
	"gitlab.ozon.dev/safariproxd/homework/internal/domain"
	"gitlab.ozon.dev/safariproxd/homework/pkg/db"
)

func (s *PVZService) ReturnOrderToDelivery(ctx context.Context, orderID uint64) error {
	order, err := s.orderRepo.GetByID(ctx, orderID)
	if err != nil {
		return fmt.Errorf("repo.GetByID: %w", err)
	}

	if order.Status != domain.StatusInStorage && order.Status != domain.StatusReturnedFromClient {
		return fmt.Errorf("validation: %w", domain.ValidationFailedError(
			fmt.Sprintf("order is not in storage (current status: %s)", order.GetStatusString())))
	}
	if s.nowFn().Before(order.StorageUntil) {
		return fmt.Errorf("validation: %w", domain.StorageNotExpiredError(
			orderID, cli.MapTimeToString(order.StorageUntil)))
	}

	newStatus := domain.StatusReturnedWithoutClient
	if order.Status == domain.StatusReturnedFromClient {
		newStatus = domain.StatusGivenToCourier
	}
	order.Status = newStatus
	order.LastUpdateTime = s.nowFn()

	history := domain.OrderHistory{
		OrderID:   orderID,
		Status:    newStatus,
		ChangedAt: order.LastUpdateTime,
	}

	event := domain.NewEvent(
		domain.EventTypeOrderReturnedToCourier,
		domain.Actor{
			Type: domain.ActorTypeSystem,
			ID:   0,
		},
		domain.OrderInfo{
			ID:     orderID,
			UserID: order.ReceiverID,
			Status: "returned_to_courier",
		},
	)
	if s.dbClient == nil {
		if err := s.orderRepo.Update(ctx, order); err != nil {
			return fmt.Errorf("failed to update order: %w", err)
		}
		history := domain.OrderHistory{
			OrderID:   order.OrderID,
			Status:    order.Status,
			ChangedAt: order.AcceptTime,
		}
		return s.orderRepo.SaveHistory(ctx, history)
	}
	return s.withTransaction(ctx, func(tx *db.Tx) error {
		if err := updateOrderInTx(ctx, tx, order); err != nil {
			return fmt.Errorf("update order: %w", err)
		}

		if err := saveHistoryInTx(ctx, tx, history); err != nil {
			return fmt.Errorf("save history: %w", err)
		}

		if err := saveEventInTx(ctx, tx, event); err != nil {
			return fmt.Errorf("save event: %w", err)
		}

		return nil
	})
}


##### internal/app/service.go #####
package app

import (
	"context"
	"sync/atomic"
	"time"

	"gitlab.ozon.dev/safariproxd/homework/internal/domain"
	"gitlab.ozon.dev/safariproxd/homework/pkg/db"
	"golang.org/x/sync/errgroup"
)

type OrderRepository interface {
	Save(ctx context.Context, order domain.Order) error
	GetByID(ctx context.Context, orderID uint64) (domain.Order, error)
	Update(ctx context.Context, order domain.Order) error
	GetByReceiverID(ctx context.Context, receiverID uint64) ([]domain.Order, error)
	GetReturnedOrders(ctx context.Context) ([]domain.Order, error)
	GetAllOrders(ctx context.Context) ([]domain.Order, error)
	GetPackageRules(ctx context.Context, code string) ([]domain.PackageRules, error)
	SaveHistory(ctx context.Context, history domain.OrderHistory) error
	GetHistoryByOrderID(ctx context.Context, orderID uint64) ([]domain.OrderHistory, error)
}

type OutboxRepository interface {
	Save(ctx context.Context, payload []byte) error
}

type PVZService struct {
	orderRepo   OrderRepository
	outboxRepo  OutboxRepository
	dbClient    *db.Client
	nowFn       func() time.Time
	workerLimit int
}

func NewPVZService(orderRepo OrderRepository, outboxRepo OutboxRepository, dbClient *db.Client, nowFn func() time.Time, limit int) *PVZService {
	if nowFn == nil {
		nowFn = time.Now
	}
	if limit <= 0 {
		limit = 1
	}
	return &PVZService{
		orderRepo:   orderRepo,
		outboxRepo:  outboxRepo,
		dbClient:    dbClient,
		nowFn:       nowFn,
		workerLimit: limit,
	}
}

func Paginate[T any](items []T, currentPage, itemsPerPage uint64) []T {
	totalItems := uint64(len(items))

	if itemsPerPage == 0 {
		return []T{}
	}
	if currentPage == 0 {
		currentPage = 1
	}

	startIndex := (currentPage - 1) * itemsPerPage
	endIndex := startIndex + itemsPerPage

	if startIndex >= totalItems {
		return []T{}
	}
	if endIndex > totalItems {
		endIndex = totalItems
	}

	return items[startIndex:endIndex]
}

func processConcurrently[T any](
	parentCtx context.Context,
	items []T,
	workerLimit int,
	fn func(context.Context, T) error,
) (uint64, error) {
	g, ctx := errgroup.WithContext(parentCtx)
	sem := make(chan struct{}, workerLimit)

	var processed uint64

	for _, item := range items {
		g.Go(func() error {
			select {
			case sem <- struct{}{}:
			case <-ctx.Done():
				return ctx.Err()
			}
			defer func() {
				<-sem
			}()

			if err := fn(ctx, item); err != nil {
				return err
			}
			atomic.AddUint64(&processed, 1)
			return nil
		})
	}

	err := g.Wait()
	return processed, err
}


##### internal/app/tests_utils.go #####
package app

import (
	"context"
	"testing"
	"time"

	"github.com/gojuno/minimock/v3"
	"github.com/stretchr/testify/assert"
	"gitlab.ozon.dev/safariproxd/homework/internal/adapter/cli"
	"gitlab.ozon.dev/safariproxd/homework/internal/app/mock"
	"gitlab.ozon.dev/safariproxd/homework/internal/domain"
)

var (
	someConstTime  = time.Date(2025, time.June, 28, 3, 26, 0, 0, time.UTC)
	contextBack    = context.Background()
	someRecieverID = uint64(100)
)

func Stored(id uint64, status domain.OrderStatus) domain.Order {
	return domain.Order{
		OrderID:        id,
		ReceiverID:     someRecieverID,
		StorageUntil:   someConstTime.Add(24 * time.Hour),
		Status:         status,
		LastUpdateTime: someConstTime.Add(time.Duration(id) * time.Minute),
	}
}

func IdsOf(ord []domain.Order) (ids []uint64) {
	for _, o := range ord {
		ids = append(ids, o.OrderID)
	}
	return
}

func NewEnv(t *testing.T) (*mock.OrderRepositoryMock, *PVZService) {
	ctrl := minimock.NewController(t)
	repo := mock.NewOrderRepositoryMock(ctrl)
	const testWorkerLimit = 8
	outbox := mock.NewOutboxRepositoryMock(ctrl)
	svc := &PVZService{orderRepo: repo, outboxRepo: outbox, dbClient: nil, nowFn: func() time.Time { return someConstTime }, workerLimit: testWorkerLimit}
	return repo, svc
}

func BuildOrder(id uint64, status domain.OrderStatus,
	storageOff, updateOff time.Duration) domain.Order {

	o := Stored(id, status)
	o.StorageUntil = someConstTime.Add(storageOff)
	o.LastUpdateTime = someConstTime.Add(updateOff)
	return o
}

func OrderInStorage(id uint64, storageOff time.Duration) domain.Order {
	return BuildOrder(id, domain.StatusInStorage, storageOff, 0)
}

func OrderGiven(id uint64, lastUpdOff time.Duration) domain.Order {
	return BuildOrder(id, domain.StatusGivenToClient, 24*time.Hour, lastUpdOff)
}

func OrderReturned(id uint64, lastUpdOff time.Duration) domain.Order {
	return BuildOrder(id, domain.StatusReturnedFromClient, 24*time.Hour, lastUpdOff)
}

func Updated(o domain.Order, newStatus domain.OrderStatus, t time.Time) domain.Order {
	o.Status, o.LastUpdateTime = newStatus, t
	return o
}
func DateString(off time.Duration) string {
	return cli.MapTimeToString(someConstTime.Add(off))
}

func History(orderID uint64, status domain.OrderStatus,
	changedOff time.Duration) domain.OrderHistory {

	return domain.OrderHistory{
		OrderID:   orderID,
		Status:    status,
		ChangedAt: someConstTime.Add(changedOff),
	}
}

func TimesOf(h []domain.OrderHistory) (ts []time.Time) {
	for _, rec := range h {
		ts = append(ts, rec.ChangedAt)
	}
	return
}

func DTO(id uint64, pkg string, off time.Duration) domain.OrderToImport {
	return domain.OrderToImport{
		OrderID:      id,
		ReceiverID:   someRecieverID,
		StorageUntil: DateString(off),
		PackageType:  pkg,
		Weight:       5,
		Price:        100,
	}
}

func errIs(target error) assert.ErrorAssertionFunc {
	return func(t assert.TestingT, err error, _ ...interface{}) bool {
		return assert.ErrorIs(t, err, target)
	}
}


##### internal/app/tx_helper.go #####
package app

import (
	"context"
	"encoding/json"
	"fmt"

	"gitlab.ozon.dev/safariproxd/homework/internal/domain"
	"gitlab.ozon.dev/safariproxd/homework/pkg/db"
)

func saveOrderInTx(ctx context.Context, tx *db.Tx, o domain.Order) error {
	const query = `
        INSERT INTO orders (
            id, receiver_id, expires_at, status,
            accept_time, last_update_time, package_code, weight, price)
        VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9)
        ON CONFLICT (id) DO NOTHING`

	res, err := tx.Exec(ctx, query,
		o.OrderID, o.ReceiverID, o.StorageUntil, o.Status,
		o.AcceptTime, o.LastUpdateTime, o.PackageType, o.Weight, o.Price,
	)
	if err != nil {
		return fmt.Errorf("exec insert: %w", err)
	}
	rows, _ := res.RowsAffected()
	if rows == 0 {
		return domain.OrderAlreadyExistsError(o.OrderID)
	}
	return nil
}

func updateOrderInTx(ctx context.Context, tx *db.Tx, o domain.Order) error {
	const query = `
        UPDATE orders
        SET receiver_id = $2, expires_at = $3, status = $4,
            accept_time = $5, last_update_time = $6,
            package_code = $7, weight = $8, price = $9
        WHERE id = $1`

	res, err := tx.Exec(ctx, query,
		o.OrderID, o.ReceiverID, o.StorageUntil, o.Status,
		o.AcceptTime, o.LastUpdateTime, o.PackageType, o.Weight, o.Price,
	)
	if err != nil {
		return fmt.Errorf("exec update: %w", err)
	}
	rows, _ := res.RowsAffected()
	if rows == 0 {
		return domain.EntityNotFoundError("Order", fmt.Sprintf("%d", o.OrderID))
	}
	return nil
}

func saveHistoryInTx(ctx context.Context, tx *db.Tx, h domain.OrderHistory) error {
	const query = `INSERT INTO order_history (order_id, status, changed_at) VALUES ($1,$2,$3)`
	_, err := tx.Exec(ctx, query, h.OrderID, h.Status, h.ChangedAt)
	if err != nil {
		return fmt.Errorf("exec insert history: %w", err)
	}
	return nil
}

func saveEventInTx(ctx context.Context, tx *db.Tx, event domain.Event) error {
	payload, err := json.Marshal(event)
	if err != nil {
		return fmt.Errorf("marshal event: %w", err)
	}
	const query = `
        INSERT INTO outbox (id, payload, status, created_at)
        VALUES (gen_random_uuid(), $1, $2, NOW())
    `
	_, err = tx.Exec(ctx, query, payload, domain.OutboxStatusCreated)
	if err != nil {
		return fmt.Errorf("save outbox message: %w", err)
	}
	return nil
}

func (s *PVZService) withTransaction(ctx context.Context, fn func(*db.Tx) error) error {
	tx, err := s.dbClient.BeginTx(ctx)
	if err != nil {
		return fmt.Errorf("begin tx: %w", err)
	}

	defer func() {
		if err != nil {
			_ = tx.Rollback()
		}
	}()

	if err = fn(tx); err != nil {
		return err
	}

	if err = tx.Commit(); err != nil {
		return fmt.Errorf("commit tx: %w", err)
	}

	return nil
}


##### internal/config/config.go #####
package config

import (
	"fmt"
	"os"
	"time"

	"github.com/caarlos0/env/v10"
	"github.com/pkg/errors"
	"gopkg.in/yaml.v3"
)

type Config struct {
	Service struct {
		GRPCAddress    string        `yaml:"grpc_address"`
		HTTPAddress    string        `yaml:"http_address"`
		SwaggerAddress string        `yaml:"swagger_address"`
		AdminAddress   string        `yaml:"admin_address"`
		Timeout        time.Duration `yaml:"timeout"`
		WorkerLimit    int           `yaml:"worker_limit"`
		QueueSize      int           `yaml:"queue_size"`
	} `yaml:"service"`

	DB struct {
		ReadHost  string `yaml:"read_host" env:"POSTGRES_READ_HOST"`
		WriteHost string `yaml:"write_host" env:"POSTGRES_WRITE_HOST"`
		Port      int    `yaml:"port" env:"POSTGRES_PORT"`
		Name      string `yaml:"name" env:"POSTGRES_DB"`
		User      string `yaml:"-" env:"POSTGRES_USER"`
		Pass      string `yaml:"-" env:"POSTGRES_PASSWORD"`
		SSL       string `yaml:"sslmode"`
		Pool      struct {
			MaxOpen int `yaml:"max_open"`
			MaxIdle int `yaml:"max_idle"`
		} `yaml:"pool"`
		MigrationsDir string `yaml:"migrations_dir"`
	} `yaml:"db"`

	Kafka struct {
		Brokers  []string `yaml:"brokers"`
		Topic    string   `yaml:"topic"`
		Producer struct {
			Timeout time.Duration `yaml:"timeout"`
			Retries int           `yaml:"retries"`
		} `yaml:"producer"`
	} `yaml:"kafka"`

	Outbox struct {
		WorkerInterval time.Duration `yaml:"worker_interval"`
		BatchSize      int           `yaml:"batch_size"`
	} `yaml:"outbox"`
}

func (c *Config) ReadDSN() string {
	return fmt.Sprintf(
		"postgres://%s:%s@%s:%d/%s?sslmode=%s",
		c.DB.User, c.DB.Pass, c.DB.ReadHost, c.DB.Port, c.DB.Name, c.DB.SSL)
}

func (c *Config) WriteDSN() string {
	return fmt.Sprintf(
		"postgres://%s:%s@%s:%d/%s?sslmode=%s",
		c.DB.User, c.DB.Pass, c.DB.WriteHost, c.DB.Port, c.DB.Name, c.DB.SSL)
}

func Load(path string) (*Config, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, errors.Wrap(err, "read yaml")
	}

	var cfg Config
	if err := yaml.Unmarshal(data, &cfg); err != nil {
		return nil, errors.Wrap(err, "parse yaml")
	}

	if err := env.Parse(&cfg); err != nil {
		return nil, errors.Wrap(err, "parse env")
	}
	return &cfg, nil
}


##### internal/domain/errors.go #####
package domain

import "fmt"

type ErrorCode int64

const (
	ErrorCodeNotFound               ErrorCode = 1
	ErrorCodeAlreadyExists          ErrorCode = 2
	ErrorCodeStorageExpired         ErrorCode = 3
	ErrorCodeValidationFailed       ErrorCode = 4
	ErrorCodeAlreadyGiven           ErrorCode = 5
	ErrorCodeBelongsToOtherReceiver ErrorCode = 6
	ErrorCodeAlreadyInStorage       ErrorCode = 7
	ErrorCodeReturnPeriodExpired    ErrorCode = 8
	ErrorCodeStorageNotExpired      ErrorCode = 9
	ErrorCodeUnavaliableReturned    ErrorCode = 10
	ErrorCodeNilOrder               ErrorCode = 11
	ErrorCodeInvalidPackage         ErrorCode = 12
	ErrorCodeWeightTooHeavy         ErrorCode = 13
)

type Error struct {
	Code    ErrorCode
	Message string
}

func (e Error) Error() string {
	return e.Message
}

func EntityNotFoundError(entityName, entityID string) error {
	return Error{
		Code:    ErrorCodeNotFound,
		Message: fmt.Sprintf("Entity %q with ID %s not found", entityName, entityID),
	}
}

func OrderAlreadyExistsError(orderID uint64) error {
	return Error{
		Code:    ErrorCodeAlreadyExists,
		Message: fmt.Sprintf("Order %d already exists", orderID),
	}
}

func StorageExpiredError(orderID uint64, storageUntil string) error {
	return Error{
		Code:    ErrorCodeStorageExpired,
		Message: fmt.Sprintf("Order %d storage period expired (%s)", orderID, storageUntil),
	}
}

func ValidationFailedError(message string) error {
	return Error{
		Code:    ErrorCodeValidationFailed,
		Message: message,
	}
}

func OrderAlreadyGivenError(orderID uint64) error {
	return Error{
		Code:    ErrorCodeAlreadyGiven,
		Message: fmt.Sprintf("Order %d already given to client", orderID),
	}
}

func BelongsToDifferentReceiverError(orderID, expectedReceiverID, actualReceiverID uint64) error {
	return Error{
		Code:    ErrorCodeBelongsToOtherReceiver,
		Message: fmt.Sprintf("Order %d belongs to a different receiver (expected %d, got %d)", orderID, expectedReceiverID, actualReceiverID),
	}
}

func AlreadyInStorageError(orderID uint64) error {
	return Error{
		Code:    ErrorCodeAlreadyInStorage,
		Message: fmt.Sprintf("Order %d is already in storage", orderID),
	}
}

func ReturnPeriodExpiredError(orderID uint64, hoursSinceGiven float64) error {
	return Error{
		Code:    ErrorCodeReturnPeriodExpired,
		Message: fmt.Sprintf("Order %d return period expired (%.1f hours)", orderID, hoursSinceGiven),
	}
}

func StorageNotExpiredError(orderID uint64, storageUntil string) error {
	return Error{
		Code:    ErrorCodeStorageNotExpired,
		Message: fmt.Sprintf("Order %d storage period not expired (until %s)", orderID, storageUntil),
	}
}

func UnavaliableReturnedOrderError(orderID uint64) error {
	return Error{
		Code:    ErrorCodeUnavaliableReturned,
		Message: fmt.Sprintf("Order %d is an unavailable returned order", orderID),
	}
}

func NilOrderError(orderID uint64) error {
	return Error{
		Code:    ErrorCodeNilOrder,
		Message: fmt.Sprintf("Order %d is nil", orderID),
	}
}

func InvalidPackageError(packageType string) error {
	return Error{
		Code:    ErrorCodeInvalidPackage,
		Message: fmt.Sprintf("Invalid package type: %s", packageType),
	}
}

func WeightTooHeavyError(packageType string, weight float64, maxWeight float64) error {
	return Error{
		Code:    ErrorCodeWeightTooHeavy,
		Message: fmt.Sprintf("Weight %.2f kg exceeds maximum allowed for %s (%.2f kg)", weight, packageType, maxWeight),
	}
}


##### internal/domain/event.go #####
package domain

import (
	"time"

	"github.com/google/uuid"
)

type EventType string

const (
	EventTypeOrderAccepted          EventType = "order_accepted"
	EventTypeOrderReturnedToCourier EventType = "order_returned_to_courier"
	EventTypeOrderIssued            EventType = "order_issued"
	EventTypeOrderReturnedByClient  EventType = "order_returned_by_client"
)

type ActorType string

const (
	ActorTypeCourier ActorType = "courier"
	ActorTypeClient  ActorType = "client"
	ActorTypeSystem  ActorType = "system"
)

type Event struct {
	EventID   string    `json:"event_id"`
	EventType EventType `json:"event_type"`
	Timestamp time.Time `json:"timestamp"`
	Actor     Actor     `json:"actor"`
	Order     OrderInfo `json:"order"`
	Source    string    `json:"source"`
}

type Actor struct {
	Type ActorType `json:"type"`
	ID   uint64    `json:"id,string"`
}

type OrderInfo struct {
	ID     uint64 `json:"id,string"`
	UserID uint64 `json:"user_id,string"`
	Status string `json:"status"`
}

func NewEvent(eventType EventType, actor Actor, order OrderInfo) Event {
	return Event{
		EventID:   uuid.New().String(),
		EventType: eventType,
		Timestamp: time.Now().UTC(),
		Actor:     actor,
		Order:     order,
		Source:    "pvz-api",
	}
}

type OutboxStatus string

const (
	OutboxStatusCreated    OutboxStatus = "CREATED"
	OutboxStatusProcessing OutboxStatus = "PROCESSING"
	OutboxStatusCompleted  OutboxStatus = "COMPLETED"
	OutboxStatusFailed     OutboxStatus = "FAILED"
)

type OutboxMessage struct {
	ID        uuid.UUID
	Payload   []byte
	Status    OutboxStatus
	Error     *string
	CreatedAt time.Time
	SentAt    *time.Time
}


##### internal/domain/order.go #####
package domain

import (
	"time"
)

type OrderStatus uint8

const (
	StatusInStorage OrderStatus = iota
	StatusGivenToClient
	StatusReturnedFromClient
	StatusReturnedWithoutClient
	StatusGivenToCourier
)

type Order struct {
	OrderID        uint64
	ReceiverID     uint64
	StorageUntil   time.Time
	Status         OrderStatus
	AcceptTime     time.Time
	LastUpdateTime time.Time
	PackageType    string
	Weight         float64
	Price          float64
}

type OrderHistory struct {
	OrderID   uint64
	Status    OrderStatus
	ChangedAt time.Time
}

type OrderToImport struct {
	OrderID      uint64  `json:"order_id"`
	ReceiverID   uint64  `json:"receiver_id"`
	StorageUntil string  `json:"storage_until"`
	PackageType  string  `json:"package_type"`
	Weight       float64 `json:"weight"`
	Price        float64 `json:"price"`
}

var OrdersToImport []OrderToImport

type AcceptOrderRequest struct {
	ReceiverID   uint64
	OrderID      uint64
	StorageUntil time.Time
	Weight       float64
	Price        float64
	PackageType  string
}

type ReceiverOrdersRequest struct {
	ReceiverID uint64
	InPVZ      bool
	LastN      uint64
	Page       uint64
	Limit      uint64
}

type PackageRules struct {
	MaxWeight float64 `json:"max_weight"`
	Price     float64 `json:"price"`
}

func (o Order) GetStatusString() string {
	switch o.Status {
	case StatusInStorage:
		return "In Storage"
	case StatusGivenToClient:
		return "Given to client"
	case StatusReturnedFromClient:
		return "Returned from client"
	case StatusGivenToCourier:
		return "Given to courier"
	case StatusReturnedWithoutClient:
		return "Given to courier without client"
	default:
		return "Unknown Status"
	}
}


##### internal/infra/admin.go #####
package infra

import (
	"context"
	"errors"
	"log/slog"
	"net/http"
	"strconv"

	"gitlab.ozon.dev/safariproxd/homework/internal/workerpool"
)

type AdminServer struct {
	srv  *http.Server
	pool *workerpool.Pool
}

func NewAdmin(addr string, pool *workerpool.Pool) *AdminServer {
	mux := http.NewServeMux()
	as := &AdminServer{srv: &http.Server{Addr: addr, Handler: mux}, pool: pool}

	mux.HandleFunc("/resize", func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			http.Error(w, "use POST", http.StatusMethodNotAllowed)
			return
		}
		n, _ := strconv.Atoi(r.URL.Query().Get("workers"))
		if n <= 0 {
			http.Error(w, "workers must be > 0", http.StatusBadRequest)
			return
		}
		as.pool.Resize(n)
		if _, err := w.Write([]byte("ok")); err != nil {
			slog.Warn("admin write failed", "error", err)
		}
	})
	return as
}

func (a *AdminServer) Start() {
	go func() {
		if err := a.srv.ListenAndServe(); err != nil && !errors.Is(err, http.ErrServerClosed) {
			slog.Error("admin listen error", "error", err)
		}
	}()
}

func (a *AdminServer) Shutdown(ctx context.Context) {
	if err := a.srv.Shutdown(ctx); err != nil {
		slog.Warn("admin shutdown error", "error", err)
	}
}


##### internal/infra/event_producer.go #####
package infra

import (
	"context"
	"encoding/json"
	"fmt"

	"gitlab.ozon.dev/safariproxd/homework/internal/domain"
	"gitlab.ozon.dev/safariproxd/homework/pkg/db"
)

type OutboxRepository interface {
	SaveInTx(ctx context.Context, tx *db.Tx, payload []byte) error
}

type EventProducer struct {
	outboxRepo OutboxRepository
}

func NewEventProducer(outboxRepo OutboxRepository) *EventProducer {
	return &EventProducer{
		outboxRepo: outboxRepo,
	}
}

func (p *EventProducer) ProduceInTx(ctx context.Context, tx *db.Tx, event domain.Event) error {
	payload, err := json.Marshal(event)
	if err != nil {
		return fmt.Errorf("marshal event: %w", err)
	}

	if err := p.outboxRepo.SaveInTx(ctx, tx, payload); err != nil {
		return fmt.Errorf("save to outbox: %w", err)
	}

	return nil
}


##### internal/infra/kafka_producer.go #####
package infra

import (
	"context"
	"fmt"
	"time"

	"github.com/IBM/sarama"
)

type KafkaProducer struct {
	producer sarama.SyncProducer
	topic    string
}

func NewKafkaProducer(brokers []string, topic string) (*KafkaProducer, error) {
	config := sarama.NewConfig()
	config.Producer.Return.Successes = true
	config.Producer.Flush.Messages = 1
	config.Producer.Flush.Frequency = 10 * time.Millisecond
	config.Producer.Partitioner = func(topic string) sarama.Partitioner {
		return sarama.NewHashPartitioner(topic)
	}

	producer, err := sarama.NewSyncProducer(brokers, config)
	if err != nil {
		return nil, fmt.Errorf("create sync producer: %w", err)
	}

	return &KafkaProducer{
		producer: producer,
		topic:    topic,
	}, nil
}

func (p *KafkaProducer) Send(ctx context.Context, message []byte) error {
	select {
	case <-ctx.Done():
		return ctx.Err()
	default:
	}

	_, _, err := p.producer.SendMessage(&sarama.ProducerMessage{
		Topic: p.topic,
		Value: sarama.ByteEncoder(message),
	})
	if err != nil {
		return fmt.Errorf("send message to kafka: %w", err)
	}
	return nil
}

func (p *KafkaProducer) Close() error {
	if err := p.producer.Close(); err != nil {
		return fmt.Errorf("close producer: %w", err)
	}
	return nil
}


##### internal/infra/shutdown.go #####
package infra

import (
	"context"
	"log/slog"
	"os"
	"os/signal"
	"sync"
	"syscall"
	"time"
)

const timeout = 10 * time.Second

func Graceful(cb ...func(context.Context)) {
	sigCh := make(chan os.Signal, 1)
	signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)
	defer signal.Stop(sigCh)

	<-sigCh
	slog.Info("graceful shutdown started")

	ctx, cancel := context.WithTimeout(context.Background(), timeout)
	defer cancel()

	go func() {
		select {
		case <-sigCh:
			slog.Warn("second interrupt — forcing exit")
			os.Exit(1)
		case <-ctx.Done():
		}
	}()

	var wg sync.WaitGroup
	for _, f := range cb {
		wg.Add(1)
		go func(fn func(context.Context)) {
			defer wg.Done()
			fn(ctx)
		}(f)
	}
	wg.Wait()
	slog.Info("shutdown complete")
}


##### internal/repository/postgres/crud.go #####
package postgres

import (
	"context"
	"database/sql"
	"errors"
	"fmt"

	"gitlab.ozon.dev/safariproxd/homework/internal/domain"
	"gitlab.ozon.dev/safariproxd/homework/pkg/db"
)

// транзакции внутри каждого CRUD решил удалить — как будто с ними могут быть проблемы при параллельных запросах
// сами транзакции сейчас не используются, но планирую в бизнес логике их использовать
// (например атомарно выполнять методы Save и SaveHistory)
func (r *OrderRepository) Exists(ctx context.Context, orderID uint64) (bool, error) {
	const query = `SELECT 1 FROM orders WHERE id = $1`
	var exists int
	err := r.client.QueryRow(ctx, query, orderID).Scan(&exists)
	if errors.Is(err, sql.ErrNoRows) {
		return false, nil
	}
	if err != nil {
		return false, fmt.Errorf("check existence: %w", err)
	}
	return true, nil
}

func (r *OrderRepository) Save(ctx context.Context, o domain.Order) error {
	const query = `
        INSERT INTO orders (
            id, receiver_id, expires_at, status,
            accept_time, last_update_time, package_code, weight, price)
        VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9)
        ON CONFLICT (id) DO NOTHING`

	res, err := r.client.Exec(ctx, db.ModeWrite, query,
		o.OrderID, o.ReceiverID, o.StorageUntil, o.Status,
		o.AcceptTime, o.LastUpdateTime, o.PackageType, o.Weight, o.Price,
	)
	if err != nil {
		return fmt.Errorf("exec insert: %w", err)
	}
	rows, _ := res.RowsAffected()
	if rows == 0 {
		return domain.OrderAlreadyExistsError(o.OrderID)
	}
	return nil
}

func (r *OrderRepository) Update(ctx context.Context, o domain.Order) error {
	const query = `
        UPDATE orders
        SET receiver_id = $2, expires_at = $3, status = $4,
            accept_time = $5, last_update_time = $6,
            package_code = $7, weight = $8, price = $9
        WHERE id = $1`

	res, err := r.client.Exec(ctx, db.ModeWrite, query,
		o.OrderID, o.ReceiverID, o.StorageUntil, o.Status,
		o.AcceptTime, o.LastUpdateTime, o.PackageType, o.Weight, o.Price,
	)
	if err != nil {
		return fmt.Errorf("exec update: %w", err)
	}
	rows, _ := res.RowsAffected()
	if rows == 0 {
		return domain.EntityNotFoundError("Order", fmt.Sprintf("%d", o.OrderID))
	}
	return nil
}

func (r *OrderRepository) SaveHistory(ctx context.Context, h domain.OrderHistory) error {
	const query = `INSERT INTO order_history (order_id, status, changed_at) VALUES ($1,$2,$3)`
	_, err := r.client.Exec(ctx, db.ModeWrite, query, h.OrderID, h.Status, h.ChangedAt)
	if err != nil {
		return fmt.Errorf("exec insert history: %w", err)
	}
	return nil
}


##### internal/repository/postgres/getters.go #####
package postgres

import (
	"context"
	"database/sql"
	"errors"
	"fmt"

	"gitlab.ozon.dev/safariproxd/homework/internal/domain"
)

func (r *OrderRepository) GetByID(ctx context.Context, orderID uint64) (domain.Order, error) {
	query := `
		SELECT id, receiver_id, expires_at, status, accept_time, last_update_time, package_code, weight, price
		FROM orders
		WHERE id = $1
	`
	row := r.client.QueryRow(ctx, query, orderID)

	order, err := scanOrder(row)
	if errors.Is(err, sql.ErrNoRows) {
		return domain.Order{}, fmt.Errorf("get by id: %w", domain.EntityNotFoundError("Order", fmt.Sprintf("%d", orderID)))
	}
	if err != nil {
		return domain.Order{}, err
	}

	return order, nil
}

func (r *OrderRepository) GetByReceiverID(ctx context.Context, receiverID uint64) ([]domain.Order, error) {
	query := `
		SELECT id, receiver_id, expires_at, status, accept_time, last_update_time, package_code, weight, price
		FROM orders
		WHERE receiver_id = $1
	`
	rows, err := r.client.Query(ctx, query, receiverID)
	if err != nil {
		return nil, fmt.Errorf("query: %w", err)
	}
	defer rows.Close()

	var orders []domain.Order
	for rows.Next() {
		order, err := scanOrder(rows)
		if err != nil {
			return nil, err
		}
		orders = append(orders, order)
	}

	return orders, nil
}

func (r *OrderRepository) GetReturnedOrders(ctx context.Context) ([]domain.Order, error) {
	query := `
		SELECT id, receiver_id, expires_at, status, accept_time, last_update_time, package_code, weight, price
		FROM orders
		WHERE status IN ($1, $2)
		ORDER BY last_update_time DESC
	`
	rows, err := r.client.Query(ctx, query, domain.StatusReturnedFromClient, domain.StatusGivenToCourier)
	if err != nil {
		return nil, fmt.Errorf("query: %w", err)
	}
	defer rows.Close()

	var orders []domain.Order
	for rows.Next() {
		order, err := scanOrder(rows)
		if err != nil {
			return nil, err
		}
		orders = append(orders, order)
	}

	return orders, nil
}

func (r *OrderRepository) GetAllOrders(ctx context.Context) ([]domain.Order, error) {
	query := `
		SELECT id, receiver_id, expires_at, status, accept_time, last_update_time, package_code, weight, price
		FROM orders
		ORDER BY last_update_time DESC
	`
	rows, err := r.client.Query(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("query: %w", err)
	}
	defer rows.Close()

	var orders []domain.Order
	for rows.Next() {
		order, err := scanOrder(rows)
		if err != nil {
			return nil, err
		}
		orders = append(orders, order)
	}

	return orders, nil
}

func (r *OrderRepository) GetPackageRules(ctx context.Context, code string) ([]domain.PackageRules, error) {
	query := `
		SELECT max_weight, extra_price
		FROM package_types
		WHERE code = $1
	`
	rows, err := r.client.Query(ctx, query, code)
	if err != nil {
		return nil, fmt.Errorf("query: %w", err)
	}
	defer rows.Close()

	var rules []domain.PackageRules
	for rows.Next() {
		var rule domain.PackageRules
		err := rows.Scan(&rule.MaxWeight, &rule.Price)
		if err != nil {
			return nil, fmt.Errorf("scan: %w", err)
		}
		rules = append(rules, rule)
	}

	if len(rules) == 0 {
		return nil, fmt.Errorf("no rules found for package code %s", code)
	}

	return rules, nil
}

func (r *OrderRepository) GetHistoryByOrderID(ctx context.Context, orderID uint64) ([]domain.OrderHistory, error) {
	query := `
        SELECT order_id, status, changed_at
        FROM order_history
        WHERE order_id = $1
        ORDER BY changed_at DESC
    `

	rows, err := r.client.Query(ctx, query, orderID)
	if err != nil {
		return nil, fmt.Errorf("query: %w", err)
	}
	defer rows.Close()

	var history []domain.OrderHistory
	for rows.Next() {
		var h domain.OrderHistory
		err := rows.Scan(&h.OrderID, &h.Status, &h.ChangedAt)
		if err != nil {
			return nil, fmt.Errorf("scan: %w", err)
		}
		history = append(history, h)
	}

	return history, nil
}


##### internal/repository/postgres/order_pg_repo.go #####
package postgres

import (
	"database/sql"
	"fmt"
	"time"

	"gitlab.ozon.dev/safariproxd/homework/internal/domain"
	"gitlab.ozon.dev/safariproxd/homework/pkg/db"
)

type Scanner interface {
	Scan(dest ...interface{}) error
}

func scanOrder(scanner Scanner) (domain.Order, error) {
	var order domain.Order
	var expiresAt, acceptTime, lastUpdateTime time.Time
	var packageCode sql.NullString

	err := scanner.Scan(
		&order.OrderID,
		&order.ReceiverID,
		&expiresAt,
		&order.Status,
		&acceptTime,
		&lastUpdateTime,
		&packageCode,
		&order.Weight,
		&order.Price,
	)
	if err != nil {
		return domain.Order{}, fmt.Errorf("scan: %w", err)
	}

	return domain.Order{
		OrderID:        order.OrderID,
		ReceiverID:     order.ReceiverID,
		StorageUntil:   expiresAt,
		Status:         order.Status,
		AcceptTime:     acceptTime,
		LastUpdateTime: lastUpdateTime,
		PackageType:    packageCode.String,
		Weight:         order.Weight,
		Price:          order.Price,
	}, nil
}

type OrderRepository struct {
	client *db.Client
}

func NewOrderRepository(client *db.Client) *OrderRepository {
	return &OrderRepository{client: client}
}


##### internal/repository/postgres/outbox.go #####
package postgres

import (
	"context"
	"database/sql"
	"fmt"

	"github.com/google/uuid"
	"gitlab.ozon.dev/safariproxd/homework/internal/domain"
	"gitlab.ozon.dev/safariproxd/homework/pkg/db"
)

type OutboxRepository struct {
	client *db.Client
}

func NewOutboxRepository(client *db.Client) *OutboxRepository {
	return &OutboxRepository{client: client}
}

func (r *OutboxRepository) Save(ctx context.Context, payload []byte) error {
	const query = `
		INSERT INTO outbox (payload, status, created_at)
		VALUES ($1, $2, NOW())
	`
	_, err := r.client.Exec(ctx, db.ModeWrite, query, payload, domain.OutboxStatusCreated)
	if err != nil {
		return fmt.Errorf("save outbox message: %w", err)
	}
	return nil
}

func (r *OutboxRepository) GetPendingMessages(ctx context.Context, limit int) ([]domain.OutboxMessage, error) {
	const query = `
		SELECT id, payload, status, error, created_at, sent_at
		FROM outbox
		WHERE status = $1
		ORDER BY created_at ASC
		LIMIT $2
		FOR UPDATE SKIP LOCKED
	`

	rows, err := r.client.Query(ctx, query, domain.OutboxStatusCreated, limit)
	if err != nil {
		return nil, fmt.Errorf("query pending messages: %w", err)
	}
	defer rows.Close()

	var messages []domain.OutboxMessage
	for rows.Next() {
		var msg domain.OutboxMessage
		var errorStr sql.NullString
		var sentAt sql.NullTime

		err := rows.Scan(&msg.ID, &msg.Payload, &msg.Status, &errorStr, &msg.CreatedAt, &sentAt)
		if err != nil {
			return nil, fmt.Errorf("scan message: %w", err)
		}

		if errorStr.Valid {
			msg.Error = &errorStr.String
		}
		if sentAt.Valid {
			msg.SentAt = &sentAt.Time
		}

		messages = append(messages, msg)
	}

	return messages, nil
}

func (r *OutboxRepository) UpdateStatus(ctx context.Context, id uuid.UUID, status domain.OutboxStatus, errorMsg *string) error {
	var query string
	var args []interface{}

	switch status {
	case domain.OutboxStatusProcessing:
		query = `UPDATE outbox SET status = $2 WHERE id = $1`
		args = []interface{}{id, status}
	case domain.OutboxStatusCompleted:
		query = `UPDATE outbox SET status = $2, sent_at = NOW() WHERE id = $1`
		args = []interface{}{id, status}
	case domain.OutboxStatusFailed:
		query = `UPDATE outbox SET status = $2, error = $3 WHERE id = $1`
		args = []interface{}{id, status, errorMsg}
	default:
		return fmt.Errorf("invalid status: %s", status)
	}

	res, err := r.client.Exec(ctx, db.ModeWrite, query, args...)
	if err != nil {
		return fmt.Errorf("update status: %w", err)
	}

	rows, _ := res.RowsAffected()
	if rows == 0 {
		return fmt.Errorf("message not found: %s", id)
	}

	return nil
}


##### internal/workerpool/job.go #####
package workerpool

import "context"

type Response struct {
	Value any
	Err   error
}

type Job struct {
	Ctx  context.Context
	Run  func(context.Context) (any, error)
	Resp chan Response
}


##### internal/workerpool/pool.go #####
package workerpool

import (
	"context"
	"sync"
	"sync/atomic"
)

type Pool struct {
	jobs    chan Job
	kill    chan struct{} // сигналы для метода Resize
	rootCtx context.Context
	cancel  context.CancelFunc
	wg      sync.WaitGroup
	workers int32
	mu      sync.RWMutex
	closed  bool
}

func New(workerCnt, queueSize int) *Pool {
	if workerCnt <= 0 {
		workerCnt = 1
	}
	if queueSize <= 0 {
		queueSize = workerCnt * 4
	}

	ctx, cancel := context.WithCancel(context.Background())
	p := &Pool{
		jobs:    make(chan Job, queueSize),
		kill:    make(chan struct{}, workerCnt*2),
		rootCtx: ctx,
		cancel:  cancel,
	}
	atomic.StoreInt32(&p.workers, int32(workerCnt))
	p.spawn(workerCnt)
	return p
}

func (p *Pool) spawn(n int) {
	for i := 0; i < n; i++ {
		p.wg.Add(1)
		go p.worker()
	}
}

func (p *Pool) worker() {
	defer p.wg.Done()
	for {
		select {
		case <-p.kill:
			return
		case job, ok := <-p.jobs:
			if !ok {
				return
			}
			// проверяем отмену контеста до выполнения
			if errCtx := job.Ctx.Err(); errCtx != nil {
				select {
				case job.Resp <- Response{Err: errCtx}:
				default:
				}
				continue
			}

			v, err := job.Run(job.Ctx)
			select {
			case job.Resp <- Response{Value: v, Err: err}:
			case <-job.Ctx.Done():
			}
		case <-p.rootCtx.Done():
			return
		}
	}
}

func (p *Pool) Submit(j Job) {
	select {
	case p.jobs <- j:
	default:
		// случай для заполненной очереди: выполняем задачу синхронно, чтобы не задерживать вызов rpc‑хендлера
		v, err := j.Run(j.Ctx)
		select {
		case j.Resp <- Response{Value: v, Err: err}:
		case <-j.Ctx.Done():
		}
	}
}

func (p *Pool) Resize(n int) {
	if n < 0 {
		return
	}

	p.mu.RLock()
	if p.closed {
		p.mu.RUnlock()
		return
	}
	p.mu.RUnlock()

	cur := int(atomic.LoadInt32(&p.workers))
	if n == cur {
		return
	}

	if n > cur {
		p.spawn(n - cur)
	} else {
		diff := cur - n
		for i := 0; i < diff; i++ {
			p.kill <- struct{}{}
		}
	}
	atomic.StoreInt32(&p.workers, int32(n))
}

func (p *Pool) Close() {
	p.mu.Lock()
	if p.closed {
		p.mu.Unlock()
		return
	}
	p.closed = true
	p.mu.Unlock()

	p.cancel()
	close(p.jobs)
	for i := int32(0); i < atomic.LoadInt32(&p.workers); i++ {
		p.kill <- struct{}{}
	}
	p.wg.Wait()
	close(p.kill)
}


##### migrations/001_init.sql #####
-- +goose Up
CREATE TABLE package_types (
    code          TEXT PRIMARY KEY,
    max_weight    NUMERIC(10,2) NOT NULL,
    extra_price   NUMERIC(10,2) NOT NULL
);

CREATE TABLE orders (
    id               BIGINT       PRIMARY KEY,
    receiver_id      BIGINT       NOT NULL,
    status           SMALLINT     NOT NULL,
    expires_at       TIMESTAMPTZ  NOT NULL,
    accept_time      TIMESTAMPTZ  NOT NULL,
    last_update_time TIMESTAMPTZ  NOT NULL,
    package_code     TEXT         REFERENCES package_types(code),
    weight           NUMERIC(10,2) NOT NULL,
    price            NUMERIC(10,2) NOT NULL
);

CREATE INDEX idx_orders_receiver_status ON orders (receiver_id, status);

-- +goose Down
DROP INDEX IF EXISTS idx_orders_receiver_status;
DROP TABLE IF EXISTS orders;
DROP TABLE IF EXISTS package_types;

##### migrations/002_seed_package_types.sql #####
-- +goose Up
INSERT INTO package_types (code,max_weight,extra_price) VALUES
  ('bag',10,5), ('box',30,20),
  ('film',0,1), ('bag+film',10,6), ('box+film',30,21);

-- +goose Down
DELETE FROM package_types
WHERE code IN ('bag','box','film','bag+film','box+film');

##### migrations/003_order_history.sql #####
-- +goose Up
CREATE TABLE order_history (
    id              BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    order_id        BIGINT NOT NULL REFERENCES orders(id),
    status          SMALLINT NOT NULL,
    changed_at      TIMESTAMPTZ NOT NULL,
    CONSTRAINT fk_order FOREIGN KEY (order_id) REFERENCES orders(id) ON DELETE CASCADE
);

CREATE INDEX idx_order_history_order_id ON order_history (order_id);

-- +goose Down
DROP INDEX IF EXISTS idx_order_history_order_id;
DROP TABLE IF EXISTS order_history;

##### migrations/004_outbox.sql #####
-- +goose Up
CREATE TYPE outbox_status AS ENUM ('CREATED', 'PROCESSING', 'COMPLETED', 'FAILED');

CREATE TABLE outbox (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    payload JSONB NOT NULL,
    status outbox_status NOT NULL,
    error TEXT,
    created_at TIMESTAMPTZ NOT NULL,
    sent_at TIMESTAMPTZ
);

CREATE INDEX idx_outbox_status ON outbox (status, created_at);

-- +goose Down
DROP INDEX IF EXISTS idx_outbox_status;
DROP TABLE IF EXISTS outbox;
DROP TYPE IF EXISTS outbox_status;

##### pkg/db/client.go #####
package db

import (
	"context"
	"database/sql"
	"fmt"
	"log/slog"
	"sync"
)

type ClientMode string

const (
	ModeRead  ClientMode = "read"
	ModeWrite ClientMode = "write"
)

type Client struct {
	readDB  *sql.DB
	writeDB *sql.DB
	logger  *slog.Logger
	txMutex sync.Mutex
}

type Config struct {
	ReadDSN      string
	WriteDSN     string
	MaxOpen      int
	MaxIdle      int
	MaxTxRetries int
}

func NewClient(cfg Config) (*Client, error) {
	logger := slog.Default()

	readDB, err := sql.Open("postgres", cfg.ReadDSN)
	if err != nil {
		return nil, fmt.Errorf("failed to open read DB: %w", err)
	}
	readDB.SetMaxOpenConns(cfg.MaxOpen)
	readDB.SetMaxIdleConns(cfg.MaxIdle)

	writeDB, err := sql.Open("postgres", cfg.WriteDSN)
	if err != nil {
		readDB.Close()
		return nil, fmt.Errorf("failed to open write DB: %w", err)
	}
	writeDB.SetMaxOpenConns(cfg.MaxOpen)
	writeDB.SetMaxIdleConns(cfg.MaxIdle)

	if err := readDB.Ping(); err != nil {
		readDB.Close()
		writeDB.Close()
		return nil, fmt.Errorf("read DB ping failed: %w", err)
	}
	if err := writeDB.Ping(); err != nil {
		readDB.Close()
		writeDB.Close()
		return nil, fmt.Errorf("write DB ping failed: %w", err)
	}

	return &Client{
		readDB:  readDB,
		writeDB: writeDB,
		logger:  logger,
	}, nil
}

func (c *Client) Close() error {
	var err error
	if c.readDB != nil {
		if closeErr := c.readDB.Close(); closeErr != nil {
			err = fmt.Errorf("failed to close read DB: %w", closeErr)
		}
	}
	if c.writeDB != nil {
		if closeErr := c.writeDB.Close(); closeErr != nil {
			err = fmt.Errorf("%v; failed to close write DB: %w", err, closeErr)
		}
	}
	return err
}

func (c *Client) Exec(ctx context.Context, mode ClientMode, query string, args ...interface{}) (sql.Result, error) {
	db := c.getDB(mode)
	result, err := db.ExecContext(ctx, query, args...)
	if err != nil {
		c.logger.Error("Error executing query", "error", err)
		return nil, fmt.Errorf("exec query: %w", err)
	}
	c.logger.Info("Query executed successfully")
	return result, nil
}

func (c *Client) Query(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) {
	rows, err := c.readDB.QueryContext(ctx, query, args...)
	if err != nil {
		c.logger.Error("Error executing query", "error", err)
		return nil, fmt.Errorf("query: %w", err)
	}
	c.logger.Info("Query executed successfully")
	return rows, nil
}

func (c *Client) QueryRow(ctx context.Context, query string, args ...interface{}) *sql.Row {
	row := c.readDB.QueryRowContext(ctx, query, args...)
	return row
}

func (c *Client) BeginTx(ctx context.Context) (*Tx, error) {
	c.txMutex.Lock()
	defer c.txMutex.Unlock()

	tx, err := c.writeDB.BeginTx(ctx, nil)
	if err != nil {
		c.logger.Error("Error starting transaction", "error", err)
		return nil, fmt.Errorf("begin transaction: %w", err)
	}
	c.logger.Info("Transaction started")
	return &Tx{tx: tx, logger: c.logger}, nil
}

func (c *Client) getDB(mode ClientMode) *sql.DB {
	if mode == ModeRead {
		return c.readDB
	}
	return c.writeDB
}


##### pkg/db/transaction.go #####
package db

import (
	"context"
	"database/sql"
	"fmt"
	"log/slog"
)

type Tx struct {
	tx     *sql.Tx
	logger *slog.Logger
}

func (t *Tx) Exec(ctx context.Context, query string, args ...interface{}) (sql.Result, error) {
	result, err := t.tx.ExecContext(ctx, query, args...)
	if err != nil {
		t.logger.Error("Error executing query", "error", err)
		return nil, fmt.Errorf("exec query: %w", err)
	}
	t.logger.Info("Query executed successfully")
	return result, nil
}

func (t *Tx) Query(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) {
	rows, err := t.tx.QueryContext(ctx, query, args...)
	if err != nil {
		t.logger.Error("Error executing query", "error", err)
		return nil, fmt.Errorf("query: %w", err)
	}
	t.logger.Info("Query executed successfully")
	return rows, nil
}

func (t *Tx) QueryRow(ctx context.Context, query string, args ...interface{}) *sql.Row {
	row := t.tx.QueryRowContext(ctx, query, args...)
	return row
}

func (t *Tx) Commit() error {
	err := t.tx.Commit()
	if err != nil {
		t.logger.Error("Error committing transaction", "error", err)
		return fmt.Errorf("commit transaction: %w", err)
	}
	t.logger.Info("Transaction committed")
	return nil
}

func (t *Tx) Rollback() error {
	err := t.tx.Rollback()
	if err != nil {
		t.logger.Error("Error rolling back transaction", "error", err)
		return fmt.Errorf("rollback transaction: %w", err)
	}
	t.logger.Info("Transaction rolled back")
	return nil
}


##### tests/suites/e2e/e2e.go #####
package e2e

import (
	"context"
	"database/sql"
	"fmt"
	"net"
	"path/filepath"
	"testing"
	"time"

	_ "github.com/lib/pq"
	"github.com/pressly/goose/v3"
	"github.com/stretchr/testify/require"
	"github.com/stretchr/testify/suite"
	"github.com/testcontainers/testcontainers-go"
	"github.com/testcontainers/testcontainers-go/wait"

	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/protobuf/types/known/timestamppb"

	server "gitlab.ozon.dev/safariproxd/homework/internal/adapter/grpc"
	"gitlab.ozon.dev/safariproxd/homework/internal/adapter/grpc/mw"
	"gitlab.ozon.dev/safariproxd/homework/internal/app"
	"gitlab.ozon.dev/safariproxd/homework/internal/repository/postgres"
	"gitlab.ozon.dev/safariproxd/homework/pkg/api"
	dbpkg "gitlab.ozon.dev/safariproxd/homework/pkg/db"

	"github.com/ulule/limiter/v3"
	"github.com/ulule/limiter/v3/drivers/store/memory"
)

const (
	postgresImage = "postgres:16-alpine"
	postgresUser  = "user"
	postgresPass  = "password"
	postgresDB    = "testdb"
)

type testEnv struct {
	ctx          context.Context
	container    testcontainers.Container
	dbClient     *dbpkg.Client
	grpcConn     *grpc.ClientConn
	ordersClient api.OrdersServiceClient
	stopServer   func()
}

func (e *testEnv) Close() {
	if e.grpcConn != nil {
		_ = e.grpcConn.Close()
	}
	if e.stopServer != nil {
		e.stopServer()
	}
	if e.dbClient != nil {
		_ = e.dbClient.Close()
	}
	if e.container != nil {
		_ = e.container.Terminate(e.ctx)
	}
}

func setupEnv(t *testing.T) *testEnv {
	t.Helper()

	ctx := context.Background()
	req := testcontainers.ContainerRequest{
		Image:        postgresImage,
		ExposedPorts: []string{"5432/tcp"},
		Env: map[string]string{
			"POSTGRES_USER":     postgresUser,
			"POSTGRES_PASSWORD": postgresPass,
			"POSTGRES_DB":       postgresDB,
		},
		WaitingFor: wait.ForListeningPort("5432/tcp"),
	}
	container, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
		ContainerRequest: req,
		Started:          true,
	})
	require.NoError(t, err)

	host, err := container.Host(ctx)
	require.NoError(t, err)
	port, err := container.MappedPort(ctx, "5432/tcp")
	require.NoError(t, err)
	dsn := fmt.Sprintf("postgres://%s:%s@%s:%s/%s?sslmode=disable", postgresUser, postgresPass, host, port.Port(), postgresDB)

	sqlDB, err := sql.Open("postgres", dsn)
	require.NoError(t, err)
	require.Eventually(t, func() bool { return sqlDB.PingContext(ctx) == nil }, 15*time.Second, time.Second)

	goose.SetDialect("postgres")
	repoRoot, err := filepath.Abs(filepath.Join("..", ".."))
	require.NoError(t, err)
	migrationsDir := filepath.Join(repoRoot, "migrations")
	require.NoError(t, goose.Up(sqlDB, migrationsDir))

	dbCfg := dbpkg.Config{ReadDSN: dsn, WriteDSN: dsn, MaxOpen: 5, MaxIdle: 5}
	dbClient, err := dbpkg.NewClient(dbCfg)
	require.NoError(t, err)

	repo := postgres.NewOrderRepository(dbClient)
	outbox := postgres.NewOutboxRepository(dbClient)
	svc := app.NewPVZService(repo, outbox, dbClient, time.Now, 16)

	lis, err := net.Listen("tcp", "127.0.0.1:0")
	require.NoError(t, err)

	limiterInstance := limiter.New(memory.NewStore(), limiter.Rate{Period: time.Second, Limit: 5})
	grpcServer := grpc.NewServer(
		grpc.ChainUnaryInterceptor(
			mw.TimeoutInterceptor(2*time.Second),
			mw.LoggingInterceptor(),
			mw.ValidationInterceptor(),
			mw.ErrorMappingInterceptor(),
			mw.RateLimiterInterceptor(limiterInstance),
		),
	)
	server.NewOrdersServer(svc).Register(grpcServer)

	go func() { _ = grpcServer.Serve(lis) }()

	conn, err := grpc.NewClient(lis.Addr().String(), grpc.WithTransportCredentials(insecure.NewCredentials()))
	require.NoError(t, err)

	env := &testEnv{
		ctx:          ctx,
		container:    container,
		dbClient:     dbClient,
		grpcConn:     conn,
		ordersClient: api.NewOrdersServiceClient(conn),
		stopServer:   grpcServer.Stop,
	}

	t.Cleanup(env.Close)
	return env
}

type OrdersE2ESuite struct {
	suite.Suite
	env *testEnv
}

func (s *OrdersE2ESuite) SetupTest() {
	s.env = setupEnv(s.T())
}

func (s *OrdersE2ESuite) TearDownTest() {
	if s.env != nil {
		s.env.Close()
	}
}

func (s *OrdersE2ESuite) TestAcceptAndListOrders() {
	orderID := uint64(1)
	userID := uint64(42)

	pkgType := api.PackageType_PACKAGE_TYPE_BOX

	_, err := s.env.ordersClient.AcceptOrder(s.env.ctx, &api.AcceptOrderRequest{
		OrderId:   orderID,
		UserId:    userID,
		ExpiresAt: timestamppb.New(time.Now().Add(24 * time.Hour)),
		Package:   &pkgType,
		Weight:    2.5,
		Price:     100,
	})
	s.Require().NoError(err)

	listResp, err := s.env.ordersClient.ListOrders(s.env.ctx, &api.ListOrdersRequest{
		UserId:     userID,
		InPvz:      true,
		Pagination: &api.Pagination{Page: 1, CountOnPage: 10},
	})
	s.Require().NoError(err)
	s.Require().Len(listResp.Orders, 1)

	got := listResp.Orders[0]
	s.Equal(orderID, got.OrderId)
	s.Equal(api.OrderStatus_ORDER_STATUS_EXPECTS, got.Status)
}

func (s *OrdersE2ESuite) TestAcceptAndIssueOrders() {
	orderID := uint64(2)
	userID := uint64(99)

	pkgType := api.PackageType_PACKAGE_TYPE_BOX

	_, err := s.env.ordersClient.AcceptOrder(s.env.ctx, &api.AcceptOrderRequest{
		OrderId:   orderID,
		UserId:    userID,
		ExpiresAt: timestamppb.New(time.Now().Add(24 * time.Hour)),
		Package:   &pkgType,
		Weight:    1.1,
		Price:     55.5,
	})
	s.Require().NoError(err)

	procResp, err := s.env.ordersClient.ProcessOrders(s.env.ctx, &api.ProcessOrdersRequest{
		UserId:   userID,
		Action:   api.ActionType_ACTION_TYPE_ISSUE,
		OrderIds: []uint64{orderID},
	})
	s.Require().NoError(err)
	s.ElementsMatch([]uint64{orderID}, procResp.Processed)
	s.Empty(procResp.Errors)

	listResp, err := s.env.ordersClient.ListOrders(s.env.ctx, &api.ListOrdersRequest{
		UserId:     userID,
		Pagination: &api.Pagination{Page: 1, CountOnPage: 10},
	})
	s.Require().NoError(err)
	s.Require().Len(listResp.Orders, 1)
	s.Equal(api.OrderStatus_ORDER_STATUS_ACCEPTED, listResp.Orders[0].Status)
}


##### tests/suites/order/postgres_repo.go #####
package postgres_repo

import (
	"context"
	"database/sql"
	"fmt"
	"path/filepath"
	"time"

	"github.com/pressly/goose/v3"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/stretchr/testify/suite"
	"github.com/testcontainers/testcontainers-go"
	"github.com/testcontainers/testcontainers-go/wait"

	_ "github.com/lib/pq"

	"gitlab.ozon.dev/safariproxd/homework/internal/domain"
	"gitlab.ozon.dev/safariproxd/homework/internal/repository/postgres"
	dbpkg "gitlab.ozon.dev/safariproxd/homework/pkg/db"
)

// надо вынести в конфиг наверное
const (
	postgresImage = "postgres:16-alpine"
	postgresUser  = "user"
	postgresPass  = "password"
	postgresDB    = "testdb"
)

type OrderRepositorySuite struct {
	suite.Suite
	ctx                context.Context
	pgContainer        testcontainers.Container
	dsn                string
	sqlDB              *sql.DB
	dbClient           *dbpkg.Client
	orderRepo          *postgres.OrderRepository
	migrationsLocation string
}

func (s *OrderRepositorySuite) SetupSuite() {
	s.ctx = context.Background()

	req := testcontainers.ContainerRequest{
		Image:        postgresImage,
		ExposedPorts: []string{"5432/tcp"},
		Env: map[string]string{
			"POSTGRES_USER":     postgresUser,
			"POSTGRES_PASSWORD": postgresPass,
			"POSTGRES_DB":       postgresDB,
		},
		WaitingFor: wait.ForListeningPort("5432/tcp"),
	}
	container, err := testcontainers.GenericContainer(s.ctx, testcontainers.GenericContainerRequest{
		ContainerRequest: req,
		Started:          true,
	})
	require.NoError(s.T(), err)
	s.pgContainer = container

	host, err := container.Host(s.ctx)
	require.NoError(s.T(), err)
	port, err := container.MappedPort(s.ctx, "5432/tcp")
	require.NoError(s.T(), err)
	s.dsn = fmt.Sprintf("postgres://%s:%s@%s:%s/%s?sslmode=disable", postgresUser, postgresPass, host, port.Port(), postgresDB)

	sqlDB, err := sql.Open("postgres", s.dsn)
	require.NoError(s.T(), err)
	s.sqlDB = sqlDB
	require.Eventually(s.T(), func() bool { return sqlDB.PingContext(s.ctx) == nil }, 10*time.Second, time.Second)

	goose.SetDialect("postgres")
	root, err := filepath.Abs(filepath.Join("..", ".."))
	require.NoError(s.T(), err)

	s.migrationsLocation = filepath.Join(root, "migrations")
	require.NoError(s.T(), goose.Up(sqlDB, s.migrationsLocation))

	cfg := dbpkg.Config{
		ReadDSN:  s.dsn,
		WriteDSN: s.dsn,
		MaxOpen:  5,
		MaxIdle:  5,
	}
	s.dbClient, err = dbpkg.NewClient(cfg)
	require.NoError(s.T(), err)

	s.orderRepo = postgres.NewOrderRepository(s.dbClient)
}

func (s *OrderRepositorySuite) TearDownSuite() {
	if s.dbClient != nil {
		_ = s.dbClient.Close()
	}
	if s.sqlDB != nil {
		_ = s.sqlDB.Close()
	}
	if s.pgContainer != nil {
		_ = s.pgContainer.Terminate(s.ctx)
	}
}

func makeTestOrder(id uint64) domain.Order {
	now := time.Now().UTC().Truncate(time.Second)

	return domain.Order{
		OrderID:        id,
		ReceiverID:     99,
		StorageUntil:   now.Add(48 * time.Hour),
		Status:         domain.StatusInStorage,
		AcceptTime:     now,
		LastUpdateTime: now,
		PackageType:    "box",
		Weight:         1.23,
		Price:          456.78,
	}
}

func (s *OrderRepositorySuite) Test_Save_And_GetByID() {
	ctx := s.ctx
	order := makeTestOrder(1)

	require.NoError(s.T(), s.orderRepo.Save(ctx, order))

	got, err := s.orderRepo.GetByID(ctx, order.OrderID)
	require.NoError(s.T(), err)
	assert.Equal(s.T(), order.OrderID, got.OrderID)
	assert.Equal(s.T(), order.Price, got.Price)
}

func (s *OrderRepositorySuite) Test_Exists() {
	ctx := s.ctx
	order := makeTestOrder(2)

	ok, err := s.orderRepo.Exists(ctx, order.OrderID)
	require.NoError(s.T(), err)
	assert.False(s.T(), ok)

	require.NoError(s.T(), s.orderRepo.Save(ctx, order))
	ok, err = s.orderRepo.Exists(ctx, order.OrderID)
	require.NoError(s.T(), err)
	assert.True(s.T(), ok)
}

func (s *OrderRepositorySuite) Test_Update() {
	ctx := s.ctx
	order := makeTestOrder(3)
	require.NoError(s.T(), s.orderRepo.Save(ctx, order))

	order.Status = domain.StatusGivenToCourier
	order.Price = 999.99
	order.LastUpdateTime = time.Now().UTC()

	require.NoError(s.T(), s.orderRepo.Update(ctx, order))

	got, err := s.orderRepo.GetByID(ctx, order.OrderID)
	require.NoError(s.T(), err)
	assert.Equal(s.T(), domain.StatusGivenToCourier, got.Status)
	assert.EqualValues(s.T(), 999.99, got.Price)
}

func (s *OrderRepositorySuite) Test_SaveHistory() {
	ctx := s.ctx
	order := makeTestOrder(4)
	require.NoError(s.T(), s.orderRepo.Save(ctx, order))

	h := domain.OrderHistory{
		OrderID:   order.OrderID,
		Status:    domain.StatusReturnedFromClient,
		ChangedAt: time.Now().UTC(),
	}
	require.NoError(s.T(), s.orderRepo.SaveHistory(ctx, h))

	history, err := s.orderRepo.GetHistoryByOrderID(ctx, order.OrderID)
	require.NoError(s.T(), err)
	require.Len(s.T(), history, 1)
	assert.Equal(s.T(), h.Status, history[0].Status)
}


